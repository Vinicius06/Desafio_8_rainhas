{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment Documenta\'E7\'E3o  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0 \par
}}Documenta\'E7\'E3o}
{\comment Gerado por doxygen 1.9.7.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt Documenta\'E7\'E3o}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Vers\'E3o 1.0\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Sum\'E1rio\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\par \pard\plain 
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
README\par \pard\plain 
{\tc\tcl1 \v README}
{\xe \v README}
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'EF\'BB\'BF# Desafio_8_rainhas \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespaces\par \pard\plain 
{\tc \v Namespaces}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de Namespaces\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Esta \'E9 a lista de todos os Namespaces com suas respectivas descri\'E7\'F5es:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b Catch} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Detail} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::Floating} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::Impl} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::StdString} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::Vector} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::Vector::Detail} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice Hier\'E1rquico\par \pard\plain 
{\tc \v \'CDndice Hier\'E1rquico}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Hierarquia de Classes\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Esta lista de hierarquias est\'E1 parcialmente ordenada (ordem alfab\'E9tica):}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Detail::Approx\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::AssertionHandler\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::AssertionInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::AssertionReaction\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAID \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::BenchmarkLooper\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::StdString::CasedString\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::CaseSensitive\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch_global_namespace_dummy\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Counts\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Decomposer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ExceptionTranslatorRegistrar\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ExprLhs< LhsT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::IExceptionTranslator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::IExceptionTranslatorRegistry\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::IMutableRegistryHub\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::IRegistryHub\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::IResultCapture\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::IRunner\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::is_range< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Detail::IsStreamInsertable< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::IStream\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ITestCaseRegistry\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ITestInvoker\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALW \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::TestInvokerAsMethod< C >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::ITransientExpression\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMA \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::BinaryExpr< LhsT, RhsT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::MatchExpr< ArgT, MatcherT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::UnaryExpr< LhsT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::LazyExpression\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::Impl::MatcherMethod< ObjectT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Matchers::Impl::MatcherBase< double >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::Impl::MatcherBase< ArgT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXM \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Matchers::Impl::MatchAllOf< ArgT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::Impl::MatchAnyOf< ArgT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::Impl::MatchNotOf< ArgT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::Matchers::Impl::MatcherBase< std::string >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::Impl::MatcherBase< std::vector< T > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::Matchers::Impl::MatcherMethod< ArgT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::Impl::MatcherMethod< double >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::Impl::MatcherMethod< PtrT * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::Impl::MatcherMethod< std::string >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::Impl::MatcherMethod< std::vector< T > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::Impl::MatcherMethod< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Matchers::Impl::MatcherBase< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXM \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Matchers::Floating::WithinAbsMatcher\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::Floating::WithinUlpsMatcher\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::StdString::RegexMatcher\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::StdString::StringMatcherBase\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZI \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Matchers::StdString::ContainsMatcher\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::StdString::EndsWithMatcher\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::StdString::EqualsMatcher\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::StdString::StartsWithMatcher\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::Matchers::Vector::ContainsElementMatcher< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::Vector::ContainsMatcher< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::Vector::EqualsMatcher< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::Vector::UnorderedEqualsMatcher< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
Catch::Matchers::Impl::MatcherUntypedBase\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXU \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Matchers::Impl::MatcherBase< double >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::Impl::MatcherBase< ArgT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::Impl::MatcherBase< std::string >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::Impl::MatcherBase< std::vector< T > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Matchers::Impl::MatcherBase< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::MessageInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::MessageStream\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANH \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::MessageBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::NameAndTags\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::NonCopyable\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANO \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::AutoReg\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Section\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::not_this_one\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::pluralise\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::RegistrarForTagAliases\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ResultDisposition\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ResultWas\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ReusableStringStream\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ScopedMessage\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::SectionEndInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::SectionInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::SourceLineInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StreamEndStop\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< T, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< bool >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< Catch::Detail::Approx >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< char * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< char >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< char const * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< char[SZ]>\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< double >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< float >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< int >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< long >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< long long >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< R C::* >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< R, typename std::enable_if< is_range< R >::value &&!::Catch::Detail::IsStreamInsertable< R >::value >::type >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< signed char >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< signed char[SZ]>\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< std::nullptr_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< std::string >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< std::wstring >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< T * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< T[SZ]>\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< unsigned char >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< unsigned char[SZ]>\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< unsigned int >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< unsigned long >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< unsigned long long >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< wchar_t * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< wchar_t const * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringRef\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::TestCaseInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATN \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::TestCase\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::TestFailureException\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Timer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Totals\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice dos Componentes\par \pard\plain 
{\tc \v \'CDndice dos Componentes}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de Classes\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Aqui est\'E3o as classes, estruturas, uni\'F5es e interfaces e suas respectivas descri\'E7\'F5es:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b Catch::Detail::Approx} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::AssertionHandler} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::AssertionInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::AssertionReaction} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAID \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::AutoReg} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::BenchmarkLooper} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::BinaryExpr< LhsT, RhsT >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::StdString::CasedString} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::CaseSensitive} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch_global_namespace_dummy} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::Vector::ContainsElementMatcher< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::StdString::ContainsMatcher} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::Vector::ContainsMatcher< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Counts} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Decomposer} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::StdString::EndsWithMatcher} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::StdString::EqualsMatcher} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::Vector::EqualsMatcher< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ExceptionTranslatorRegistrar} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ExprLhs< LhsT >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::IExceptionTranslator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::IExceptionTranslatorRegistry} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::IMutableRegistryHub} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::IRegistryHub} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::IResultCapture} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::IRunner} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::is_range< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Detail::IsStreamInsertable< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::IStream} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ITestCaseRegistry} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ITestInvoker} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ITransientExpression} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::LazyExpression} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::Impl::MatchAllOf< ArgT >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::Impl::MatchAnyOf< ArgT >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::Impl::MatcherBase< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::Impl::MatcherMethod< ObjectT >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::Impl::MatcherMethod< PtrT * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::Impl::MatcherUntypedBase} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::MatchExpr< ArgT, MatcherT >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::Impl::MatchNotOf< ArgT >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::MessageBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::MessageInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::MessageStream} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::NameAndTags} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::NonCopyable} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::not_this_one} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::pluralise} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::StdString::RegexMatcher} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::RegistrarForTagAliases} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ResultDisposition} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ResultWas} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ReusableStringStream} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ScopedMessage} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Section} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::SectionEndInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::SectionInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::SourceLineInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::StdString::StartsWithMatcher} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StreamEndStop} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< T, typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< bool >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< Catch::Detail::Approx >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< char * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< char >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< char const * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< char[SZ]>} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< double >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< float >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< int >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< long >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< long long >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< R C::* >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< R, typename std::enable_if< is_range< R >::value &&!::Catch::Detail::IsStreamInsertable< R >::value >::type >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< signed char >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< signed char[SZ]>} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< std::nullptr_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< std::string >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< std::wstring >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< T * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< T[SZ]>} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< unsigned char >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< unsigned char[SZ]>} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< unsigned int >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< unsigned long >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< unsigned long long >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< wchar_t * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< wchar_t const * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::StdString::StringMatcherBase} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringRef} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::TestCase} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::TestCaseInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::TestFailureException} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::TestInvokerAsMethod< C >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Timer} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Totals} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::UnaryExpr< LhsT >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::Vector::UnorderedEqualsMatcher< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::Floating::WithinAbsMatcher} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::Floating::WithinUlpsMatcher} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice dos Arquivos\par \pard\plain 
{\tc \v \'CDndice dos Arquivos}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de Arquivos\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Esta \'E9 a lista de todos os arquivos e suas respectivas descri\'E7\'F5es:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b desafio_8_rainhas/{\b catch.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b desafio_8_rainhas/{\b rainhas.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b desafio_8_rainhas/{\b rainhas.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b desafio_8_rainhas/{\b testa_rainhas.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch\par \pard\plain 
{\tc\tcl2 \v Catch}
{\xe \v Catch}
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Detail}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Matchers}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AssertionHandler}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b AssertionInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b AssertionReaction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b AutoReg}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BenchmarkLooper}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BinaryExpr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CaseSensitive}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Counts}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Decomposer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ExceptionTranslatorRegistrar}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ExprLhs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IExceptionTranslator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IExceptionTranslatorRegistry}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IMutableRegistryHub}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IRegistryHub}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IResultCapture}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IRunner}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_range}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IStream}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ITestCaseRegistry}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ITestInvoker}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ITransientExpression}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LazyExpression}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MatchExpr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MessageBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MessageInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MessageStream}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NameAndTags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b NonCopyable}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b not_this_one}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pluralise}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b RegistrarForTagAliases}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ResultDisposition}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ResultWas}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ReusableStringStream}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ScopedMessage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Section}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SectionEndInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SectionInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SourceLineInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StreamEndStop}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< bool >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< Catch::Detail::Approx >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< char * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< char >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< char const * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< char[SZ]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< double >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< float >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< int >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< long >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< long long >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< R C::* >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< R, typename std::enable_if< is_range< R >::value &&!::Catch::Detail::IsStreamInsertable< R >::value >::type >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< signed char >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< signed char[SZ]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< std::nullptr_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< std::string >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< std::wstring >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< T * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< T[SZ]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< unsigned char >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< unsigned char[SZ]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< unsigned int >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< unsigned long >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< unsigned long long >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< wchar_t * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< wchar_t const * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StringRef}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestCase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TestCaseInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TestFailureException}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestInvokerAsMethod}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Timer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Totals}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UnaryExpr}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de Tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b ITestCasePtr} = std::shared_ptr< {\b ITestInvoker} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b IReporterFactoryPtr} = std::shared_ptr< IReporterFactory >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b exceptionTranslateFunction} = std::string(*)()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b ExceptionTranslators} = std::vector< std::unique_ptr< {\b IExceptionTranslator} const  > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b StringMatcher} = {\b Matchers::Impl::MatcherBase}< std::string >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b rngSeed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &os, {\b SourceLineInfo} const &info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > T const & {\b operator+} (T const &value, {\b StreamEndStop})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b matchTest} ({\b TestCase} const &testCase, TestSpec const &testSpec, IConfig const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b TestCase} > {\b filterTests} (std::vector< {\b TestCase} > const &testCases, TestSpec const &testSpec, IConfig const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b TestCase} > const & {\b getAllTestCasesSorted} (IConfig const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator+} ({\b StringRef} const &lhs, {\b StringRef} const &rhs) -> std::string\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator+} ({\b StringRef} const &lhs, char const *rhs) -> std::string\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator+} (char const *lhs, {\b StringRef} const &rhs) -> std::string\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator+=} (std::string &lhs, {\b StringRef} const &sr) -> std::string &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator<<} (std::ostream &os, {\b StringRef} const &sr) -> std::ostream &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator""_sr} (char const *rawChars, std::size_t size) noexcept -> {\b StringRef}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b makeTestInvoker} (void(*testAsFunction)()) noexcept -> {\b ITestInvoker} *\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C > auto {\b makeTestInvoker} (void(C::*testAsMethod)()) noexcept -> {\b ITestInvoker} *\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isOk} ({\b ResultWas::OfType} resultType)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isJustInfo} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultDisposition::Flags} {\b operator|} ({\b ResultDisposition::Flags} lhs, {\b ResultDisposition::Flags} rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shouldContinueOnFailure} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isFalseTest} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shouldSuppressFailure} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b cout} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b cerr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b clog} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b makeStream} ({\b StringRef} const &filename) -> {\b IStream} const *\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Range > std::string {\b rangeToString} (Range const &range)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Allocator > std::string {\b rangeToString} (std::vector< bool, Allocator > const &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b formatReconstructedExpression} (std::ostream &os, std::string const &lhs, {\b StringRef} op, std::string const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename LhsT , typename RhsT > auto {\b compareEqual} (LhsT const &lhs, RhsT const &rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b compareEqual} (T *const &lhs, int rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b compareEqual} (T *const &lhs, long rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b compareEqual} (int lhs, T *const &rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b compareEqual} (long lhs, T *const &rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename LhsT , typename RhsT > auto {\b compareNotEqual} (LhsT const &lhs, RhsT &&rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b compareNotEqual} (T *const &lhs, int rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b compareNotEqual} (T *const &lhs, long rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b compareNotEqual} (int lhs, T *const &rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b compareNotEqual} (long lhs, T *const &rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleExpression} ({\b ITransientExpression} const &expr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b handleExpression} ({\b ExprLhs}< T > const &expr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IResultCapture} & {\b getResultCapture} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleExceptionMatchExpr} ({\b AssertionHandler} &handler, std::string const &str, {\b StringRef} matcherString)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b getCurrentNanosecondsSinceEpoch} () -> uint64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b getEstimatedClockResolution} () -> uint64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IRegistryHub} & {\b getRegistryHub} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IMutableRegistryHub} & {\b getMutableRegistryHub} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cleanUp} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b translateActiveException} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b startsWith} (std::string const &s, std::string const &prefix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b startsWith} (std::string const &s, char prefix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b endsWith} (std::string const &s, std::string const &suffix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b endsWith} (std::string const &s, char suffix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b contains} (std::string const &s, std::string const &infix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b toLowerInPlace} (std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toLower} (std::string const &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b trim} (std::string const &str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b replaceInPlace} (std::string &str, std::string const &replaceThis, std::string const &withThis)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleExceptionMatchExpr} ({\b AssertionHandler} &handler, {\b StringMatcher} const &matcher, {\b StringRef} matcherString)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ArgT , typename MatcherT > auto {\b makeMatchExpr} (ArgT const &arg, MatcherT const &matcher, {\b StringRef} matcherString) -> {\b MatchExpr}< ArgT, MatcherT >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestCase} {\b makeTestCase} ({\b ITestInvoker} *testCase, std::string const &className, {\b NameAndTags} const &nameAndTags, {\b SourceLineInfo} const &lineInfo)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Vari\'E1veis\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b not_this_one} {\b begin} (...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b not_this_one} {\b end} (...)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es dos tipos\par
\pard\plain 
{\xe \v exceptionTranslateFunction\:Catch}
{\xe \v Catch\:exceptionTranslateFunction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::exceptionTranslateFunction} = typedef std::string(*)()}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ExceptionTranslators\:Catch}
{\xe \v Catch\:ExceptionTranslators}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::ExceptionTranslators} = typedef std::vector<std::unique_ptr<{\b IExceptionTranslator} const> >}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IReporterFactoryPtr\:Catch}
{\xe \v Catch\:IReporterFactoryPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::IReporterFactoryPtr} = typedef std::shared_ptr<IReporterFactory>}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ITestCasePtr\:Catch}
{\xe \v Catch\:ITestCasePtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::ITestCasePtr} = typedef std::shared_ptr<{\b ITestInvoker}>}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v StringMatcher\:Catch}
{\xe \v Catch\:StringMatcher}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::StringMatcher} = typedef {\b Matchers::Impl::MatcherBase}<std::string>}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v cerr\:Catch}
{\xe \v Catch\:cerr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & Catch::cerr ()}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v cleanUp\:Catch}
{\xe \v Catch\:cleanUp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::cleanUp ()}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v clog\:Catch}
{\xe \v Catch\:clog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & Catch::clog ()}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v compareEqual\:Catch}
{\xe \v Catch\:compareEqual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > auto Catch::compareEqual (int  {\i lhs}, T *const &  {\i rhs}) -> bool }}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1319 \{ {\cf19 return} {\cf17 reinterpret_cast<}{\cf18 void} const*{\cf17 >}( lhs ) == rhs; \}\par
}
}
{\xe \v compareEqual\:Catch}
{\xe \v Catch\:compareEqual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT , typename RhsT > auto Catch::compareEqual (LhsT const &  {\i lhs}, RhsT const &  {\i rhs}) -> bool }}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1313 \{ {\cf19 return} {\cf17 static_cast<}{\cf18 bool}{\cf17 >}(lhs == rhs); \}\par
}
}
{\xe \v compareEqual\:Catch}
{\xe \v Catch\:compareEqual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > auto Catch::compareEqual (long  {\i lhs}, T *const &  {\i rhs}) -> bool }}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1321 \{ {\cf19 return} {\cf17 reinterpret_cast<}{\cf18 void} const*{\cf17 >}( lhs ) == rhs; \}\par
}
}
{\xe \v compareEqual\:Catch}
{\xe \v Catch\:compareEqual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > auto Catch::compareEqual (T *const &  {\i lhs}, int  {\i rhs}) -> bool }}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1315 \{ {\cf19 return} lhs == {\cf17 reinterpret_cast<}{\cf18 void} const*{\cf17 >}( rhs ); \}\par
}
}
{\xe \v compareEqual\:Catch}
{\xe \v Catch\:compareEqual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > auto Catch::compareEqual (T *const &  {\i lhs}, long  {\i rhs}) -> bool }}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1317 \{ {\cf19 return} lhs == {\cf17 reinterpret_cast<}{\cf18 void} const*{\cf17 >}( rhs ); \}\par
}
}
{\xe \v compareNotEqual\:Catch}
{\xe \v Catch\:compareNotEqual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > auto Catch::compareNotEqual (int  {\i lhs}, T *const &  {\i rhs}) -> bool }}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1330 \{ {\cf19 return} {\cf17 reinterpret_cast<}{\cf18 void} const*{\cf17 >}( lhs ) != rhs; \}\par
}
}
{\xe \v compareNotEqual\:Catch}
{\xe \v Catch\:compareNotEqual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT , typename RhsT > auto Catch::compareNotEqual (LhsT const &  {\i lhs}, RhsT &&  {\i rhs}) -> bool }}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1324 \{ {\cf19 return} {\cf17 static_cast<}{\cf18 bool}{\cf17 >}(lhs != rhs); \}\par
}
}
{\xe \v compareNotEqual\:Catch}
{\xe \v Catch\:compareNotEqual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > auto Catch::compareNotEqual (long  {\i lhs}, T *const &  {\i rhs}) -> bool }}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1332 \{ {\cf19 return} {\cf17 reinterpret_cast<}{\cf18 void} const*{\cf17 >}( lhs ) != rhs; \}\par
}
}
{\xe \v compareNotEqual\:Catch}
{\xe \v Catch\:compareNotEqual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > auto Catch::compareNotEqual (T *const &  {\i lhs}, int  {\i rhs}) -> bool }}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1326 \{ {\cf19 return} lhs != {\cf17 reinterpret_cast<}{\cf18 void} const*{\cf17 >}( rhs ); \}\par
}
}
{\xe \v compareNotEqual\:Catch}
{\xe \v Catch\:compareNotEqual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > auto Catch::compareNotEqual (T *const &  {\i lhs}, long  {\i rhs}) -> bool }}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1328 \{ {\cf19 return} lhs != {\cf17 reinterpret_cast<}{\cf18 void} const*{\cf17 >}( rhs ); \}\par
}
}
{\xe \v contains\:Catch}
{\xe \v Catch\:contains}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::contains (std::string const &  {\i s}, std::string const &  {\i infix})}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v cout\:Catch}
{\xe \v Catch\:cout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & Catch::cout ()}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v endsWith\:Catch}
{\xe \v Catch\:endsWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::endsWith (std::string const &  {\i s}, char  {\i suffix})}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v endsWith\:Catch}
{\xe \v Catch\:endsWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::endsWith (std::string const &  {\i s}, std::string const &  {\i suffix})}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v filterTests\:Catch}
{\xe \v Catch\:filterTests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b TestCase} > Catch::filterTests (std::vector< {\b TestCase} > const &  {\i testCases}, TestSpec const &  {\i testSpec}, IConfig const &  {\i config})}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v formatReconstructedExpression\:Catch}
{\xe \v Catch\:formatReconstructedExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::formatReconstructedExpression (std::ostream &  {\i os}, std::string const &  {\i lhs}, {\b StringRef}  {\i op}, std::string const &  {\i rhs})}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getAllTestCasesSorted\:Catch}
{\xe \v Catch\:getAllTestCasesSorted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b TestCase} > const  & Catch::getAllTestCasesSorted (IConfig const &  {\i config})}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getCurrentNanosecondsSinceEpoch\:Catch}
{\xe \v Catch\:getCurrentNanosecondsSinceEpoch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::getCurrentNanosecondsSinceEpoch () ->  uint64_t}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getEstimatedClockResolution\:Catch}
{\xe \v Catch\:getEstimatedClockResolution}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::getEstimatedClockResolution () ->  uint64_t}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getMutableRegistryHub\:Catch}
{\xe \v Catch\:getMutableRegistryHub}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IMutableRegistryHub} & Catch::getMutableRegistryHub ()}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getRegistryHub\:Catch}
{\xe \v Catch\:getRegistryHub}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IRegistryHub} & Catch::getRegistryHub ()}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getResultCapture\:Catch}
{\xe \v Catch\:getResultCapture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IResultCapture} & Catch::getResultCapture ()}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleExceptionMatchExpr\:Catch}
{\xe \v Catch\:handleExceptionMatchExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::handleExceptionMatchExpr ({\b AssertionHandler} &  {\i handler}, std::string const &  {\i str}, {\b StringRef}  {\i matcherString})}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleExceptionMatchExpr\:Catch}
{\xe \v Catch\:handleExceptionMatchExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::handleExceptionMatchExpr ({\b AssertionHandler} &  {\i handler}, {\b StringMatcher} const &  {\i matcher}, {\b StringRef}  {\i matcherString})}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleExpression\:Catch}
{\xe \v Catch\:handleExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void Catch::handleExpression ({\b ExprLhs}< T > const &  {\i expr})}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1381                                                     \{\par
1382         handleExpression( expr.makeUnaryExpr() );\par
1383     \}\par
}
}
{\xe \v handleExpression\:Catch}
{\xe \v Catch\:handleExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::handleExpression ({\b ITransientExpression} const &  {\i expr})}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v isFalseTest\:Catch}
{\xe \v Catch\:isFalseTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::isFalseTest (int  {\i flags}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 612 \{ {\cf19 return} ( flags & ResultDisposition::FalseTest ) != 0; \}\par
}
}
{\xe \v isJustInfo\:Catch}
{\xe \v Catch\:isJustInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::isJustInfo (int  {\i flags})}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v isOk\:Catch}
{\xe \v Catch\:isOk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::isOk ({\b ResultWas::OfType}  {\i resultType})}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v makeMatchExpr\:Catch}
{\xe \v Catch\:makeMatchExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ArgT , typename MatcherT > auto Catch::makeMatchExpr (ArgT const &  {\i arg}, MatcherT const &  {\i matcher}, {\b StringRef}  {\i matcherString}) -> {\b MatchExpr}<ArgT, MatcherT> }}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2632                                                                                                                           \{\par
2633         {\cf19 return} MatchExpr<ArgT, MatcherT>( arg, matcher, matcherString );\par
2634     \}\par
}
}
{\xe \v makeStream\:Catch}
{\xe \v Catch\:makeStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::makeStream ({\b StringRef} const &  {\i filename}) ->  {\b IStream} const *}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v makeTestCase\:Catch}
{\xe \v Catch\:makeTestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestCase} Catch::makeTestCase ({\b ITestInvoker} *  {\i testCase}, std::string const &  {\i className}, {\b NameAndTags} const &  {\i nameAndTags}, {\b SourceLineInfo} const &  {\i lineInfo})}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v makeTestInvoker\:Catch}
{\xe \v Catch\:makeTestInvoker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::makeTestInvoker (void(*)()  {\i testAsFunction}) ->  {\b ITestInvoker} *{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v makeTestInvoker\:Catch}
{\xe \v Catch\:makeTestInvoker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C > auto Catch::makeTestInvoker (void(C::*)()  {\i testAsMethod}) -> {\b ITestInvoker}* {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 499                                                                           \{\par
500     {\cf19 return} {\cf17 new}(std::nothrow) TestInvokerAsMethod<C>( testAsMethod );\par
501 \}\par
}
}
{\xe \v matchTest\:Catch}
{\xe \v Catch\:matchTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::matchTest ({\b TestCase} const &  {\i testCase}, TestSpec const &  {\i testSpec}, IConfig const &  {\i config})}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator""_sr\:Catch}
{\xe \v Catch\:operator""_sr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::operator""_sr (char const *  {\i rawChars}, std::size_t  {\i size}) -> {\b StringRef} {\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 475                                                                                               \{\par
476         {\cf19 return} StringRef( rawChars, size );\par
477     \}\par
}
}
{\xe \v operator+\:Catch}
{\xe \v Catch\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::operator+ (char const *  {\i lhs}, {\b StringRef} const &  {\i rhs}) ->  std::string}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator+\:Catch}
{\xe \v Catch\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::operator+ ({\b StringRef} const &  {\i lhs}, char const *  {\i rhs}) ->  std::string}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator+\:Catch}
{\xe \v Catch\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::operator+ ({\b StringRef} const &  {\i lhs}, {\b StringRef} const &  {\i rhs}) ->  std::string}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator+\:Catch}
{\xe \v Catch\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T const  & Catch::operator+ (T const &  {\i value}, {\b StreamEndStop} )}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 303                                                           \{\par
304         {\cf19 return} value;\par
305     \}\par
}
}
{\xe \v operator+=\:Catch}
{\xe \v Catch\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::operator+= (std::string &  {\i lhs}, {\b StringRef} const &  {\i sr}) ->  std::string &}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<<\:Catch}
{\xe \v Catch\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & Catch::operator<< (std::ostream &  {\i os}, {\b SourceLineInfo} const &  {\i info})}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<<\:Catch}
{\xe \v Catch\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::operator<< (std::ostream &  {\i os}, {\b StringRef} const &  {\i sr}) ->  std::ostream &}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator|\:Catch}
{\xe \v Catch\:operator|}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ResultDisposition::Flags} Catch::operator| ({\b ResultDisposition::Flags}  {\i lhs}, {\b ResultDisposition::Flags}  {\i rhs})}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rangeToString\:Catch}
{\xe \v Catch\:rangeToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Range > std::string Catch::rangeToString (Range const &  {\i range})}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1084                                                   \{\par
1085         return ::Catch::Detail::rangeToString( begin( range ), end( range ) );\par
1086     \}\par
}
}
{\xe \v rangeToString\:Catch}
{\xe \v Catch\:rangeToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Allocator > std::string Catch::rangeToString (std::vector< bool, Allocator > const &  {\i v})}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1090                                                                    \{\par
1091         ReusableStringStream rss;\par
1092         rss << {\cf22 "\{ "};\par
1093         {\cf18 bool} first = {\cf17 true};\par
1094         {\cf19 for}( {\cf18 bool} b : v ) \{\par
1095             {\cf19 if}( first )\par
1096                 first = {\cf17 false};\par
1097             {\cf19 else}\par
1098                 rss << {\cf22 ", "};\par
1099             rss << ::Catch::Detail::stringify( b );\par
1100         \}\par
1101         rss << {\cf22 " \}"};\par
1102         {\cf19 return} rss.str();\par
1103     \}\par
}
}
{\xe \v replaceInPlace\:Catch}
{\xe \v Catch\:replaceInPlace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::replaceInPlace (std::string &  {\i str}, std::string const &  {\i replaceThis}, std::string const &  {\i withThis})}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rngSeed\:Catch}
{\xe \v Catch\:rngSeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Catch::rngSeed ()}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v shouldContinueOnFailure\:Catch}
{\xe \v Catch\:shouldContinueOnFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::shouldContinueOnFailure (int  {\i flags})}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v shouldSuppressFailure\:Catch}
{\xe \v Catch\:shouldSuppressFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::shouldSuppressFailure (int  {\i flags})}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v startsWith\:Catch}
{\xe \v Catch\:startsWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::startsWith (std::string const &  {\i s}, char  {\i prefix})}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v startsWith\:Catch}
{\xe \v Catch\:startsWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::startsWith (std::string const &  {\i s}, std::string const &  {\i prefix})}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v toLower\:Catch}
{\xe \v Catch\:toLower}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::toLower (std::string const &  {\i s})}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v toLowerInPlace\:Catch}
{\xe \v Catch\:toLowerInPlace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::toLowerInPlace (std::string &  {\i s})}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v translateActiveException\:Catch}
{\xe \v Catch\:translateActiveException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::translateActiveException ()}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v trim\:Catch}
{\xe \v Catch\:trim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::trim (std::string const &  {\i str})}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Vari\'E1veis\par
\pard\plain 
{\xe \v begin\:Catch}
{\xe \v Catch\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b not_this_one} Catch::begin(...) (  {\i ...})}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v end\:Catch}
{\xe \v Catch\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b not_this_one} Catch::end(...) (  {\i ...})}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch::Detail\par \pard\plain 
{\tc\tcl2 \v Catch::Detail}
{\xe \v Catch::Detail}
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Approx}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IsStreamInsertable}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b rawMemoryToString} (const void *object, std::size_t size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::string {\b rawMemoryToString} (const T &object)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename E > std::string {\b convertUnknownEnumToString} (E e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::enable_if<!std::is_enum< T >::value, std::string >::type {\b convertUnstreamable} (T const &value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::enable_if< std::is_enum< T >::value, std::string >::type {\b convertUnstreamable} (T const &value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::string {\b stringify} (const T &e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputIterator > std::string {\b rangeToString} (InputIterator first, InputIterator last)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Vari\'E1veis\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string {\b unprintableString}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v convertUnknownEnumToString\:Catch::Detail}
{\xe \v Catch::Detail\:convertUnknownEnumToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename E > std::string Catch::Detail::convertUnknownEnumToString (E  {\i e})}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 818                                                     \{\par
819             return ::Catch::Detail::stringify({\cf17 static_cast<}typename std::underlying_type<E>::type{\cf17 >}(e));\par
820         \}\par
}
}
{\xe \v convertUnstreamable\:Catch::Detail}
{\xe \v Catch::Detail\:convertUnstreamable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::enable_if<!std::is_enum< T >::value, std::string >::type Catch::Detail::convertUnstreamable (T const &  {\i value})}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 773                                                                                                         \{\par
774 {\cf21 #if !defined(CATCH_CONFIG_FALLBACK_STRINGIFIER)}\par
775             (void)value;\par
776             {\cf19 return} Detail::unprintableString;\par
777 {\cf21 #else}\par
778             {\cf19 return} CATCH_CONFIG_FALLBACK_STRINGIFIER(value);\par
779 {\cf21 #endif}\par
780         \}\par
}
}
{\xe \v convertUnstreamable\:Catch::Detail}
{\xe \v Catch::Detail\:convertUnstreamable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::enable_if< std::is_enum< T >::value, std::string >::type Catch::Detail::convertUnstreamable (T const &  {\i value})}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 782                                                                                                        \{\par
783             {\cf19 return} convertUnknownEnumToString( value );\par
784         \}\par
}
}
{\xe \v rangeToString\:Catch::Detail}
{\xe \v Catch::Detail\:rangeToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename InputIterator > std::string Catch::Detail::rangeToString (InputIterator  {\i first}, InputIterator  {\i last})}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 957                                                                          \{\par
958             ReusableStringStream rss;\par
959             rss << {\cf22 "\{ "};\par
960             {\cf19 if} (first != last) \{\par
961                 rss << ::Catch::Detail::stringify(*first);\par
962                 {\cf19 for} (++first; first != last; ++first)\par
963                     rss << {\cf22 ", "} << ::Catch::Detail::stringify(*first);\par
964             \}\par
965             rss << {\cf22 " \}"};\par
966             {\cf19 return} rss.str();\par
967         \}\par
}
}
{\xe \v rawMemoryToString\:Catch::Detail}
{\xe \v Catch::Detail\:rawMemoryToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::string Catch::Detail::rawMemoryToString (const T &  {\i object})}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 752                                                        \{\par
753           {\cf19 return} rawMemoryToString( &{\cf18 object}, {\cf17 sizeof}({\cf18 object}) );\par
754         \}\par
}
}
{\xe \v rawMemoryToString\:Catch::Detail}
{\xe \v Catch::Detail\:rawMemoryToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::Detail::rawMemoryToString (const void *  {\i object}, std::size_t  {\i size})}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v stringify\:Catch::Detail}
{\xe \v Catch::Detail\:stringify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::string Catch::Detail::stringify (const T &  {\i e})}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 813                                         \{\par
814             return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);\par
815         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Vari\'E1veis\par
\pard\plain 
{\xe \v unprintableString\:Catch::Detail}
{\xe \v Catch::Detail\:unprintableString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string Catch::Detail::unprintableString{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch::Matchers\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers}
{\xe \v Catch::Matchers}
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Floating}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b StdString}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Vector}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Floating::WithinUlpsMatcher} {\b WithinULP} (double target, int maxUlpDiff)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Floating::WithinUlpsMatcher} {\b WithinULP} (float target, int maxUlpDiff)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Floating::WithinAbsMatcher} {\b WithinAbs} (double target, double margin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StdString::EqualsMatcher} {\b Equals} (std::string const &str, {\b CaseSensitive::Choice} caseSensitivity={\b CaseSensitive::Yes})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StdString::ContainsMatcher} {\b Contains} (std::string const &str, {\b CaseSensitive::Choice} caseSensitivity={\b CaseSensitive::Yes})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StdString::EndsWithMatcher} {\b EndsWith} (std::string const &str, {\b CaseSensitive::Choice} caseSensitivity={\b CaseSensitive::Yes})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StdString::StartsWithMatcher} {\b StartsWith} (std::string const &str, {\b CaseSensitive::Choice} caseSensitivity={\b CaseSensitive::Yes})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StdString::RegexMatcher} {\b Matches} (std::string const &regex, {\b CaseSensitive::Choice} caseSensitivity={\b CaseSensitive::Yes})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b Vector::ContainsMatcher}< T > {\b Contains} (std::vector< T > const &comparator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b Vector::ContainsElementMatcher}< T > {\b VectorContains} (T const &comparator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b Vector::EqualsMatcher}< T > {\b Equals} (std::vector< T > const &comparator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b Vector::UnorderedEqualsMatcher}< T > {\b UnorderedEquals} (std::vector< T > const &target)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v Contains\:Catch::Matchers}
{\xe \v Catch::Matchers\:Contains}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StdString::ContainsMatcher} Catch::Matchers::Contains (std::string const &  {\i str}, {\b CaseSensitive::Choice}  {\i caseSensitivity} = {\f2 {\b CaseSensitive::Yes}})}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Contains\:Catch::Matchers}
{\xe \v Catch::Matchers\:Contains}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Vector::ContainsMatcher}< T > Catch::Matchers::Contains (std::vector< T > const &  {\i comparator})}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2579                                                                         \{\par
2580         {\cf19 return} Vector::ContainsMatcher<T>( comparator );\par
2581     \}\par
}
}
{\xe \v EndsWith\:Catch::Matchers}
{\xe \v Catch::Matchers\:EndsWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StdString::EndsWithMatcher} Catch::Matchers::EndsWith (std::string const &  {\i str}, {\b CaseSensitive::Choice}  {\i caseSensitivity} = {\f2 {\b CaseSensitive::Yes}})}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Equals\:Catch::Matchers}
{\xe \v Catch::Matchers\:Equals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StdString::EqualsMatcher} Catch::Matchers::Equals (std::string const &  {\i str}, {\b CaseSensitive::Choice}  {\i caseSensitivity} = {\f2 {\b CaseSensitive::Yes}})}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Equals\:Catch::Matchers}
{\xe \v Catch::Matchers\:Equals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Vector::EqualsMatcher}< T > Catch::Matchers::Equals (std::vector< T > const &  {\i comparator})}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2589                                                                     \{\par
2590         {\cf19 return} Vector::EqualsMatcher<T>( comparator );\par
2591     \}\par
}
}
{\xe \v Matches\:Catch::Matchers}
{\xe \v Catch::Matchers\:Matches}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StdString::RegexMatcher} Catch::Matchers::Matches (std::string const &  {\i regex}, {\b CaseSensitive::Choice}  {\i caseSensitivity} = {\f2 {\b CaseSensitive::Yes}})}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v StartsWith\:Catch::Matchers}
{\xe \v Catch::Matchers\:StartsWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StdString::StartsWithMatcher} Catch::Matchers::StartsWith (std::string const &  {\i str}, {\b CaseSensitive::Choice}  {\i caseSensitivity} = {\f2 {\b CaseSensitive::Yes}})}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v UnorderedEquals\:Catch::Matchers}
{\xe \v Catch::Matchers\:UnorderedEquals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Vector::UnorderedEqualsMatcher}< T > Catch::Matchers::UnorderedEquals (std::vector< T > const &  {\i target})}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2594                                                                                 \{\par
2595         {\cf19 return} Vector::UnorderedEqualsMatcher<T>(target);\par
2596     \}\par
}
}
{\xe \v VectorContains\:Catch::Matchers}
{\xe \v Catch::Matchers\:VectorContains}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Vector::ContainsElementMatcher}< T > Catch::Matchers::VectorContains (T const &  {\i comparator})}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2584                                                                           \{\par
2585         {\cf19 return} Vector::ContainsElementMatcher<T>( comparator );\par
2586     \}\par
}
}
{\xe \v WithinAbs\:Catch::Matchers}
{\xe \v Catch::Matchers\:WithinAbs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Floating::WithinAbsMatcher} Catch::Matchers::WithinAbs (double  {\i target}, double  {\i margin})}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v WithinULP\:Catch::Matchers}
{\xe \v Catch::Matchers\:WithinULP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Floating::WithinUlpsMatcher} Catch::Matchers::WithinULP (double  {\i target}, int  {\i maxUlpDiff})}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v WithinULP\:Catch::Matchers}
{\xe \v Catch::Matchers\:WithinULP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Floating::WithinUlpsMatcher} Catch::Matchers::WithinULP (float  {\i target}, int  {\i maxUlpDiff})}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch::Matchers::Floating\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::Floating}
{\xe \v Catch::Matchers::Floating}
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b WithinAbsMatcher}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b WithinUlpsMatcher}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch::Matchers::Impl\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::Impl}
{\xe \v Catch::Matchers::Impl}
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MatchAllOf}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MatchAnyOf}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MatcherBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MatcherMethod}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MatcherMethod< PtrT * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MatcherUntypedBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MatchNotOf}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch::Matchers::StdString\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::StdString}
{\xe \v Catch::Matchers::StdString}
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CasedString}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ContainsMatcher}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b EndsWithMatcher}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b EqualsMatcher}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b RegexMatcher}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StartsWithMatcher}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMatcherBase}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch::Matchers::Vector\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::Vector}
{\xe \v Catch::Matchers::Vector}
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ContainsElementMatcher}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ContainsMatcher}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b EqualsMatcher}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b UnorderedEqualsMatcher}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch::Matchers::Vector::Detail\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::Vector::Detail}
{\xe \v Catch::Matchers::Vector::Detail}
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputIterator , typename T > size_t {\b count} (InputIterator first, InputIterator last, T const &item)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputIterator , typename T > bool {\b contains} (InputIterator first, InputIterator last, T const &item)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v contains\:Catch::Matchers::Vector::Detail}
{\xe \v Catch::Matchers::Vector::Detail\:contains}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename InputIterator , typename T > bool Catch::Matchers::Vector::Detail::contains (InputIterator  {\i first}, InputIterator  {\i last}, T const &  {\i item})}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2449                                                                                   \{\par
2450                 {\cf19 for} (; first != last; ++first) \{\par
2451                     {\cf19 if} (*first == item) \{\par
2452                         {\cf19 return} {\cf17 true};\par
2453                     \}\par
2454                 \}\par
2455                 {\cf19 return} {\cf17 false};\par
2456             \}\par
}
}
{\xe \v count\:Catch::Matchers::Vector::Detail}
{\xe \v Catch::Matchers::Vector::Detail\:count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename InputIterator , typename T > size_t Catch::Matchers::Vector::Detail::count (InputIterator  {\i first}, InputIterator  {\i last}, T const &  {\i item})}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2439                                                                                  \{\par
2440                 {\cf18 size_t} cnt = 0;\par
2441                 {\cf19 for} (; first != last; ++first) \{\par
2442                     {\cf19 if} (*first == item) \{\par
2443                         ++cnt;\par
2444                     \}\par
2445                 \}\par
2446                 {\cf19 return} cnt;\par
2447             \}\par
}
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Classes{\tc \v Classes}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Detail::Approx\par \pard\plain 
{\tc\tcl2 \v Catch::Detail::Approx}
{\xe \v Catch::Detail::Approx}
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Approx} (double value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> {\b Approx} {\b operator()} (T const &value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> {\b Approx} (T const &value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> {\b Approx} & {\b epsilon} (T const &newEpsilon)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> {\b Approx} & {\b margin} (T const &newMargin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> {\b Approx} & {\b scale} (T const &newScale)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Approx} {\b custom} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> bool {\b operator==} (const T &lhs, {\b Approx} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> bool {\b operator==} ({\b Approx} const &lhs, const T &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> bool {\b operator!=} (T const &lhs, {\b Approx} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> bool {\b operator!=} ({\b Approx} const &lhs, T const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> bool {\b operator<=} (T const &lhs, {\b Approx} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> bool {\b operator<=} ({\b Approx} const &lhs, T const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> bool {\b operator>=} (T const &lhs, {\b Approx} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> bool {\b operator>=} ({\b Approx} const &lhs, T const &rhs)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v Approx\:Catch::Detail::Approx}
{\xe \v Catch::Detail::Approx\:Approx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Detail::Approx::Approx (double  {\i value}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Approx\:Catch::Detail::Approx}
{\xe \v Catch::Detail::Approx\:Approx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> Catch::Detail::Approx::Approx (T const &  {\i value}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2044                                          : Approx({\cf17 static_cast<}{\cf18 double}{\cf17 >}(value))\par
2045         \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v custom\:Catch::Detail::Approx}
{\xe \v Catch::Detail::Approx\:custom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b Approx} Catch::Detail::Approx::custom (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v epsilon\:Catch::Detail::Approx}
{\xe \v Catch::Detail::Approx\:epsilon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> {\b Approx} & Catch::Detail::Approx::epsilon (T const &  {\i newEpsilon}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2089                                                \{\par
2090             {\cf18 double} epsilonAsDouble = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(newEpsilon);\par
2091             {\cf19 if}( epsilonAsDouble < 0 || epsilonAsDouble > 1.0 ) \{\par
2092                 {\cf19 throw} std::domain_error\par
2093                     (   {\cf22 "Invalid Approx::epsilon: "} +\par
2094                         Catch::Detail::stringify( epsilonAsDouble ) +\par
2095                         {\cf22 ", Approx::epsilon has to be between 0 and 1"} );\par
2096             \}\par
2097             m_epsilon = epsilonAsDouble;\par
2098             {\cf19 return} *{\cf17 this};\par
2099         \}\par
}
}
{\xe \v margin\:Catch::Detail::Approx}
{\xe \v Catch::Detail::Approx\:margin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> {\b Approx} & Catch::Detail::Approx::margin (T const &  {\i newMargin}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2102                                              \{\par
2103             {\cf18 double} marginAsDouble = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(newMargin);\par
2104             {\cf19 if}( marginAsDouble < 0 ) \{\par
2105                 {\cf19 throw} std::domain_error\par
2106                     (   {\cf22 "Invalid Approx::margin: "} +\par
2107                          Catch::Detail::stringify( marginAsDouble ) +\par
2108                          {\cf22 ", Approx::Margin has to be non-negative."} );\par
2109 \par
2110             \}\par
2111             m_margin = marginAsDouble;\par
2112             {\cf19 return} *{\cf17 this};\par
2113         \}\par
}
}
{\xe \v operator()\:Catch::Detail::Approx}
{\xe \v Catch::Detail::Approx\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> {\b Approx} Catch::Detail::Approx::operator() (T const &  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2035                                             \{\par
2036             Approx approx( {\cf17 static_cast<}{\cf18 double}{\cf17 >}(value) );\par
2037             approx.epsilon( m_epsilon );\par
2038             approx.margin( m_margin );\par
2039             approx.scale( m_scale );\par
2040             {\cf19 return} approx;\par
2041         \}\par
}
}
{\xe \v scale\:Catch::Detail::Approx}
{\xe \v Catch::Detail::Approx\:scale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> {\b Approx} & Catch::Detail::Approx::scale (T const &  {\i newScale}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2116                                            \{\par
2117             m_scale = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(newScale);\par
2118             {\cf19 return} *{\cf17 this};\par
2119         \}\par
}
}
{\xe \v toString\:Catch::Detail::Approx}
{\xe \v Catch::Detail::Approx\:toString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::Detail::Approx::toString () const}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v operator!=\:Catch::Detail::Approx}
{\xe \v Catch::Detail::Approx\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> bool operator!= ({\b Approx} const &  {\i lhs}, T const &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2064                                                                     \{\par
2065             {\cf19 return} !operator==( rhs, lhs );\par
2066         \}\par
}
}
{\xe \v operator!=\:Catch::Detail::Approx}
{\xe \v Catch::Detail::Approx\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> bool operator!= (T const &  {\i lhs}, {\b Approx} const &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2059                                                                     \{\par
2060             {\cf19 return} !operator==( lhs, rhs );\par
2061         \}\par
}
}
{\xe \v operator<=\:Catch::Detail::Approx}
{\xe \v Catch::Detail::Approx\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> bool operator<= ({\b Approx} const &  {\i lhs}, T const &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2074                                                                     \{\par
2075             {\cf19 return} lhs.m_value < {\cf17 static_cast<}{\cf18 double}{\cf17 >}(rhs) || lhs == rhs;\par
2076         \}\par
}
}
{\xe \v operator<=\:Catch::Detail::Approx}
{\xe \v Catch::Detail::Approx\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> bool operator<= (T const &  {\i lhs}, {\b Approx} const &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2069                                                                     \{\par
2070             {\cf19 return} {\cf17 static_cast<}{\cf18 double}{\cf17 >}(lhs) < rhs.m_value || lhs == rhs;\par
2071         \}\par
}
}
{\xe \v operator==\:Catch::Detail::Approx}
{\xe \v Catch::Detail::Approx\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> bool operator== ({\b Approx} const &  {\i lhs}, const T &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2054                                                                     \{\par
2055             {\cf19 return} operator==( rhs, lhs );\par
2056         \}\par
}
}
{\xe \v operator==\:Catch::Detail::Approx}
{\xe \v Catch::Detail::Approx\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> bool operator== (const T &  {\i lhs}, {\b Approx} const &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2048                                                                     \{\par
2049             {\cf17 auto} lhs_v = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(lhs);\par
2050             {\cf19 return} rhs.equalityComparisonImpl(lhs_v);\par
2051         \}\par
}
}
{\xe \v operator>=\:Catch::Detail::Approx}
{\xe \v Catch::Detail::Approx\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> bool operator>= ({\b Approx} const &  {\i lhs}, T const &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2084                                                                     \{\par
2085             {\cf19 return} lhs.m_value > {\cf17 static_cast<}{\cf18 double}{\cf17 >}(rhs) || lhs == rhs;\par
2086         \}\par
}
}
{\xe \v operator>=\:Catch::Detail::Approx}
{\xe \v Catch::Detail::Approx\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = typename std::enable_if<std::is_constructible<double, T>::value>::type> bool operator>= (T const &  {\i lhs}, {\b Approx} const &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2079                                                                     \{\par
2080             {\cf19 return} {\cf17 static_cast<}{\cf18 double}{\cf17 >}(lhs) > rhs.m_value || lhs == rhs;\par
2081         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::AssertionHandler\par \pard\plain 
{\tc\tcl2 \v Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler}
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionHandler} ({\b StringRef} macroName, {\b SourceLineInfo} const &lineInfo, {\b StringRef} capturedExpression, {\b ResultDisposition::Flags} resultDisposition)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~AssertionHandler} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b handleExpr} ({\b ExprLhs}< T > const &expr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleExpr} ({\b ITransientExpression} const &expr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleMessage} ({\b ResultWas::OfType} resultType, {\b StringRef} const &message)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleExceptionThrownAsExpected} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleUnexpectedExceptionNotThrown} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleExceptionNotThrownAsExpected} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleThrowingCallSkipped} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleUnexpectedInflightException} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b complete} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCompleted} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b allowThrows} () const -> bool\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v AssertionHandler\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:AssertionHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::AssertionHandler::AssertionHandler ({\b StringRef}  {\i macroName}, {\b SourceLineInfo} const &  {\i lineInfo}, {\b StringRef}  {\i capturedExpression}, {\b ResultDisposition::Flags}  {\i resultDisposition})}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~AssertionHandler\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:~AssertionHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::AssertionHandler::~AssertionHandler (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1515                             \{\par
1516             {\cf19 if} ( !m_completed ) \{\par
1517                 m_resultCapture.handleIncomplete( m_assertionInfo );\par
1518             \}\par
1519         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v allowThrows\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:allowThrows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::AssertionHandler::allowThrows () const ->  bool}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v complete\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:complete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::AssertionHandler::complete ()}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleExceptionNotThrownAsExpected\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:handleExceptionNotThrownAsExpected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::AssertionHandler::handleExceptionNotThrownAsExpected ()}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleExceptionThrownAsExpected\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:handleExceptionThrownAsExpected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::AssertionHandler::handleExceptionThrownAsExpected ()}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleExpr\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:handleExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void Catch::AssertionHandler::handleExpr ({\b ExprLhs}< T > const &  {\i expr}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1522                                                   \{\par
1523             handleExpr( expr.makeUnaryExpr() );\par
1524         \}\par
}
}
{\xe \v handleExpr\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:handleExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::AssertionHandler::handleExpr ({\b ITransientExpression} const &  {\i expr})}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleMessage\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:handleMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::AssertionHandler::handleMessage ({\b ResultWas::OfType}  {\i resultType}, {\b StringRef} const &  {\i message})}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleThrowingCallSkipped\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:handleThrowingCallSkipped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::AssertionHandler::handleThrowingCallSkipped ()}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleUnexpectedExceptionNotThrown\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:handleUnexpectedExceptionNotThrown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::AssertionHandler::handleUnexpectedExceptionNotThrown ()}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleUnexpectedInflightException\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:handleUnexpectedInflightException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::AssertionHandler::handleUnexpectedInflightException ()}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v setCompleted\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:setCompleted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::AssertionHandler::setCompleted ()}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::AssertionInfo\par \pard\plain 
{\tc\tcl2 \v Catch::AssertionInfo}
{\xe \v Catch::AssertionInfo}
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b macroName}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SourceLineInfo} {\b lineInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b capturedExpression}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultDisposition::Flags} {\b resultDisposition}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v capturedExpression\:Catch::AssertionInfo}
{\xe \v Catch::AssertionInfo\:capturedExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::AssertionInfo::capturedExpression}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lineInfo\:Catch::AssertionInfo}
{\xe \v Catch::AssertionInfo\:lineInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SourceLineInfo} Catch::AssertionInfo::lineInfo}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v macroName\:Catch::AssertionInfo}
{\xe \v Catch::AssertionInfo\:macroName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::AssertionInfo::macroName}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v resultDisposition\:Catch::AssertionInfo}
{\xe \v Catch::AssertionInfo\:resultDisposition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ResultDisposition::Flags} Catch::AssertionInfo::resultDisposition}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::AssertionReaction\par \pard\plain 
{\tc\tcl2 \v Catch::AssertionReaction}
{\xe \v Catch::AssertionReaction}
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shouldDebugBreak} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shouldThrow} = false\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v shouldDebugBreak\:Catch::AssertionReaction}
{\xe \v Catch::AssertionReaction\:shouldDebugBreak}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::AssertionReaction::shouldDebugBreak = false}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v shouldThrow\:Catch::AssertionReaction}
{\xe \v Catch::AssertionReaction\:shouldThrow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::AssertionReaction::shouldThrow = false}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::AutoReg\par \pard\plain 
{\tc\tcl2 \v Catch::AutoReg}
{\xe \v Catch::AutoReg}
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::AutoReg:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_auto_reg.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoReg} ({\b ITestInvoker} *invoker, {\b SourceLineInfo} const &lineInfo, {\b StringRef} const &classOrMethod, {\b NameAndTags} const &nameAndTags) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~AutoReg} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::NonCopyable}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NonCopyable} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~NonCopyable} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v AutoReg\:Catch::AutoReg}
{\xe \v Catch::AutoReg\:AutoReg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::AutoReg::AutoReg ({\b ITestInvoker} *  {\i invoker}, {\b SourceLineInfo} const &  {\i lineInfo}, {\b StringRef} const &  {\i classOrMethod}, {\b NameAndTags} const &  {\i nameAndTags}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~AutoReg\:Catch::AutoReg}
{\xe \v Catch::AutoReg\:~AutoReg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::AutoReg::~AutoReg ()}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::BenchmarkLooper\par \pard\plain 
{\tc\tcl2 \v Catch::BenchmarkLooper}
{\xe \v Catch::BenchmarkLooper}
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BenchmarkLooper} ({\b StringRef} name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator bool} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b increment} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reportStart} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b needsMoreIterations} () -> bool\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v BenchmarkLooper\:Catch::BenchmarkLooper}
{\xe \v Catch::BenchmarkLooper\:BenchmarkLooper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::BenchmarkLooper::BenchmarkLooper ({\b StringRef}  {\i name}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1869         :   m_name( name ),\par
1870             m_resolution( getResolution() )\par
1871         \{\par
1872             reportStart();\par
1873             m_timer.start();\par
1874         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v increment\:Catch::BenchmarkLooper}
{\xe \v Catch::BenchmarkLooper\:increment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::BenchmarkLooper::increment (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1882                          \{\par
1883             ++m_count;\par
1884         \}\par
}
}
{\xe \v needsMoreIterations\:Catch::BenchmarkLooper}
{\xe \v Catch::BenchmarkLooper\:needsMoreIterations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::BenchmarkLooper::needsMoreIterations () ->  bool}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator bool\:Catch::BenchmarkLooper}
{\xe \v Catch::BenchmarkLooper\:operator bool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::BenchmarkLooper::operator bool (){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1876                                  \{\par
1877             {\cf19 if}( m_count < m_iterationsToRun )\par
1878                 {\cf19 return} {\cf17 true};\par
1879             {\cf19 return} needsMoreIterations();\par
1880         \}\par
}
}
{\xe \v reportStart\:Catch::BenchmarkLooper}
{\xe \v Catch::BenchmarkLooper\:reportStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::BenchmarkLooper::reportStart ()}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Classe Catch::BinaryExpr< LhsT, RhsT >\par \pard\plain 
{\tc\tcl2 \v Catch::BinaryExpr< LhsT, RhsT >}
{\xe \v Catch::BinaryExpr< LhsT, RhsT >}
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::BinaryExpr< LhsT, RhsT >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_binary_expr.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BinaryExpr} (bool comparisonResult, LhsT lhs, {\b StringRef} op, RhsT rhs)\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::ITransientExpression}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b isBinaryExpression} () const -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b getResult} () const -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b streamReconstructedExpression} (std::ostream &os) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ITransientExpression} (bool {\b isBinaryExpression}, bool result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ITransientExpression} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos P\'FAblicos herdados de {\b Catch::ITransientExpression}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_isBinaryExpression}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_result}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v BinaryExpr\:Catch::BinaryExpr< LhsT, RhsT >}
{\xe \v Catch::BinaryExpr< LhsT, RhsT >\:BinaryExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT , typename RhsT > {\b Catch::BinaryExpr}< LhsT, RhsT >::BinaryExpr (bool  {\i comparisonResult}, LhsT  {\i lhs}, {\b StringRef}  {\i op}, RhsT  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1289         :   ITransientExpression\{ {\cf17 true}, comparisonResult \},\par
1290             m_lhs( lhs ),\par
1291             m_op( op ),\par
1292             m_rhs( rhs )\par
1293         \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Matchers::StdString::CasedString\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::StdString::CasedString}
{\xe \v Catch::Matchers::StdString::CasedString}
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CasedString} (std::string const &str, {\b CaseSensitive::Choice} caseSensitivity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b adjustString} (std::string const &str) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b caseSensitivitySuffix} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CaseSensitive::Choice} {\b m_caseSensitivity}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_str}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v CasedString\:Catch::Matchers::StdString::CasedString}
{\xe \v Catch::Matchers::StdString::CasedString\:CasedString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Matchers::StdString::CasedString::CasedString (std::string const &  {\i str}, {\b CaseSensitive::Choice}  {\i caseSensitivity})}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v adjustString\:Catch::Matchers::StdString::CasedString}
{\xe \v Catch::Matchers::StdString::CasedString\:adjustString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::Matchers::StdString::CasedString::adjustString (std::string const &  {\i str}) const}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v caseSensitivitySuffix\:Catch::Matchers::StdString::CasedString}
{\xe \v Catch::Matchers::StdString::CasedString\:caseSensitivitySuffix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::Matchers::StdString::CasedString::caseSensitivitySuffix () const}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_caseSensitivity\:Catch::Matchers::StdString::CasedString}
{\xe \v Catch::Matchers::StdString::CasedString\:m_caseSensitivity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CaseSensitive::Choice} Catch::Matchers::StdString::CasedString::m_caseSensitivity}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v m_str\:Catch::Matchers::StdString::CasedString}
{\xe \v Catch::Matchers::StdString::CasedString\:m_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::Matchers::StdString::CasedString::m_str}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::CaseSensitive\par \pard\plain 
{\tc\tcl2 \v Catch::CaseSensitive}
{\xe \v Catch::CaseSensitive}
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Choice} \{ {\b Yes}
, {\b No}
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das enumera\'E7\'F5es\par
\pard\plain 
{\xe \v Choice\:Catch::CaseSensitive}
{\xe \v Catch::CaseSensitive\:Choice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Catch::CaseSensitive::Choice}}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Yes\:Catch::CaseSensitive}
{\xe \v Catch::CaseSensitive\:Yes}
{\qr Yes{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
\cell }{\cell }{\row }
{\xe \v No\:Catch::CaseSensitive}
{\xe \v Catch::CaseSensitive\:No}
{\qr No{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
\cell }{\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 256                          \{ {\cf17 enum} Choice \{\par
257         Yes,\par
258         No\par
259     \}; \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch_global_namespace_dummy\par \pard\plain 
{\tc\tcl2 \v Catch_global_namespace_dummy}
{\xe \v Catch_global_namespace_dummy}
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
\par
{
{\f2 #include <catch.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Estrutura Catch::Matchers::Vector::ContainsElementMatcher< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::Vector::ContainsElementMatcher< T >}
{\xe \v Catch::Matchers::Vector::ContainsElementMatcher< T >}
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::Matchers::Vector::ContainsElementMatcher< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_matchers_1_1_vector_1_1_contains_element_matcher.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ContainsElementMatcher} (T const &comparator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b match} (std::vector< T > const &v) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b describe} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherBase< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAllOf}< T > {\b operator&&} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAnyOf}< T > {\b operator||} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchNotOf}< T > {\b operator!} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ({\b MatcherUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} & {\b operator=} ({\b MatcherUntypedBase} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherMethod< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b match} (T const &arg) const=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T const  & {\b m_comparator}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MatcherUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b describe} () const =0\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_cachedToString}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ContainsElementMatcher\:Catch::Matchers::Vector::ContainsElementMatcher< T >}
{\xe \v Catch::Matchers::Vector::ContainsElementMatcher< T >\:ContainsElementMatcher}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Matchers::Vector::ContainsElementMatcher}< T >::ContainsElementMatcher (T const &  {\i comparator}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2462 : m_comparator( comparator) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v describe\:Catch::Matchers::Vector::ContainsElementMatcher< T >}
{\xe \v Catch::Matchers::Vector::ContainsElementMatcher< T >\:describe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::string {\b Catch::Matchers::Vector::ContainsElementMatcher}< T >::describe () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Matchers::Impl::MatcherUntypedBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2473                                                 \{\par
2474                 {\cf19 return} {\cf22 "Contains: "} + ::Catch::Detail::stringify( m_comparator );\par
2475             \}\par
}
}
{\xe \v match\:Catch::Matchers::Vector::ContainsElementMatcher< T >}
{\xe \v Catch::Matchers::Vector::ContainsElementMatcher< T >\:match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b Catch::Matchers::Vector::ContainsElementMatcher}< T >::match (std::vector< T > const &  {\i v}) const{\f2 [inline]}, {\f2 [override]}}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2464                                                              \{\par
2465                 {\cf19 for} ({\cf17 auto} {\cf17 const}& el : v) \{\par
2466                     {\cf19 if} (el == m_comparator) \{\par
2467                         {\cf19 return} {\cf17 true};\par
2468                     \}\par
2469                 \}\par
2470                 {\cf19 return} {\cf17 false};\par
2471             \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_comparator\:Catch::Matchers::Vector::ContainsElementMatcher< T >}
{\xe \v Catch::Matchers::Vector::ContainsElementMatcher< T >\:m_comparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T const& {\b Catch::Matchers::Vector::ContainsElementMatcher}< T >::m_comparator}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Matchers::StdString::ContainsMatcher\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::StdString::ContainsMatcher}
{\xe \v Catch::Matchers::StdString::ContainsMatcher}
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::Matchers::StdString::ContainsMatcher:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_matchers_1_1_std_string_1_1_contains_matcher.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ContainsMatcher} ({\b CasedString} const &comparator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b match} (std::string const &source) const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::StdString::StringMatcherBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringMatcherBase} (std::string const &operation, {\b CasedString} const &comparator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b describe} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherBase< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAllOf}< T > {\b operator&&} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAnyOf}< T > {\b operator||} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchNotOf}< T > {\b operator!} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ({\b MatcherUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} & {\b operator=} ({\b MatcherUntypedBase} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherMethod< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b match} (T const &arg) const=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos P\'FAblicos herdados de {\b Catch::Matchers::StdString::StringMatcherBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CasedString} {\b m_comparator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_operation}\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MatcherUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b describe} () const =0\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_cachedToString}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ContainsMatcher\:Catch::Matchers::StdString::ContainsMatcher}
{\xe \v Catch::Matchers::StdString::ContainsMatcher\:ContainsMatcher}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Matchers::StdString::ContainsMatcher::ContainsMatcher ({\b CasedString} const &  {\i comparator})}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v match\:Catch::Matchers::StdString::ContainsMatcher}
{\xe \v Catch::Matchers::StdString::ContainsMatcher\:match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Matchers::StdString::ContainsMatcher::match (std::string const &  {\i source}) const{\f2 [override]}}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Estrutura Catch::Matchers::Vector::ContainsMatcher< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::Vector::ContainsMatcher< T >}
{\xe \v Catch::Matchers::Vector::ContainsMatcher< T >}
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::Matchers::Vector::ContainsMatcher< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_matchers_1_1_vector_1_1_contains_matcher.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ContainsMatcher} (std::vector< T > const &comparator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b match} (std::vector< T > const &v) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b describe} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherBase< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAllOf}< T > {\b operator&&} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAnyOf}< T > {\b operator||} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchNotOf}< T > {\b operator!} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ({\b MatcherUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} & {\b operator=} ({\b MatcherUntypedBase} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherMethod< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b match} (T const &arg) const=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< T > const  & {\b m_comparator}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MatcherUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b describe} () const =0\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_cachedToString}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ContainsMatcher\:Catch::Matchers::Vector::ContainsMatcher< T >}
{\xe \v Catch::Matchers::Vector::ContainsMatcher< T >\:ContainsMatcher}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Matchers::Vector::ContainsMatcher}< T >::ContainsMatcher (std::vector< T > const &  {\i comparator}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2483 : m_comparator( comparator ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v describe\:Catch::Matchers::Vector::ContainsMatcher< T >}
{\xe \v Catch::Matchers::Vector::ContainsMatcher< T >\:describe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::string {\b Catch::Matchers::Vector::ContainsMatcher}< T >::describe () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Matchers::Impl::MatcherUntypedBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2503                                                 \{\par
2504                 {\cf19 return} {\cf22 "Contains: "} + ::Catch::Detail::stringify( m_comparator );\par
2505             \}\par
}
}
{\xe \v match\:Catch::Matchers::Vector::ContainsMatcher< T >}
{\xe \v Catch::Matchers::Vector::ContainsMatcher< T >\:match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b Catch::Matchers::Vector::ContainsMatcher}< T >::match (std::vector< T > const &  {\i v}) const{\f2 [inline]}, {\f2 [override]}}}
\par
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2485                                                              \{\par
2486                 {\cf20 // !TBD: see note in EqualsMatcher}\par
2487                 {\cf19 if} (m_comparator.size() > v.size())\par
2488                     {\cf19 return} {\cf17 false};\par
2489                 {\cf19 for} ({\cf17 auto} {\cf17 const}& comparator : m_comparator) \{\par
2490                     {\cf17 auto} present = {\cf17 false};\par
2491                     {\cf19 for} ({\cf17 const} {\cf17 auto}& el : v) \{\par
2492                         {\cf19 if} (el == comparator) \{\par
2493                             present = {\cf17 true};\par
2494                             {\cf19 break};\par
2495                         \}\par
2496                     \}\par
2497                     {\cf19 if} (!present) \{\par
2498                         {\cf19 return} {\cf17 false};\par
2499                     \}\par
2500                 \}\par
2501                 {\cf19 return} {\cf17 true};\par
2502             \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_comparator\:Catch::Matchers::Vector::ContainsMatcher< T >}
{\xe \v Catch::Matchers::Vector::ContainsMatcher< T >\:m_comparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::vector<T> const& {\b Catch::Matchers::Vector::ContainsMatcher}< T >::m_comparator}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Counts\par \pard\plain 
{\tc\tcl2 \v Catch::Counts}
{\xe \v Catch::Counts}
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Counts} {\b operator-} ({\b Counts} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Counts} & {\b operator+=} ({\b Counts} const &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b total} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b allPassed} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b allOk} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b passed} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b failed} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b failedButOk} = 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v allOk\:Catch::Counts}
{\xe \v Catch::Counts\:allOk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Counts::allOk () const}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v allPassed\:Catch::Counts}
{\xe \v Catch::Counts\:allPassed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Counts::allPassed () const}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator+=\:Catch::Counts}
{\xe \v Catch::Counts\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Counts} & Catch::Counts::operator+= ({\b Counts} const &  {\i other})}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator-\:Catch::Counts}
{\xe \v Catch::Counts\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Counts} Catch::Counts::operator- ({\b Counts} const &  {\i other}) const}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v total\:Catch::Counts}
{\xe \v Catch::Counts\:total}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t Catch::Counts::total () const}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v failed\:Catch::Counts}
{\xe \v Catch::Counts\:failed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t Catch::Counts::failed = 0}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v failedButOk\:Catch::Counts}
{\xe \v Catch::Counts\:failedButOk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t Catch::Counts::failedButOk = 0}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v passed\:Catch::Counts}
{\xe \v Catch::Counts\:passed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t Catch::Counts::passed = 0}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Decomposer\par \pard\plain 
{\tc\tcl2 \v Catch::Decomposer}
{\xe \v Catch::Decomposer}
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b operator<=} (T const &lhs) -> {\b ExprLhs}< T const & >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator<=} (bool value) -> {\b ExprLhs}< bool >\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator<=\:Catch::Decomposer}
{\xe \v Catch::Decomposer\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Decomposer::operator<= (bool  {\i value}) -> {\b ExprLhs}<bool> {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1391                                                         \{\par
1392             {\cf19 return} ExprLhs<bool>\{ value \};\par
1393         \}\par
}
}
{\xe \v operator<=\:Catch::Decomposer}
{\xe \v Catch::Decomposer\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > auto Catch::Decomposer::operator<= (T const &  {\i lhs}) -> {\b ExprLhs}<T const&> {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1387                                                                \{\par
1388             {\cf19 return} ExprLhs<T const&>\{ lhs \};\par
1389         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Matchers::StdString::EndsWithMatcher\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::StdString::EndsWithMatcher}
{\xe \v Catch::Matchers::StdString::EndsWithMatcher}
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::Matchers::StdString::EndsWithMatcher:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_matchers_1_1_std_string_1_1_ends_with_matcher.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EndsWithMatcher} ({\b CasedString} const &comparator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b match} (std::string const &source) const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::StdString::StringMatcherBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringMatcherBase} (std::string const &operation, {\b CasedString} const &comparator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b describe} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherBase< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAllOf}< T > {\b operator&&} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAnyOf}< T > {\b operator||} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchNotOf}< T > {\b operator!} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ({\b MatcherUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} & {\b operator=} ({\b MatcherUntypedBase} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherMethod< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b match} (T const &arg) const=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos P\'FAblicos herdados de {\b Catch::Matchers::StdString::StringMatcherBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CasedString} {\b m_comparator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_operation}\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MatcherUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b describe} () const =0\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_cachedToString}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v EndsWithMatcher\:Catch::Matchers::StdString::EndsWithMatcher}
{\xe \v Catch::Matchers::StdString::EndsWithMatcher\:EndsWithMatcher}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Matchers::StdString::EndsWithMatcher::EndsWithMatcher ({\b CasedString} const &  {\i comparator})}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v match\:Catch::Matchers::StdString::EndsWithMatcher}
{\xe \v Catch::Matchers::StdString::EndsWithMatcher\:match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Matchers::StdString::EndsWithMatcher::match (std::string const &  {\i source}) const{\f2 [override]}}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Matchers::StdString::EqualsMatcher\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::StdString::EqualsMatcher}
{\xe \v Catch::Matchers::StdString::EqualsMatcher}
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::Matchers::StdString::EqualsMatcher:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_matchers_1_1_std_string_1_1_equals_matcher.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EqualsMatcher} ({\b CasedString} const &comparator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b match} (std::string const &source) const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::StdString::StringMatcherBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringMatcherBase} (std::string const &operation, {\b CasedString} const &comparator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b describe} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherBase< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAllOf}< T > {\b operator&&} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAnyOf}< T > {\b operator||} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchNotOf}< T > {\b operator!} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ({\b MatcherUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} & {\b operator=} ({\b MatcherUntypedBase} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherMethod< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b match} (T const &arg) const=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos P\'FAblicos herdados de {\b Catch::Matchers::StdString::StringMatcherBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CasedString} {\b m_comparator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_operation}\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MatcherUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b describe} () const =0\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_cachedToString}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v EqualsMatcher\:Catch::Matchers::StdString::EqualsMatcher}
{\xe \v Catch::Matchers::StdString::EqualsMatcher\:EqualsMatcher}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Matchers::StdString::EqualsMatcher::EqualsMatcher ({\b CasedString} const &  {\i comparator})}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v match\:Catch::Matchers::StdString::EqualsMatcher}
{\xe \v Catch::Matchers::StdString::EqualsMatcher\:match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Matchers::StdString::EqualsMatcher::match (std::string const &  {\i source}) const{\f2 [override]}}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Estrutura Catch::Matchers::Vector::EqualsMatcher< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::Vector::EqualsMatcher< T >}
{\xe \v Catch::Matchers::Vector::EqualsMatcher< T >}
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::Matchers::Vector::EqualsMatcher< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_matchers_1_1_vector_1_1_equals_matcher.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EqualsMatcher} (std::vector< T > const &comparator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b match} (std::vector< T > const &v) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b describe} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherBase< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAllOf}< T > {\b operator&&} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAnyOf}< T > {\b operator||} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchNotOf}< T > {\b operator!} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ({\b MatcherUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} & {\b operator=} ({\b MatcherUntypedBase} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherMethod< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b match} (T const &arg) const=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< T > const  & {\b m_comparator}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MatcherUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b describe} () const =0\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_cachedToString}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v EqualsMatcher\:Catch::Matchers::Vector::EqualsMatcher< T >}
{\xe \v Catch::Matchers::Vector::EqualsMatcher< T >\:EqualsMatcher}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Matchers::Vector::EqualsMatcher}< T >::EqualsMatcher (std::vector< T > const &  {\i comparator}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2513 : m_comparator( comparator ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v describe\:Catch::Matchers::Vector::EqualsMatcher< T >}
{\xe \v Catch::Matchers::Vector::EqualsMatcher< T >\:describe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::string {\b Catch::Matchers::Vector::EqualsMatcher}< T >::describe () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Matchers::Impl::MatcherUntypedBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2527                                                 \{\par
2528                 {\cf19 return} {\cf22 "Equals: "} + ::Catch::Detail::stringify( m_comparator );\par
2529             \}\par
}
}
{\xe \v match\:Catch::Matchers::Vector::EqualsMatcher< T >}
{\xe \v Catch::Matchers::Vector::EqualsMatcher< T >\:match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b Catch::Matchers::Vector::EqualsMatcher}< T >::match (std::vector< T > const &  {\i v}) const{\f2 [inline]}, {\f2 [override]}}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2515                                                              \{\par
2516                 {\cf20 // !TBD: This currently works if all elements can be compared using !=}\par
2517                 {\cf20 // - a more general approach would be via a compare template that defaults}\par
2518                 {\cf20 // to using !=. but could be specialised for, e.g. std::vector<T> etc}\par
2519                 {\cf20 // - then just call that directly}\par
2520                 {\cf19 if} (m_comparator.size() != v.size())\par
2521                     {\cf19 return} {\cf17 false};\par
2522                 {\cf19 for} (std::size_t i = 0; i < v.size(); ++i)\par
2523                     {\cf19 if} (m_comparator[i] != v[i])\par
2524                         {\cf19 return} {\cf17 false};\par
2525                 {\cf19 return} {\cf17 true};\par
2526             \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_comparator\:Catch::Matchers::Vector::EqualsMatcher< T >}
{\xe \v Catch::Matchers::Vector::EqualsMatcher< T >\:m_comparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::vector<T> const& {\b Catch::Matchers::Vector::EqualsMatcher}< T >::m_comparator}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::ExceptionTranslatorRegistrar\par \pard\plain 
{\tc\tcl2 \v Catch::ExceptionTranslatorRegistrar}
{\xe \v Catch::ExceptionTranslatorRegistrar}
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b ExceptionTranslatorRegistrar} (std::string(*translateFunction)(T &))\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ExceptionTranslatorRegistrar\:Catch::ExceptionTranslatorRegistrar}
{\xe \v Catch::ExceptionTranslatorRegistrar\:ExceptionTranslatorRegistrar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > Catch::ExceptionTranslatorRegistrar::ExceptionTranslatorRegistrar (std::string(*)(T &)  {\i translateFunction}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1999                                                                             \{\par
2000             getMutableRegistryHub().registerTranslator\par
2001                 ( {\cf17 new} ExceptionTranslator<T>( translateFunction ) );\par
2002         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Classe Catch::ExprLhs< LhsT >\par \pard\plain 
{\tc\tcl2 \v Catch::ExprLhs< LhsT >}
{\xe \v Catch::ExprLhs< LhsT >}
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ExprLhs} (LhsT lhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename RhsT > auto {\b operator==} (RhsT const &rhs) -> {\b BinaryExpr}< LhsT, RhsT const & > const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator==} (bool rhs) -> {\b BinaryExpr}< LhsT, bool > const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename RhsT > auto {\b operator!=} (RhsT const &rhs) -> {\b BinaryExpr}< LhsT, RhsT const & > const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator!=} (bool rhs) -> {\b BinaryExpr}< LhsT, bool > const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename RhsT > auto {\b operator>} (RhsT const &rhs) -> {\b BinaryExpr}< LhsT, RhsT const & > const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename RhsT > auto {\b operator<} (RhsT const &rhs) -> {\b BinaryExpr}< LhsT, RhsT const & > const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename RhsT > auto {\b operator>=} (RhsT const &rhs) -> {\b BinaryExpr}< LhsT, RhsT const & > const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename RhsT > auto {\b operator<=} (RhsT const &rhs) -> {\b BinaryExpr}< LhsT, RhsT const & > const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b makeUnaryExpr} () const -> {\b UnaryExpr}< LhsT >\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ExprLhs\:Catch::ExprLhs< LhsT >}
{\xe \v Catch::ExprLhs< LhsT >\:ExprLhs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT > {\b Catch::ExprLhs}< LhsT >::ExprLhs (LhsT  {\i lhs}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1338 : m_lhs( lhs ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v makeUnaryExpr\:Catch::ExprLhs< LhsT >}
{\xe \v Catch::ExprLhs< LhsT >\:makeUnaryExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT > auto {\b Catch::ExprLhs}< LhsT >::makeUnaryExpr () const -> {\b UnaryExpr}<LhsT> {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1373                                                       \{\par
1374             {\cf19 return} UnaryExpr<LhsT>\{ m_lhs \};\par
1375         \}\par
}
}
{\xe \v operator!=\:Catch::ExprLhs< LhsT >}
{\xe \v Catch::ExprLhs< LhsT >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT > auto {\b Catch::ExprLhs}< LhsT >::operator!= (bool  {\i rhs}) -> {\b BinaryExpr}<LhsT, bool> const {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1352                                                                       \{\par
1353             {\cf19 return} \{ m_lhs != rhs, m_lhs, {\cf22 "!="}, rhs \};\par
1354         \}\par
}
}
{\xe \v operator!=\:Catch::ExprLhs< LhsT >}
{\xe \v Catch::ExprLhs< LhsT >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT > template<typename RhsT > auto {\b Catch::ExprLhs}< LhsT >::operator!= (RhsT const &  {\i rhs}) -> {\b BinaryExpr}<LhsT, RhsT const&> const {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1349                                                                                     \{\par
1350             {\cf19 return} \{ compareNotEqual( m_lhs, rhs ), m_lhs, {\cf22 "!="}, rhs \};\par
1351         \}\par
}
}
{\xe \v operator<\:Catch::ExprLhs< LhsT >}
{\xe \v Catch::ExprLhs< LhsT >\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT > template<typename RhsT > auto {\b Catch::ExprLhs}< LhsT >::operator< (RhsT const &  {\i rhs}) -> {\b BinaryExpr}<LhsT, RhsT const&> const {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1361                                                                                    \{\par
1362             {\cf19 return} \{ {\cf17 static_cast<}{\cf18 bool}{\cf17 >}(m_lhs < rhs), m_lhs, {\cf22 "<"}, rhs \};\par
1363         \}\par
}
}
{\xe \v operator<=\:Catch::ExprLhs< LhsT >}
{\xe \v Catch::ExprLhs< LhsT >\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT > template<typename RhsT > auto {\b Catch::ExprLhs}< LhsT >::operator<= (RhsT const &  {\i rhs}) -> {\b BinaryExpr}<LhsT, RhsT const&> const {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1369                                                                                     \{\par
1370             {\cf19 return} \{ {\cf17 static_cast<}{\cf18 bool}{\cf17 >}(m_lhs <= rhs), m_lhs, {\cf22 "<="}, rhs \};\par
1371         \}\par
}
}
{\xe \v operator==\:Catch::ExprLhs< LhsT >}
{\xe \v Catch::ExprLhs< LhsT >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT > auto {\b Catch::ExprLhs}< LhsT >::operator== (bool  {\i rhs}) -> {\b BinaryExpr}<LhsT, bool> const {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1344                                                                       \{\par
1345             {\cf19 return} \{ m_lhs == rhs, m_lhs, {\cf22 "=="}, rhs \};\par
1346         \}\par
}
}
{\xe \v operator==\:Catch::ExprLhs< LhsT >}
{\xe \v Catch::ExprLhs< LhsT >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT > template<typename RhsT > auto {\b Catch::ExprLhs}< LhsT >::operator== (RhsT const &  {\i rhs}) -> {\b BinaryExpr}<LhsT, RhsT const&> const {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1341                                                                                     \{\par
1342             {\cf19 return} \{ compareEqual( m_lhs, rhs ), m_lhs, {\cf22 "=="}, rhs \};\par
1343         \}\par
}
}
{\xe \v operator>\:Catch::ExprLhs< LhsT >}
{\xe \v Catch::ExprLhs< LhsT >\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT > template<typename RhsT > auto {\b Catch::ExprLhs}< LhsT >::operator> (RhsT const &  {\i rhs}) -> {\b BinaryExpr}<LhsT, RhsT const&> const {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1357                                                                                    \{\par
1358             {\cf19 return} \{ {\cf17 static_cast<}{\cf18 bool}{\cf17 >}(m_lhs > rhs), m_lhs, {\cf22 ">"}, rhs \};\par
1359         \}\par
}
}
{\xe \v operator>=\:Catch::ExprLhs< LhsT >}
{\xe \v Catch::ExprLhs< LhsT >\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT > template<typename RhsT > auto {\b Catch::ExprLhs}< LhsT >::operator>= (RhsT const &  {\i rhs}) -> {\b BinaryExpr}<LhsT, RhsT const&> const {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1365                                                                                     \{\par
1366             {\cf19 return} \{ {\cf17 static_cast<}{\cf18 bool}{\cf17 >}(m_lhs >= rhs), m_lhs, {\cf22 ">="}, rhs \};\par
1367         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::IExceptionTranslator\par \pard\plain 
{\tc\tcl2 \v Catch::IExceptionTranslator}
{\xe \v Catch::IExceptionTranslator}
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IExceptionTranslator} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b translate} (ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd) const =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~IExceptionTranslator\:Catch::IExceptionTranslator}
{\xe \v Catch::IExceptionTranslator\:~IExceptionTranslator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Catch::IExceptionTranslator::~IExceptionTranslator (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v translate\:Catch::IExceptionTranslator}
{\xe \v Catch::IExceptionTranslator\:translate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::string Catch::IExceptionTranslator::translate (ExceptionTranslators::const_iterator  {\i it}, ExceptionTranslators::const_iterator  {\i itEnd}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::IExceptionTranslatorRegistry\par \pard\plain 
{\tc\tcl2 \v Catch::IExceptionTranslatorRegistry}
{\xe \v Catch::IExceptionTranslatorRegistry}
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IExceptionTranslatorRegistry} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b translateActiveException} () const =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~IExceptionTranslatorRegistry\:Catch::IExceptionTranslatorRegistry}
{\xe \v Catch::IExceptionTranslatorRegistry\:~IExceptionTranslatorRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Catch::IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v translateActiveException\:Catch::IExceptionTranslatorRegistry}
{\xe \v Catch::IExceptionTranslatorRegistry\:translateActiveException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::string Catch::IExceptionTranslatorRegistry::translateActiveException () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::IMutableRegistryHub\par \pard\plain 
{\tc\tcl2 \v Catch::IMutableRegistryHub}
{\xe \v Catch::IMutableRegistryHub}
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IMutableRegistryHub} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b registerReporter} (std::string const &name, {\b IReporterFactoryPtr} const &factory)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b registerListener} ({\b IReporterFactoryPtr} const &factory)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b registerTest} ({\b TestCase} const &testInfo)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b registerTranslator} (const {\b IExceptionTranslator} *translator)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b registerTagAlias} (std::string const &alias, std::string const &tag, {\b SourceLineInfo} const &lineInfo)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b registerStartupException} () noexcept=0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~IMutableRegistryHub\:Catch::IMutableRegistryHub}
{\xe \v Catch::IMutableRegistryHub\:~IMutableRegistryHub}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Catch::IMutableRegistryHub::~IMutableRegistryHub (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v registerListener\:Catch::IMutableRegistryHub}
{\xe \v Catch::IMutableRegistryHub\:registerListener}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IMutableRegistryHub::registerListener ({\b IReporterFactoryPtr} const &  {\i factory}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v registerReporter\:Catch::IMutableRegistryHub}
{\xe \v Catch::IMutableRegistryHub\:registerReporter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IMutableRegistryHub::registerReporter (std::string const &  {\i name}, {\b IReporterFactoryPtr} const &  {\i factory}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v registerStartupException\:Catch::IMutableRegistryHub}
{\xe \v Catch::IMutableRegistryHub\:registerStartupException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IMutableRegistryHub::registerStartupException (){\f2 [pure virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v registerTagAlias\:Catch::IMutableRegistryHub}
{\xe \v Catch::IMutableRegistryHub\:registerTagAlias}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IMutableRegistryHub::registerTagAlias (std::string const &  {\i alias}, std::string const &  {\i tag}, {\b SourceLineInfo} const &  {\i lineInfo}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v registerTest\:Catch::IMutableRegistryHub}
{\xe \v Catch::IMutableRegistryHub\:registerTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IMutableRegistryHub::registerTest ({\b TestCase} const &  {\i testInfo}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v registerTranslator\:Catch::IMutableRegistryHub}
{\xe \v Catch::IMutableRegistryHub\:registerTranslator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IMutableRegistryHub::registerTranslator (const {\b IExceptionTranslator} *  {\i translator}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::IRegistryHub\par \pard\plain 
{\tc\tcl2 \v Catch::IRegistryHub}
{\xe \v Catch::IRegistryHub}
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IRegistryHub} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual IReporterRegistry const & {\b getReporterRegistry} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ITestCaseRegistry} const & {\b getTestCaseRegistry} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual ITagAliasRegistry const & {\b getTagAliasRegistry} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b IExceptionTranslatorRegistry} & {\b getExceptionTranslatorRegistry} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual StartupExceptionRegistry const & {\b getStartupExceptionRegistry} () const =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~IRegistryHub\:Catch::IRegistryHub}
{\xe \v Catch::IRegistryHub\:~IRegistryHub}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Catch::IRegistryHub::~IRegistryHub (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getExceptionTranslatorRegistry\:Catch::IRegistryHub}
{\xe \v Catch::IRegistryHub\:getExceptionTranslatorRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b IExceptionTranslatorRegistry} & Catch::IRegistryHub::getExceptionTranslatorRegistry (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getReporterRegistry\:Catch::IRegistryHub}
{\xe \v Catch::IRegistryHub\:getReporterRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual IReporterRegistry const  & Catch::IRegistryHub::getReporterRegistry () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getStartupExceptionRegistry\:Catch::IRegistryHub}
{\xe \v Catch::IRegistryHub\:getStartupExceptionRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual StartupExceptionRegistry const  & Catch::IRegistryHub::getStartupExceptionRegistry () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getTagAliasRegistry\:Catch::IRegistryHub}
{\xe \v Catch::IRegistryHub\:getTagAliasRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual ITagAliasRegistry const  & Catch::IRegistryHub::getTagAliasRegistry () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getTestCaseRegistry\:Catch::IRegistryHub}
{\xe \v Catch::IRegistryHub\:getTestCaseRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b ITestCaseRegistry} const  & Catch::IRegistryHub::getTestCaseRegistry () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::IResultCapture\par \pard\plain 
{\tc\tcl2 \v Catch::IResultCapture}
{\xe \v Catch::IResultCapture}
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IResultCapture} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b sectionStarted} ({\b SectionInfo} const &sectionInfo, {\b Counts} &assertions)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b sectionEnded} ({\b SectionEndInfo} const &endInfo)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b sectionEndedEarly} ({\b SectionEndInfo} const &endInfo)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b benchmarkStarting} (BenchmarkInfo const &info)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b benchmarkEnded} (BenchmarkStats const &stats)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b pushScopedMessage} ({\b MessageInfo} const &message)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b popScopedMessage} ({\b MessageInfo} const &message)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleFatalErrorCondition} ({\b StringRef} message)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleExpr} ({\b AssertionInfo} const &info, {\b ITransientExpression} const &expr, {\b AssertionReaction} &reaction)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleMessage} ({\b AssertionInfo} const &info, {\b ResultWas::OfType} resultType, {\b StringRef} const &message, {\b AssertionReaction} &reaction)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleUnexpectedExceptionNotThrown} ({\b AssertionInfo} const &info, {\b AssertionReaction} &reaction)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleUnexpectedInflightException} ({\b AssertionInfo} const &info, std::string const &message, {\b AssertionReaction} &reaction)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleIncomplete} ({\b AssertionInfo} const &info)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleNonExpr} ({\b AssertionInfo} const &info, {\b ResultWas::OfType} resultType, {\b AssertionReaction} &reaction)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b lastAssertionPassed} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b assertionPassed} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b getCurrentTestName} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const AssertionResult * {\b getLastResult} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b exceptionEarlyReported} ()=0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~IResultCapture\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:~IResultCapture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Catch::IResultCapture::~IResultCapture (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v assertionPassed\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:assertionPassed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::assertionPassed (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v benchmarkEnded\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:benchmarkEnded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::benchmarkEnded (BenchmarkStats const &  {\i stats}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v benchmarkStarting\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:benchmarkStarting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::benchmarkStarting (BenchmarkInfo const &  {\i info}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v exceptionEarlyReported\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:exceptionEarlyReported}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::exceptionEarlyReported (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getCurrentTestName\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:getCurrentTestName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::string Catch::IResultCapture::getCurrentTestName () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getLastResult\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:getLastResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual const AssertionResult * Catch::IResultCapture::getLastResult () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleExpr\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:handleExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::handleExpr ({\b AssertionInfo} const &  {\i info}, {\b ITransientExpression} const &  {\i expr}, {\b AssertionReaction} &  {\i reaction}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleFatalErrorCondition\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:handleFatalErrorCondition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::handleFatalErrorCondition ({\b StringRef}  {\i message}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleIncomplete\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:handleIncomplete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::handleIncomplete ({\b AssertionInfo} const &  {\i info}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleMessage\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:handleMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::handleMessage ({\b AssertionInfo} const &  {\i info}, {\b ResultWas::OfType}  {\i resultType}, {\b StringRef} const &  {\i message}, {\b AssertionReaction} &  {\i reaction}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleNonExpr\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:handleNonExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::handleNonExpr ({\b AssertionInfo} const &  {\i info}, {\b ResultWas::OfType}  {\i resultType}, {\b AssertionReaction} &  {\i reaction}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleUnexpectedExceptionNotThrown\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:handleUnexpectedExceptionNotThrown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::handleUnexpectedExceptionNotThrown ({\b AssertionInfo} const &  {\i info}, {\b AssertionReaction} &  {\i reaction}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleUnexpectedInflightException\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:handleUnexpectedInflightException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::handleUnexpectedInflightException ({\b AssertionInfo} const &  {\i info}, std::string const &  {\i message}, {\b AssertionReaction} &  {\i reaction}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lastAssertionPassed\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:lastAssertionPassed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Catch::IResultCapture::lastAssertionPassed (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v popScopedMessage\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:popScopedMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::popScopedMessage ({\b MessageInfo} const &  {\i message}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pushScopedMessage\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:pushScopedMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::pushScopedMessage ({\b MessageInfo} const &  {\i message}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sectionEnded\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:sectionEnded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::sectionEnded ({\b SectionEndInfo} const &  {\i endInfo}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sectionEndedEarly\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:sectionEndedEarly}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::sectionEndedEarly ({\b SectionEndInfo} const &  {\i endInfo}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sectionStarted\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:sectionStarted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Catch::IResultCapture::sectionStarted ({\b SectionInfo} const &  {\i sectionInfo}, {\b Counts} &  {\i assertions}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::IRunner\par \pard\plain 
{\tc\tcl2 \v Catch::IRunner}
{\xe \v Catch::IRunner}
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IRunner} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b aborting} () const =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~IRunner\:Catch::IRunner}
{\xe \v Catch::IRunner\:~IRunner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Catch::IRunner::~IRunner (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v aborting\:Catch::IRunner}
{\xe \v Catch::IRunner\:aborting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Catch::IRunner::aborting () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Estrutura Catch::is_range< T >\par \pard\plain 
{\tc\tcl2 \v Catch::is_range< T >}
{\xe \v Catch::is_range< T >}
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos Est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const bool {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v value\:Catch::is_range< T >}
{\xe \v Catch::is_range< T >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > const bool {\b Catch::is_range}< T >::value{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor inicial:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
            !std::is_same<decltype(begin(std::declval<T>())), not_this_one>::value &&\par
            !std::is_same<decltype(end(std::declval<T>())), not_this_one>::value\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Classe Catch::Detail::IsStreamInsertable< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Detail::IsStreamInsertable< T >}
{\xe \v Catch::Detail::IsStreamInsertable< T >}
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos Est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const bool {\b value} = decltype(test<std::ostream, const T&>(0))::value\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v value\:Catch::Detail::IsStreamInsertable< T >}
{\xe \v Catch::Detail::IsStreamInsertable< T >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > const bool {\b Catch::Detail::IsStreamInsertable}< T >::value = decltype(test<std::ostream, const T&>(0))::value{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::IStream\par \pard\plain 
{\tc\tcl2 \v Catch::IStream}
{\xe \v Catch::IStream}
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IStream} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::ostream & {\b stream} () const =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~IStream\:Catch::IStream}
{\xe \v Catch::IStream\:~IStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Catch::IStream::~IStream (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v stream\:Catch::IStream}
{\xe \v Catch::IStream\:stream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::ostream & Catch::IStream::stream () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::ITestCaseRegistry\par \pard\plain 
{\tc\tcl2 \v Catch::ITestCaseRegistry}
{\xe \v Catch::ITestCaseRegistry}
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ITestCaseRegistry} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::vector< {\b TestCase} > const & {\b getAllTests} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::vector< {\b TestCase} > const & {\b getAllTestsSorted} (IConfig const &config) const =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~ITestCaseRegistry\:Catch::ITestCaseRegistry}
{\xe \v Catch::ITestCaseRegistry\:~ITestCaseRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Catch::ITestCaseRegistry::~ITestCaseRegistry (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getAllTests\:Catch::ITestCaseRegistry}
{\xe \v Catch::ITestCaseRegistry\:getAllTests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::vector< {\b TestCase} > const  & Catch::ITestCaseRegistry::getAllTests () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getAllTestsSorted\:Catch::ITestCaseRegistry}
{\xe \v Catch::ITestCaseRegistry\:getAllTestsSorted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::vector< {\b TestCase} > const  & Catch::ITestCaseRegistry::getAllTestsSorted (IConfig const &  {\i config}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::ITestInvoker\par \pard\plain 
{\tc\tcl2 \v Catch::ITestInvoker}
{\xe \v Catch::ITestInvoker}
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::ITestInvoker:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_i_test_invoker.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b invoke} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ITestInvoker} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~ITestInvoker\:Catch::ITestInvoker}
{\xe \v Catch::ITestInvoker\:~ITestInvoker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Catch::ITestInvoker::~ITestInvoker (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v invoke\:Catch::ITestInvoker}
{\xe \v Catch::ITestInvoker\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::ITestInvoker::invoke () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::TestInvokerAsMethod< C >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::ITransientExpression\par \pard\plain 
{\tc\tcl2 \v Catch::ITransientExpression}
{\xe \v Catch::ITransientExpression}
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::ITransientExpression:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_i_transient_expression.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b isBinaryExpression} () const -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b getResult} () const -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b streamReconstructedExpression} (std::ostream &os) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ITransientExpression} (bool {\b isBinaryExpression}, bool result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ITransientExpression} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_isBinaryExpression}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_result}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ITransientExpression\:Catch::ITransientExpression}
{\xe \v Catch::ITransientExpression\:ITransientExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::ITransientExpression::ITransientExpression (bool  {\i isBinaryExpression}, bool  {\i result}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1261         :   m_isBinaryExpression( isBinaryExpression ),\par
1262             m_result( result )\par
1263         \{\}\par
}
}
{\xe \v ~ITransientExpression\:Catch::ITransientExpression}
{\xe \v Catch::ITransientExpression\:~ITransientExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Catch::ITransientExpression::~ITransientExpression (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getResult\:Catch::ITransientExpression}
{\xe \v Catch::ITransientExpression\:getResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::ITransientExpression::getResult () const -> bool {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1257 \{ {\cf19 return} m_result; \}\par
}
}
{\xe \v isBinaryExpression\:Catch::ITransientExpression}
{\xe \v Catch::ITransientExpression\:isBinaryExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::ITransientExpression::isBinaryExpression () const -> bool {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1256 \{ {\cf19 return} m_isBinaryExpression; \}\par
}
}
{\xe \v streamReconstructedExpression\:Catch::ITransientExpression}
{\xe \v Catch::ITransientExpression\:streamReconstructedExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::ITransientExpression::streamReconstructedExpression (std::ostream &  {\i os}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::MatchExpr< ArgT, MatcherT >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_isBinaryExpression\:Catch::ITransientExpression}
{\xe \v Catch::ITransientExpression\:m_isBinaryExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::ITransientExpression::m_isBinaryExpression}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v m_result\:Catch::ITransientExpression}
{\xe \v Catch::ITransientExpression\:m_result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::ITransientExpression::m_result}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::LazyExpression\par \pard\plain 
{\tc\tcl2 \v Catch::LazyExpression}
{\xe \v Catch::LazyExpression}
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LazyExpression} (bool isNegated)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LazyExpression} ({\b LazyExpression} const &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LazyExpression} & {\b operator=} ({\b LazyExpression} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator bool} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AssertionHandler}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b AssertionStats}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RunContext}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator<<} (std::ostream &os, {\b LazyExpression} const &lazyExpr) -> std::ostream &\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v LazyExpression\:Catch::LazyExpression}
{\xe \v Catch::LazyExpression\:LazyExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::LazyExpression::LazyExpression (bool  {\i isNegated})}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v LazyExpression\:Catch::LazyExpression}
{\xe \v Catch::LazyExpression\:LazyExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::LazyExpression::LazyExpression ({\b LazyExpression} const &  {\i other})}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator bool\:Catch::LazyExpression}
{\xe \v Catch::LazyExpression\:operator bool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::LazyExpression::operator bool () const{\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:Catch::LazyExpression}
{\xe \v Catch::LazyExpression\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LazyExpression} & Catch::LazyExpression::operator= ({\b LazyExpression} const & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v AssertionHandler\:Catch::LazyExpression}
{\xe \v Catch::LazyExpression\:AssertionHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b AssertionHandler}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v AssertionStats\:Catch::LazyExpression}
{\xe \v Catch::LazyExpression\:AssertionStats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend struct AssertionStats{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<<\:Catch::LazyExpression}
{\xe \v Catch::LazyExpression\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto operator<< (std::ostream &  {\i os}, {\b LazyExpression} const &  {\i lazyExpr}) ->  std::ostream &{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v RunContext\:Catch::LazyExpression}
{\xe \v Catch::LazyExpression\:RunContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class RunContext{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Estrutura Catch::Matchers::Impl::MatchAllOf< ArgT >\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::Impl::MatchAllOf< ArgT >}
{\xe \v Catch::Matchers::Impl::MatchAllOf< ArgT >}
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::Matchers::Impl::MatchAllOf< ArgT >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_matchers_1_1_impl_1_1_match_all_of.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b match} (ArgT const &arg) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b describe} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAllOf}< ArgT > & {\b operator&&} ({\b MatcherBase}< ArgT > const &other)\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherBase< ArgT >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAllOf}< ArgT > {\b operator&&} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAnyOf}< ArgT > {\b operator||} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchNotOf}< ArgT > {\b operator!} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ({\b MatcherUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} & {\b operator=} ({\b MatcherUntypedBase} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherMethod< ObjectT >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b match} (ObjectT const &arg) const =0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b MatcherBase}< ArgT > const  * > {\b m_matchers}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MatcherUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b describe} () const =0\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_cachedToString}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v describe\:Catch::Matchers::Impl::MatchAllOf< ArgT >}
{\xe \v Catch::Matchers::Impl::MatchAllOf< ArgT >\:describe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ArgT > std::string {\b Catch::Matchers::Impl::MatchAllOf}< ArgT >::describe () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Matchers::Impl::MatcherUntypedBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2222                                                 \{\par
2223                 std::string description;\par
2224                 description.reserve( 4 + m_matchers.size()*32 );\par
2225                 description += {\cf22 "( "};\par
2226                 {\cf18 bool} first = {\cf17 true};\par
2227                 {\cf19 for}( {\cf17 auto} matcher : m_matchers ) \{\par
2228                     {\cf19 if}( first )\par
2229                         first = {\cf17 false};\par
2230                     {\cf19 else}\par
2231                         description += {\cf22 " and "};\par
2232                     description += matcher->toString();\par
2233                 \}\par
2234                 description += {\cf22 " )"};\par
2235                 {\cf19 return} description;\par
2236             \}\par
}
}
{\xe \v match\:Catch::Matchers::Impl::MatchAllOf< ArgT >}
{\xe \v Catch::Matchers::Impl::MatchAllOf< ArgT >\:match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ArgT > bool {\b Catch::Matchers::Impl::MatchAllOf}< ArgT >::match (ArgT const &  {\i arg}) const{\f2 [inline]}, {\f2 [override]}}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2215                                                          \{\par
2216                 {\cf19 for}( {\cf17 auto} matcher : m_matchers ) \{\par
2217                     {\cf19 if} (!matcher->match(arg))\par
2218                         {\cf19 return} {\cf17 false};\par
2219                 \}\par
2220                 {\cf19 return} {\cf17 true};\par
2221             \}\par
}
}
{\xe \v operator&&\:Catch::Matchers::Impl::MatchAllOf< ArgT >}
{\xe \v Catch::Matchers::Impl::MatchAllOf< ArgT >\:operator&&}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ArgT > {\b MatchAllOf}< ArgT > & {\b Catch::Matchers::Impl::MatchAllOf}< ArgT >::operator&& ({\b MatcherBase}< ArgT > const &  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2238                                                                              \{\par
2239                 m_matchers.push_back( &other );\par
2240                 {\cf19 return} *{\cf17 this};\par
2241             \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_matchers\:Catch::Matchers::Impl::MatchAllOf< ArgT >}
{\xe \v Catch::Matchers::Impl::MatchAllOf< ArgT >\:m_matchers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ArgT > std::vector<{\b MatcherBase}<ArgT> const*> {\b Catch::Matchers::Impl::MatchAllOf}< ArgT >::m_matchers}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Estrutura Catch::Matchers::Impl::MatchAnyOf< ArgT >\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::Impl::MatchAnyOf< ArgT >}
{\xe \v Catch::Matchers::Impl::MatchAnyOf< ArgT >}
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::Matchers::Impl::MatchAnyOf< ArgT >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_matchers_1_1_impl_1_1_match_any_of.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b match} (ArgT const &arg) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b describe} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAnyOf}< ArgT > & {\b operator||} ({\b MatcherBase}< ArgT > const &other)\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherBase< ArgT >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAllOf}< ArgT > {\b operator&&} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAnyOf}< ArgT > {\b operator||} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchNotOf}< ArgT > {\b operator!} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ({\b MatcherUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} & {\b operator=} ({\b MatcherUntypedBase} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherMethod< ObjectT >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b match} (ObjectT const &arg) const =0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b MatcherBase}< ArgT > const  * > {\b m_matchers}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MatcherUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b describe} () const =0\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_cachedToString}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v describe\:Catch::Matchers::Impl::MatchAnyOf< ArgT >}
{\xe \v Catch::Matchers::Impl::MatchAnyOf< ArgT >\:describe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ArgT > std::string {\b Catch::Matchers::Impl::MatchAnyOf}< ArgT >::describe () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Matchers::Impl::MatcherUntypedBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2255                                                 \{\par
2256                 std::string description;\par
2257                 description.reserve( 4 + m_matchers.size()*32 );\par
2258                 description += {\cf22 "( "};\par
2259                 {\cf18 bool} first = {\cf17 true};\par
2260                 {\cf19 for}( {\cf17 auto} matcher : m_matchers ) \{\par
2261                     {\cf19 if}( first )\par
2262                         first = {\cf17 false};\par
2263                     {\cf19 else}\par
2264                         description += {\cf22 " or "};\par
2265                     description += matcher->toString();\par
2266                 \}\par
2267                 description += {\cf22 " )"};\par
2268                 {\cf19 return} description;\par
2269             \}\par
}
}
{\xe \v match\:Catch::Matchers::Impl::MatchAnyOf< ArgT >}
{\xe \v Catch::Matchers::Impl::MatchAnyOf< ArgT >\:match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ArgT > bool {\b Catch::Matchers::Impl::MatchAnyOf}< ArgT >::match (ArgT const &  {\i arg}) const{\f2 [inline]}, {\f2 [override]}}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2248                                                          \{\par
2249                 {\cf19 for}( {\cf17 auto} matcher : m_matchers ) \{\par
2250                     {\cf19 if} (matcher->match(arg))\par
2251                         {\cf19 return} {\cf17 true};\par
2252                 \}\par
2253                 {\cf19 return} {\cf17 false};\par
2254             \}\par
}
}
{\xe \v operator||\:Catch::Matchers::Impl::MatchAnyOf< ArgT >}
{\xe \v Catch::Matchers::Impl::MatchAnyOf< ArgT >\:operator||}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ArgT > {\b MatchAnyOf}< ArgT > & {\b Catch::Matchers::Impl::MatchAnyOf}< ArgT >::operator|| ({\b MatcherBase}< ArgT > const &  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2271                                                                              \{\par
2272                 m_matchers.push_back( &other );\par
2273                 {\cf19 return} *{\cf17 this};\par
2274             \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_matchers\:Catch::Matchers::Impl::MatchAnyOf< ArgT >}
{\xe \v Catch::Matchers::Impl::MatchAnyOf< ArgT >\:m_matchers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ArgT > std::vector<{\b MatcherBase}<ArgT> const*> {\b Catch::Matchers::Impl::MatchAnyOf}< ArgT >::m_matchers}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Estrutura Catch::Matchers::Impl::MatcherBase< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::Impl::MatcherBase< T >}
{\xe \v Catch::Matchers::Impl::MatcherBase< T >}
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::Matchers::Impl::MatcherBase< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAllOf}< T > {\b operator&&} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAnyOf}< T > {\b operator||} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchNotOf}< T > {\b operator!} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ({\b MatcherUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} & {\b operator=} ({\b MatcherUntypedBase} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherMethod< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b match} (T const &arg) const=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MatcherUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b describe} () const =0\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_cachedToString}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator!\:Catch::Matchers::Impl::MatcherBase< T >}
{\xe \v Catch::Matchers::Impl::MatcherBase< T >\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b MatchNotOf}< T > {\b Catch::Matchers::Impl::MatcherBase}< T >::operator!}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2303                                                         \{\par
2304             {\cf19 return} MatchNotOf<T>( *{\cf17 this} );\par
2305         \}\par
}
}
{\xe \v operator&&\:Catch::Matchers::Impl::MatcherBase< T >}
{\xe \v Catch::Matchers::Impl::MatcherBase< T >\:operator&&}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b MatchAllOf}< T > {\b Catch::Matchers::Impl::MatcherBase}< T >::operator&& ({\b MatcherBase}< T > const &  {\i other}) const}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2295                                                                                    \{\par
2296             {\cf19 return} MatchAllOf<T>() && *{\cf17 this} && other;\par
2297         \}\par
}
}
{\xe \v operator||\:Catch::Matchers::Impl::MatcherBase< T >}
{\xe \v Catch::Matchers::Impl::MatcherBase< T >\:operator||}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b MatchAnyOf}< T > {\b Catch::Matchers::Impl::MatcherBase}< T >::operator|| ({\b MatcherBase}< T > const &  {\i other}) const}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2299                                                                                    \{\par
2300             {\cf19 return} MatchAnyOf<T>() || *{\cf17 this} || other;\par
2301         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Estrutura Catch::Matchers::Impl::MatcherMethod< ObjectT >\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::Impl::MatcherMethod< ObjectT >}
{\xe \v Catch::Matchers::Impl::MatcherMethod< ObjectT >}
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::Matchers::Impl::MatcherMethod< ObjectT >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_matchers_1_1_impl_1_1_matcher_method.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b match} (ObjectT const &arg) const =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v match\:Catch::Matchers::Impl::MatcherMethod< ObjectT >}
{\xe \v Catch::Matchers::Impl::MatcherMethod< ObjectT >\:match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ObjectT > virtual bool {\b Catch::Matchers::Impl::MatcherMethod}< ObjectT >::match (ObjectT const &  {\i arg}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Estrutura Catch::Matchers::Impl::MatcherMethod< PtrT * >\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::Impl::MatcherMethod< PtrT * >}
{\xe \v Catch::Matchers::Impl::MatcherMethod< PtrT * >}
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b match} (PtrT *arg) const =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v match\:Catch::Matchers::Impl::MatcherMethod< PtrT * >}
{\xe \v Catch::Matchers::Impl::MatcherMethod< PtrT * >\:match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename PtrT > virtual bool {\b Catch::Matchers::Impl::MatcherMethod}< PtrT * >::match (PtrT *  {\i arg}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Matchers::Impl::MatcherUntypedBase\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::Impl::MatcherUntypedBase}
{\xe \v Catch::Matchers::Impl::MatcherUntypedBase}
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::Matchers::Impl::MatcherUntypedBase:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_matchers_1_1_impl_1_1_matcher_untyped_base.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ({\b MatcherUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} & {\b operator=} ({\b MatcherUntypedBase} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros protegidos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MatcherUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b describe} () const =0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos Protegidos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_cachedToString}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v MatcherUntypedBase\:Catch::Matchers::Impl::MatcherUntypedBase}
{\xe \v Catch::Matchers::Impl::MatcherUntypedBase\:MatcherUntypedBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Matchers::Impl::MatcherUntypedBase::MatcherUntypedBase (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MatcherUntypedBase\:Catch::Matchers::Impl::MatcherUntypedBase}
{\xe \v Catch::Matchers::Impl::MatcherUntypedBase\:MatcherUntypedBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Matchers::Impl::MatcherUntypedBase::MatcherUntypedBase ({\b MatcherUntypedBase} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~MatcherUntypedBase\:Catch::Matchers::Impl::MatcherUntypedBase}
{\xe \v Catch::Matchers::Impl::MatcherUntypedBase\:~MatcherUntypedBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Catch::Matchers::Impl::MatcherUntypedBase::~MatcherUntypedBase (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v describe\:Catch::Matchers::Impl::MatcherUntypedBase}
{\xe \v Catch::Matchers::Impl::MatcherUntypedBase\:describe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::string Catch::Matchers::Impl::MatcherUntypedBase::describe () const{\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Matchers::Impl::MatchAllOf< ArgT >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXD \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Catch::Matchers::Impl::MatchAnyOf< ArgT >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXI \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Catch::Matchers::Impl::MatchNotOf< ArgT >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXY \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Catch::Matchers::Floating::WithinAbsMatcher} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWU \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Catch::Matchers::Floating::WithinUlpsMatcher} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWZ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Catch::Matchers::StdString::StringMatcherBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXZ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Catch::Matchers::StdString::RegexMatcher} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYA \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Catch::Matchers::Vector::ContainsElementMatcher< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYB \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Catch::Matchers::Vector::ContainsMatcher< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYC \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Catch::Matchers::Vector::EqualsMatcher< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYD \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b Catch::Matchers::Vector::UnorderedEqualsMatcher< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v operator=\:Catch::Matchers::Impl::MatcherUntypedBase}
{\xe \v Catch::Matchers::Impl::MatcherUntypedBase\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MatcherUntypedBase} & Catch::Matchers::Impl::MatcherUntypedBase::operator= ({\b MatcherUntypedBase} const & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v toString\:Catch::Matchers::Impl::MatcherUntypedBase}
{\xe \v Catch::Matchers::Impl::MatcherUntypedBase\:toString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::Matchers::Impl::MatcherUntypedBase::toString () const}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_cachedToString\:Catch::Matchers::Impl::MatcherUntypedBase}
{\xe \v Catch::Matchers::Impl::MatcherUntypedBase\:m_cachedToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::Matchers::Impl::MatcherUntypedBase::m_cachedToString{\f2 [mutable]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Classe Catch::MatchExpr< ArgT, MatcherT >\par \pard\plain 
{\tc\tcl2 \v Catch::MatchExpr< ArgT, MatcherT >}
{\xe \v Catch::MatchExpr< ArgT, MatcherT >}
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::MatchExpr< ArgT, MatcherT >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_match_expr.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchExpr} (ArgT const &arg, MatcherT const &matcher, {\b StringRef} matcherString)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b streamReconstructedExpression} (std::ostream &os) const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::ITransientExpression}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b isBinaryExpression} () const -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b getResult} () const -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b streamReconstructedExpression} (std::ostream &os) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ITransientExpression} (bool {\b isBinaryExpression}, bool result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ITransientExpression} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos P\'FAblicos herdados de {\b Catch::ITransientExpression}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_isBinaryExpression}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_result}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v MatchExpr\:Catch::MatchExpr< ArgT, MatcherT >}
{\xe \v Catch::MatchExpr< ArgT, MatcherT >\:MatchExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ArgT , typename MatcherT > {\b Catch::MatchExpr}< ArgT, MatcherT >::MatchExpr (ArgT const &  {\i arg}, MatcherT const &  {\i matcher}, {\b StringRef}  {\i matcherString}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2611         :   ITransientExpression\{ {\cf17 true}, matcher.match( arg ) \},\par
2612             m_arg( arg ),\par
2613             m_matcher( matcher ),\par
2614             m_matcherString( matcherString )\par
2615         \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v streamReconstructedExpression\:Catch::MatchExpr< ArgT, MatcherT >}
{\xe \v Catch::MatchExpr< ArgT, MatcherT >\:streamReconstructedExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ArgT , typename MatcherT > void {\b Catch::MatchExpr}< ArgT, MatcherT >::streamReconstructedExpression (std::ostream &  {\i os}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::ITransientExpression} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2617                                                                             \{\par
2618             {\cf17 auto} matcherAsString = m_matcher.toString();\par
2619             os << Catch::Detail::stringify( m_arg ) << {\cf23 ' '};\par
2620             {\cf19 if}( matcherAsString == Detail::unprintableString )\par
2621                 os << m_matcherString;\par
2622             {\cf19 else}\par
2623                 os << matcherAsString;\par
2624         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Estrutura Catch::Matchers::Impl::MatchNotOf< ArgT >\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::Impl::MatchNotOf< ArgT >}
{\xe \v Catch::Matchers::Impl::MatchNotOf< ArgT >}
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::Matchers::Impl::MatchNotOf< ArgT >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_matchers_1_1_impl_1_1_match_not_of.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchNotOf} ({\b MatcherBase}< ArgT > const &underlyingMatcher)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b match} (ArgT const &arg) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b describe} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherBase< ArgT >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAllOf}< ArgT > {\b operator&&} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAnyOf}< ArgT > {\b operator||} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchNotOf}< ArgT > {\b operator!} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ({\b MatcherUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} & {\b operator=} ({\b MatcherUntypedBase} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherMethod< ObjectT >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b match} (ObjectT const &arg) const =0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherBase}< ArgT > const  & {\b m_underlyingMatcher}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MatcherUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b describe} () const =0\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_cachedToString}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v MatchNotOf\:Catch::Matchers::Impl::MatchNotOf< ArgT >}
{\xe \v Catch::Matchers::Impl::MatchNotOf< ArgT >\:MatchNotOf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ArgT > {\b Catch::Matchers::Impl::MatchNotOf}< ArgT >::MatchNotOf ({\b MatcherBase}< ArgT > const &  {\i underlyingMatcher}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2282 : m_underlyingMatcher( underlyingMatcher ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v describe\:Catch::Matchers::Impl::MatchNotOf< ArgT >}
{\xe \v Catch::Matchers::Impl::MatchNotOf< ArgT >\:describe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ArgT > std::string {\b Catch::Matchers::Impl::MatchNotOf}< ArgT >::describe () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Matchers::Impl::MatcherUntypedBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2288                                                 \{\par
2289                 {\cf19 return} {\cf22 "not "} + m_underlyingMatcher.toString();\par
2290             \}\par
}
}
{\xe \v match\:Catch::Matchers::Impl::MatchNotOf< ArgT >}
{\xe \v Catch::Matchers::Impl::MatchNotOf< ArgT >\:match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ArgT > bool {\b Catch::Matchers::Impl::MatchNotOf}< ArgT >::match (ArgT const &  {\i arg}) const{\f2 [inline]}, {\f2 [override]}}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2284                                                          \{\par
2285                 {\cf19 return} !m_underlyingMatcher.match( arg );\par
2286             \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_underlyingMatcher\:Catch::Matchers::Impl::MatchNotOf< ArgT >}
{\xe \v Catch::Matchers::Impl::MatchNotOf< ArgT >\:m_underlyingMatcher}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ArgT > {\b MatcherBase}<ArgT> const& {\b Catch::Matchers::Impl::MatchNotOf}< ArgT >::m_underlyingMatcher}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::MessageBuilder\par \pard\plain 
{\tc\tcl2 \v Catch::MessageBuilder}
{\xe \v Catch::MessageBuilder}
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::MessageBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_message_builder.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MessageBuilder} (std::string const &macroName, {\b SourceLineInfo} const &lineInfo, {\b ResultWas::OfType} type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b MessageBuilder} & {\b operator<<} (T const &value)\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::MessageStream}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b MessageStream} & {\b operator<<} (T const &value)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MessageInfo} {\b m_info}\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos P\'FAblicos herdados de {\b Catch::MessageStream}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReusableStringStream} {\b m_stream}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v MessageBuilder\:Catch::MessageBuilder}
{\xe \v Catch::MessageBuilder\:MessageBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::MessageBuilder::MessageBuilder (std::string const &  {\i macroName}, {\b SourceLineInfo} const &  {\i lineInfo}, {\b ResultWas::OfType}  {\i type})}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator<<\:Catch::MessageBuilder}
{\xe \v Catch::MessageBuilder\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b MessageBuilder} & Catch::MessageBuilder::operator<< (T const &  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1587                                                        \{\par
1588             m_stream << value;\par
1589             {\cf19 return} *{\cf17 this};\par
1590         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_info\:Catch::MessageBuilder}
{\xe \v Catch::MessageBuilder\:m_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MessageInfo} Catch::MessageBuilder::m_info}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::MessageInfo\par \pard\plain 
{\tc\tcl2 \v Catch::MessageInfo}
{\xe \v Catch::MessageInfo}
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MessageInfo} (std::string const &_macroName, {\b SourceLineInfo} const &_lineInfo, {\b ResultWas::OfType} _type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} ({\b MessageInfo} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} ({\b MessageInfo} const &other) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b macroName}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b message}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SourceLineInfo} {\b lineInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultWas::OfType} {\b type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b sequence}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v MessageInfo\:Catch::MessageInfo}
{\xe \v Catch::MessageInfo\:MessageInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::MessageInfo::MessageInfo (std::string const &  {\i _macroName}, {\b SourceLineInfo} const &  {\i _lineInfo}, {\b ResultWas::OfType}  {\i _type})}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator<\:Catch::MessageInfo}
{\xe \v Catch::MessageInfo\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::MessageInfo::operator< ({\b MessageInfo} const &  {\i other}) const}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:Catch::MessageInfo}
{\xe \v Catch::MessageInfo\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::MessageInfo::operator== ({\b MessageInfo} const &  {\i other}) const}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v lineInfo\:Catch::MessageInfo}
{\xe \v Catch::MessageInfo\:lineInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SourceLineInfo} Catch::MessageInfo::lineInfo}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v macroName\:Catch::MessageInfo}
{\xe \v Catch::MessageInfo\:macroName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::MessageInfo::macroName}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v message\:Catch::MessageInfo}
{\xe \v Catch::MessageInfo\:message}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::MessageInfo::message}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sequence\:Catch::MessageInfo}
{\xe \v Catch::MessageInfo\:sequence}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Catch::MessageInfo::sequence}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v type\:Catch::MessageInfo}
{\xe \v Catch::MessageInfo\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ResultWas::OfType} Catch::MessageInfo::type}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::MessageStream\par \pard\plain 
{\tc\tcl2 \v Catch::MessageStream}
{\xe \v Catch::MessageStream}
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::MessageStream:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_message_stream.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b MessageStream} & {\b operator<<} (T const &value)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReusableStringStream} {\b m_stream}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator<<\:Catch::MessageStream}
{\xe \v Catch::MessageStream\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b MessageStream} & Catch::MessageStream::operator<< (T const &  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1573                                                       \{\par
1574             m_stream << value;\par
1575             {\cf19 return} *{\cf17 this};\par
1576         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_stream\:Catch::MessageStream}
{\xe \v Catch::MessageStream\:m_stream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ReusableStringStream} Catch::MessageStream::m_stream}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::NameAndTags\par \pard\plain 
{\tc\tcl2 \v Catch::NameAndTags}
{\xe \v Catch::NameAndTags}
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NameAndTags} ({\b StringRef} const &name_={\b StringRef}(), {\b StringRef} const &tags_={\b StringRef}()) noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b name}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b tags}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v NameAndTags\:Catch::NameAndTags}
{\xe \v Catch::NameAndTags\:NameAndTags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::NameAndTags::NameAndTags ({\b StringRef} const &  {\i name_} = {\f2 {\b StringRef}()}, {\b StringRef} const &  {\i tags_} = {\f2 {\b StringRef}()}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v name\:Catch::NameAndTags}
{\xe \v Catch::NameAndTags\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::NameAndTags::name}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tags\:Catch::NameAndTags}
{\xe \v Catch::NameAndTags\:tags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::NameAndTags::tags}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::NonCopyable\par \pard\plain 
{\tc\tcl2 \v Catch::NonCopyable}
{\xe \v Catch::NonCopyable}
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::NonCopyable:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_non_copyable.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros protegidos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NonCopyable} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~NonCopyable} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v NonCopyable\:Catch::NonCopyable}
{\xe \v Catch::NonCopyable\:NonCopyable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::NonCopyable::NonCopyable (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~NonCopyable\:Catch::NonCopyable}
{\xe \v Catch::NonCopyable\:~NonCopyable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Catch::NonCopyable::~NonCopyable (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::not_this_one\par \pard\plain 
{\tc\tcl2 \v Catch::not_this_one}
{\xe \v Catch::not_this_one}
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
\par
{
{\f2 #include <catch.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::pluralise\par \pard\plain 
{\tc\tcl2 \v Catch::pluralise}
{\xe \v Catch::pluralise}
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pluralise} (std::size_t count, std::string const &label)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b m_count}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_label}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &os, {\b pluralise} const &pluraliser)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v pluralise\:Catch::pluralise}
{\xe \v Catch::pluralise\:pluralise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::pluralise::pluralise (std::size_t  {\i count}, std::string const &  {\i label})}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v operator<<\:Catch::pluralise}
{\xe \v Catch::pluralise\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream &  {\i os}, {\b pluralise} const &  {\i pluraliser}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_count\:Catch::pluralise}
{\xe \v Catch::pluralise\:m_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t Catch::pluralise::m_count}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v m_label\:Catch::pluralise}
{\xe \v Catch::pluralise\:m_label}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::pluralise::m_label}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Matchers::StdString::RegexMatcher\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::StdString::RegexMatcher}
{\xe \v Catch::Matchers::StdString::RegexMatcher}
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::Matchers::StdString::RegexMatcher:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_matchers_1_1_std_string_1_1_regex_matcher.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RegexMatcher} (std::string regex, {\b CaseSensitive::Choice} caseSensitivity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b match} (std::string const &matchee) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b describe} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherBase< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAllOf}< T > {\b operator&&} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAnyOf}< T > {\b operator||} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchNotOf}< T > {\b operator!} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ({\b MatcherUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} & {\b operator=} ({\b MatcherUntypedBase} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherMethod< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b match} (T const &arg) const=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MatcherUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b describe} () const =0\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_cachedToString}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v RegexMatcher\:Catch::Matchers::StdString::RegexMatcher}
{\xe \v Catch::Matchers::StdString::RegexMatcher\:RegexMatcher}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Matchers::StdString::RegexMatcher::RegexMatcher (std::string  {\i regex}, {\b CaseSensitive::Choice}  {\i caseSensitivity})}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v describe\:Catch::Matchers::StdString::RegexMatcher}
{\xe \v Catch::Matchers::StdString::RegexMatcher\:describe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::Matchers::StdString::RegexMatcher::describe () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Matchers::Impl::MatcherUntypedBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v match\:Catch::Matchers::StdString::RegexMatcher}
{\xe \v Catch::Matchers::StdString::RegexMatcher\:match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Matchers::StdString::RegexMatcher::match (std::string const &  {\i matchee}) const{\f2 [override]}}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::RegistrarForTagAliases\par \pard\plain 
{\tc\tcl2 \v Catch::RegistrarForTagAliases}
{\xe \v Catch::RegistrarForTagAliases}
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RegistrarForTagAliases} (char const *alias, char const *tag, {\b SourceLineInfo} const &lineInfo)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v RegistrarForTagAliases\:Catch::RegistrarForTagAliases}
{\xe \v Catch::RegistrarForTagAliases\:RegistrarForTagAliases}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::RegistrarForTagAliases::RegistrarForTagAliases (char const *  {\i alias}, char const *  {\i tag}, {\b SourceLineInfo} const &  {\i lineInfo})}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::ResultDisposition\par \pard\plain 
{\tc\tcl2 \v Catch::ResultDisposition}
{\xe \v Catch::ResultDisposition}
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Flags} \{ {\b Normal} = 0x01
, {\b ContinueOnFailure} = 0x02
, {\b FalseTest} = 0x04
, {\b SuppressFail} = 0x08
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das enumera\'E7\'F5es\par
\pard\plain 
{\xe \v Flags\:Catch::ResultDisposition}
{\xe \v Catch::ResultDisposition\:Flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Catch::ResultDisposition::Flags}}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Normal\:Catch::ResultDisposition}
{\xe \v Catch::ResultDisposition\:Normal}
{\qr Normal{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
\cell }{\cell }{\row }
{\xe \v ContinueOnFailure\:Catch::ResultDisposition}
{\xe \v Catch::ResultDisposition\:ContinueOnFailure}
{\qr ContinueOnFailure{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
\cell }{\cell }{\row }
{\xe \v FalseTest\:Catch::ResultDisposition}
{\xe \v Catch::ResultDisposition\:FalseTest}
{\qr FalseTest{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
\cell }{\cell }{\row }
{\xe \v SuppressFail\:Catch::ResultDisposition}
{\xe \v Catch::ResultDisposition\:SuppressFail}
{\qr SuppressFail{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
\cell }{\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 601                              \{ {\cf17 enum} Flags \{\par
602         Normal = 0x01,\par
603 \par
604         ContinueOnFailure = 0x02,   {\cf20 // Failures fail test, but execution continues}\par
605         FalseTest = 0x04,           {\cf20 // Prefix expression with !}\par
606         SuppressFail = 0x08         {\cf20 // Failures are reported but do not fail the test}\par
607     \}; \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::ResultWas\par \pard\plain 
{\tc\tcl2 \v Catch::ResultWas}
{\xe \v Catch::ResultWas}
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b OfType} \{ {\b Unknown} = -1
, {\b Ok} = 0
, {\b Info} = 1
, {\b Warning} = 2
, {\b FailureBit} = 0x10
, {\b ExpressionFailed} = FailureBit | 1
, {\b ExplicitFailure} = FailureBit | 2
, {\b Exception} = 0x100 | FailureBit
, {\b ThrewException} = Exception | 1
, {\b DidntThrowException} = Exception | 2
, {\b FatalErrorCondition} = 0x200 | FailureBit
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das enumera\'E7\'F5es\par
\pard\plain 
{\xe \v OfType\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:OfType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Catch::ResultWas::OfType}}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Unknown\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:Unknown}
{\qr Unknown{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
\cell }{\cell }{\row }
{\xe \v Ok\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:Ok}
{\qr Ok{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
\cell }{\cell }{\row }
{\xe \v Info\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:Info}
{\qr Info{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
\cell }{\cell }{\row }
{\xe \v Warning\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:Warning}
{\qr Warning{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
\cell }{\cell }{\row }
{\xe \v FailureBit\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:FailureBit}
{\qr FailureBit{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
\cell }{\cell }{\row }
{\xe \v ExpressionFailed\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:ExpressionFailed}
{\qr ExpressionFailed{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
\cell }{\cell }{\row }
{\xe \v ExplicitFailure\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:ExplicitFailure}
{\qr ExplicitFailure{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
\cell }{\cell }{\row }
{\xe \v Exception\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:Exception}
{\qr Exception{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
\cell }{\cell }{\row }
{\xe \v ThrewException\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:ThrewException}
{\qr ThrewException{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
\cell }{\cell }{\row }
{\xe \v DidntThrowException\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:DidntThrowException}
{\qr DidntThrowException{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
\cell }{\cell }{\row }
{\xe \v FatalErrorCondition\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:FatalErrorCondition}
{\qr FatalErrorCondition{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
\cell }{\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 577                      \{ {\cf17 enum} OfType \{\par
578         Unknown = -1,\par
579         Ok = 0,\par
580         Info = 1,\par
581         Warning = 2,\par
582 \par
583         FailureBit = 0x10,\par
584 \par
585         ExpressionFailed = FailureBit | 1,\par
586         ExplicitFailure = FailureBit | 2,\par
587 \par
588         Exception = 0x100 | FailureBit,\par
589 \par
590         ThrewException = Exception | 1,\par
591         DidntThrowException = Exception | 2,\par
592 \par
593         FatalErrorCondition = 0x200 | FailureBit\par
594 \par
595     \}; \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::ReusableStringStream\par \pard\plain 
{\tc\tcl2 \v Catch::ReusableStringStream}
{\xe \v Catch::ReusableStringStream}
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReusableStringStream} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~ReusableStringStream} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b str} () const -> std::string\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b operator<<} (T const &value) -> {\b ReusableStringStream} &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b get} () -> std::ostream &\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b cleanup} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ReusableStringStream\:Catch::ReusableStringStream}
{\xe \v Catch::ReusableStringStream\:ReusableStringStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::ReusableStringStream::ReusableStringStream ()}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~ReusableStringStream\:Catch::ReusableStringStream}
{\xe \v Catch::ReusableStringStream\:~ReusableStringStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::ReusableStringStream::~ReusableStringStream ()}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v cleanup\:Catch::ReusableStringStream}
{\xe \v Catch::ReusableStringStream\:cleanup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void Catch::ReusableStringStream::cleanup (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:Catch::ReusableStringStream}
{\xe \v Catch::ReusableStringStream\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::ReusableStringStream::get () -> std::ostream& {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 678 \{ {\cf19 return} *m_oss; \}\par
}
}
{\xe \v operator<<\:Catch::ReusableStringStream}
{\xe \v Catch::ReusableStringStream\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > auto Catch::ReusableStringStream::operator<< (T const &  {\i value}) -> {\b ReusableStringStream}& {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 674                                                                      \{\par
675             *m_oss << value;\par
676             {\cf19 return} *{\cf17 this};\par
677         \}\par
}
}
{\xe \v str\:Catch::ReusableStringStream}
{\xe \v Catch::ReusableStringStream\:str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::ReusableStringStream::str () const ->  std::string}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::ScopedMessage\par \pard\plain 
{\tc\tcl2 \v Catch::ScopedMessage}
{\xe \v Catch::ScopedMessage}
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScopedMessage} ({\b MessageBuilder} const &builder)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~ScopedMessage} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MessageInfo} {\b m_info}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ScopedMessage\:Catch::ScopedMessage}
{\xe \v Catch::ScopedMessage\:ScopedMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::ScopedMessage::ScopedMessage ({\b MessageBuilder} const &  {\i builder}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~ScopedMessage\:Catch::ScopedMessage}
{\xe \v Catch::ScopedMessage\:~ScopedMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::ScopedMessage::~ScopedMessage ()}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_info\:Catch::ScopedMessage}
{\xe \v Catch::ScopedMessage\:m_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MessageInfo} Catch::ScopedMessage::m_info}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Section\par \pard\plain 
{\tc\tcl2 \v Catch::Section}
{\xe \v Catch::Section}
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::Section:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_section.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Section} ({\b SectionInfo} const &info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Section} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator bool} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v Section\:Catch::Section}
{\xe \v Catch::Section\:Section}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Section::Section ({\b SectionInfo} const &  {\i info})}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Section\:Catch::Section}
{\xe \v Catch::Section\:~Section}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Section::~Section ()}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator bool\:Catch::Section}
{\xe \v Catch::Section\:operator bool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Section::operator bool () const{\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::SectionEndInfo\par \pard\plain 
{\tc\tcl2 \v Catch::SectionEndInfo}
{\xe \v Catch::SectionEndInfo}
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SectionEndInfo} ({\b SectionInfo} const &_sectionInfo, {\b Counts} const &_prevAssertions, double _durationInSeconds)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SectionInfo} {\b sectionInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Counts} {\b prevAssertions}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b durationInSeconds}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v SectionEndInfo\:Catch::SectionEndInfo}
{\xe \v Catch::SectionEndInfo\:SectionEndInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::SectionEndInfo::SectionEndInfo ({\b SectionInfo} const &  {\i _sectionInfo}, {\b Counts} const &  {\i _prevAssertions}, double  {\i _durationInSeconds})}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v durationInSeconds\:Catch::SectionEndInfo}
{\xe \v Catch::SectionEndInfo\:durationInSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Catch::SectionEndInfo::durationInSeconds}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v prevAssertions\:Catch::SectionEndInfo}
{\xe \v Catch::SectionEndInfo\:prevAssertions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Counts} Catch::SectionEndInfo::prevAssertions}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sectionInfo\:Catch::SectionEndInfo}
{\xe \v Catch::SectionEndInfo\:sectionInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SectionInfo} Catch::SectionEndInfo::sectionInfo}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::SectionInfo\par \pard\plain 
{\tc\tcl2 \v Catch::SectionInfo}
{\xe \v Catch::SectionInfo}
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SectionInfo} ({\b SourceLineInfo} const &_lineInfo, std::string const &_name, std::string const &_description=std::string())\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b name}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b description}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SourceLineInfo} {\b lineInfo}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v SectionInfo\:Catch::SectionInfo}
{\xe \v Catch::SectionInfo\:SectionInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::SectionInfo::SectionInfo ({\b SourceLineInfo} const &  {\i _lineInfo}, std::string const &  {\i _name}, std::string const &  {\i _description} = {\f2 std::string()})}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v description\:Catch::SectionInfo}
{\xe \v Catch::SectionInfo\:description}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::SectionInfo::description}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lineInfo\:Catch::SectionInfo}
{\xe \v Catch::SectionInfo\:lineInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SourceLineInfo} Catch::SectionInfo::lineInfo}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v name\:Catch::SectionInfo}
{\xe \v Catch::SectionInfo\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::SectionInfo::name}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::SourceLineInfo\par \pard\plain 
{\tc\tcl2 \v Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo}
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SourceLineInfo} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SourceLineInfo} (char const *_file, std::size_t _line) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SourceLineInfo} ({\b SourceLineInfo} const &other)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SourceLineInfo} ({\b SourceLineInfo} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SourceLineInfo} & {\b operator=} ({\b SourceLineInfo} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SourceLineInfo} & {\b operator=} ({\b SourceLineInfo} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b empty} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} ({\b SourceLineInfo} const &other) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} ({\b SourceLineInfo} const &other) const noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char const  * {\b file}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b line}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v SourceLineInfo\:Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo\:SourceLineInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::SourceLineInfo::SourceLineInfo (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SourceLineInfo\:Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo\:SourceLineInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::SourceLineInfo::SourceLineInfo (char const *  {\i _file}, std::size_t  {\i _line}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 276         :   file( _file ),\par
277             line( _line )\par
278         \{\}\par
}
}
{\xe \v SourceLineInfo\:Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo\:SourceLineInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::SourceLineInfo::SourceLineInfo ({\b SourceLineInfo} const &  {\i other}){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SourceLineInfo\:Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo\:SourceLineInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::SourceLineInfo::SourceLineInfo ({\b SourceLineInfo} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v empty\:Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo\:empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::SourceLineInfo::empty () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<\:Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::SourceLineInfo::operator< ({\b SourceLineInfo} const &  {\i other}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SourceLineInfo} & Catch::SourceLineInfo::operator= ({\b SourceLineInfo} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SourceLineInfo} & Catch::SourceLineInfo::operator= ({\b SourceLineInfo} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::SourceLineInfo::operator== ({\b SourceLineInfo} const &  {\i other}) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v file\:Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo\:file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char const* Catch::SourceLineInfo::file}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v line\:Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo\:line}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t Catch::SourceLineInfo::line}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Matchers::StdString::StartsWithMatcher\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::StdString::StartsWithMatcher}
{\xe \v Catch::Matchers::StdString::StartsWithMatcher}
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::Matchers::StdString::StartsWithMatcher:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_matchers_1_1_std_string_1_1_starts_with_matcher.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StartsWithMatcher} ({\b CasedString} const &comparator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b match} (std::string const &source) const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::StdString::StringMatcherBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringMatcherBase} (std::string const &operation, {\b CasedString} const &comparator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b describe} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherBase< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAllOf}< T > {\b operator&&} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAnyOf}< T > {\b operator||} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchNotOf}< T > {\b operator!} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ({\b MatcherUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} & {\b operator=} ({\b MatcherUntypedBase} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherMethod< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b match} (T const &arg) const=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos P\'FAblicos herdados de {\b Catch::Matchers::StdString::StringMatcherBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CasedString} {\b m_comparator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_operation}\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MatcherUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b describe} () const =0\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_cachedToString}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v StartsWithMatcher\:Catch::Matchers::StdString::StartsWithMatcher}
{\xe \v Catch::Matchers::StdString::StartsWithMatcher\:StartsWithMatcher}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Matchers::StdString::StartsWithMatcher::StartsWithMatcher ({\b CasedString} const &  {\i comparator})}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v match\:Catch::Matchers::StdString::StartsWithMatcher}
{\xe \v Catch::Matchers::StdString::StartsWithMatcher\:match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Matchers::StdString::StartsWithMatcher::match (std::string const &  {\i source}) const{\f2 [override]}}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StreamEndStop\par \pard\plain 
{\tc\tcl2 \v Catch::StreamEndStop}
{\xe \v Catch::StreamEndStop}
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b operator+} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator+\:Catch::StreamEndStop}
{\xe \v Catch::StreamEndStop\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::StreamEndStop::operator+ () const}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Estrutura Catch::StringMaker< T, typename >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< T, typename >}
{\xe \v Catch::StringMaker< T, typename >}
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Fake  = T> static std::enable_if<{\b ::Catch::Detail::IsStreamInsertable}< Fake >::value, std::string >::type {\b convert} (const Fake &value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Fake  = T> static std::enable_if<!{\b ::Catch::Detail::IsStreamInsertable}< Fake >::value, std::string >::type {\b convert} (const Fake &value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< T, typename >}
{\xe \v Catch::StringMaker< T, typename >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = void> template<typename Fake  = T> static std::enable_if<{\b ::Catch::Detail::IsStreamInsertable}< Fake >::value, std::string >::type {\b Catch::StringMaker}< T, typename >::convert (const Fake &  {\i value}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 794                                        \{\par
795                 ReusableStringStream rss;\par
796                 rss << value;\par
797                 {\cf19 return} rss.str();\par
798         \}\par
}
}
{\xe \v convert\:Catch::StringMaker< T, typename >}
{\xe \v Catch::StringMaker< T, typename >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = void> template<typename Fake  = T> static std::enable_if<!{\b ::Catch::Detail::IsStreamInsertable}< Fake >::value, std::string >::type {\b Catch::StringMaker}< T, typename >::convert (const Fake &  {\i value}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 803                                          \{\par
804                 {\cf19 return} Detail::convertUnstreamable( value );\par
805         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< bool >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< bool >}
{\xe \v Catch::StringMaker< bool >}
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (bool b)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< bool >}
{\xe \v Catch::StringMaker< bool >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< bool >::convert (bool  {\i b}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< Catch::Detail::Approx >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< Catch::Detail::Approx >}
{\xe \v Catch::StringMaker< Catch::Detail::Approx >}
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} ({\b Catch::Detail::Approx} const &value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< Catch::Detail::Approx >}
{\xe \v Catch::StringMaker< Catch::Detail::Approx >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< {\b Catch::Detail::Approx} >::convert ({\b Catch::Detail::Approx} const &  {\i value}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< char * >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< char * >}
{\xe \v Catch::StringMaker< char * >}
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (char *str)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< char * >}
{\xe \v Catch::StringMaker< char * >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< char * >::convert (char *  {\i str}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< char >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< char >}
{\xe \v Catch::StringMaker< char >}
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (char c)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< char >}
{\xe \v Catch::StringMaker< char >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< char >::convert (char  {\i c}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< char const * >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< char const * >}
{\xe \v Catch::StringMaker< char const * >}
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (char const *str)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< char const * >}
{\xe \v Catch::StringMaker< char const * >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< char const * >::convert (char const *  {\i str}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Estrutura Catch::StringMaker< char[SZ]>\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< char[SZ]>}
{\xe \v Catch::StringMaker< char[SZ]>}
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (const char *str)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< char[SZ]>}
{\xe \v Catch::StringMaker< char[SZ]>\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<int SZ> static std::string {\b Catch::StringMaker}< char[SZ]>::convert (const char *  {\i str}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 858                                                   \{\par
859             return ::Catch::Detail::stringify(std::string\{ str \});\par
860         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< double >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< double >}
{\xe \v Catch::StringMaker< double >}
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (double value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< double >}
{\xe \v Catch::StringMaker< double >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< double >::convert (double  {\i value}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< float >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< float >}
{\xe \v Catch::StringMaker< float >}
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (float value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< float >}
{\xe \v Catch::StringMaker< float >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< float >::convert (float  {\i value}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< int >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< int >}
{\xe \v Catch::StringMaker< int >}
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (int value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< int >}
{\xe \v Catch::StringMaker< int >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< int >::convert (int  {\i value}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< long >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< long >}
{\xe \v Catch::StringMaker< long >}
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (long value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< long >}
{\xe \v Catch::StringMaker< long >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< long >::convert (long  {\i value}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< long long >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< long long >}
{\xe \v Catch::StringMaker< long long >}
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (long long value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< long long >}
{\xe \v Catch::StringMaker< long long >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< long long >::convert (long long  {\i value}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Estrutura Catch::StringMaker< R C::* >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< R C::* >}
{\xe \v Catch::StringMaker< R C::* >}
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (R C::*p)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< R C::* >}
{\xe \v Catch::StringMaker< R C::* >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename R , typename C > static std::string {\b Catch::StringMaker}< R C::* >::convert (R C::*  {\i p}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 946                                          \{\par
947             {\cf19 if} (p) \{\par
948                 return ::Catch::Detail::rawMemoryToString(p);\par
949             \} {\cf19 else} \{\par
950                 {\cf19 return} {\cf22 "nullptr"};\par
951             \}\par
952         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Estrutura Catch::StringMaker< R, typename std::enable_if< is_range< R >::value &&!::Catch::Detail::IsStreamInsertable< R >::value >::type >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< R, typename std::enable_if< is_range< R >::value &&!::Catch::Detail::IsStreamInsertable< R >::value >::type >}
{\xe \v Catch::StringMaker< R, typename std::enable_if< is_range< R >::value &&!::Catch::Detail::IsStreamInsertable< R >::value >::type >}
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (R const &range)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< R, typename std::enable_if< is_range< R >::value &&!::Catch::Detail::IsStreamInsertable< R >::value >::type >}
{\xe \v Catch::StringMaker< R, typename std::enable_if< is_range< R >::value &&!::Catch::Detail::IsStreamInsertable< R >::value >::type >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename R > static std::string {\b Catch::StringMaker}< R, typename std::enable_if< {\b is_range}< R >::value &&!{\b ::Catch::Detail::IsStreamInsertable}< R >::value >::type >::convert (R const &  {\i range}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1107                                                    \{\par
1108             {\cf19 return} rangeToString( range );\par
1109         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< signed char >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< signed char >}
{\xe \v Catch::StringMaker< signed char >}
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (signed char c)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< signed char >}
{\xe \v Catch::StringMaker< signed char >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< signed char >::convert (signed char  {\i c}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Estrutura Catch::StringMaker< signed char[SZ]>\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< signed char[SZ]>}
{\xe \v Catch::StringMaker< signed char[SZ]>}
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (const char *str)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< signed char[SZ]>}
{\xe \v Catch::StringMaker< signed char[SZ]>\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<int SZ> static std::string {\b Catch::StringMaker}< signed char[SZ]>::convert (const char *  {\i str}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 864                                                   \{\par
865             return ::Catch::Detail::stringify(std::string\{ str \});\par
866         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< std::nullptr_t >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< std::nullptr_t >}
{\xe \v Catch::StringMaker< std::nullptr_t >}
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (std::nullptr_t)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< std::nullptr_t >}
{\xe \v Catch::StringMaker< std::nullptr_t >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< std::nullptr_t >::convert (std::nullptr_t ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< std::string >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< std::string >}
{\xe \v Catch::StringMaker< std::string >}
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (const std::string &str)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< std::string >}
{\xe \v Catch::StringMaker< std::string >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< std::string >::convert (const std::string &  {\i str}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< std::wstring >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< std::wstring >}
{\xe \v Catch::StringMaker< std::wstring >}
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (const std::wstring &wstr)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< std::wstring >}
{\xe \v Catch::StringMaker< std::wstring >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< std::wstring >::convert (const std::wstring &  {\i wstr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Estrutura Catch::StringMaker< T * >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< T * >}
{\xe \v Catch::StringMaker< T * >}
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > static std::string {\b convert} (U *p)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< T * >}
{\xe \v Catch::StringMaker< T * >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > template<typename U > static std::string {\b Catch::StringMaker}< T * >::convert (U *  {\i p}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 935                                        \{\par
936             {\cf19 if} (p) \{\par
937                 return ::Catch::Detail::rawMemoryToString(p);\par
938             \} {\cf19 else} \{\par
939                 {\cf19 return} {\cf22 "nullptr"};\par
940             \}\par
941         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Estrutura Catch::StringMaker< T[SZ]>\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< T[SZ]>}
{\xe \v Catch::StringMaker< T[SZ]>}
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (T const(&arr)[SZ])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< T[SZ]>}
{\xe \v Catch::StringMaker< T[SZ]>\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , int SZ> static std::string {\b Catch::StringMaker}< T[SZ]>::convert (T const(&)  {\i arr}[SZ]){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1114                                                     \{\par
1115             {\cf19 return} rangeToString(arr);\par
1116         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< unsigned char >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< unsigned char >}
{\xe \v Catch::StringMaker< unsigned char >}
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (unsigned char c)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< unsigned char >}
{\xe \v Catch::StringMaker< unsigned char >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< unsigned char >::convert (unsigned char  {\i c}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Estrutura Catch::StringMaker< unsigned char[SZ]>\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< unsigned char[SZ]>}
{\xe \v Catch::StringMaker< unsigned char[SZ]>}
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (const char *str)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< unsigned char[SZ]>}
{\xe \v Catch::StringMaker< unsigned char[SZ]>\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<int SZ> static std::string {\b Catch::StringMaker}< unsigned char[SZ]>::convert (const char *  {\i str}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 870                                                   \{\par
871             return ::Catch::Detail::stringify(std::string\{ str \});\par
872         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< unsigned int >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< unsigned int >}
{\xe \v Catch::StringMaker< unsigned int >}
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (unsigned int value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< unsigned int >}
{\xe \v Catch::StringMaker< unsigned int >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< unsigned int >::convert (unsigned int  {\i value}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< unsigned long >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< unsigned long >}
{\xe \v Catch::StringMaker< unsigned long >}
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (unsigned long value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< unsigned long >}
{\xe \v Catch::StringMaker< unsigned long >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< unsigned long >::convert (unsigned long  {\i value}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< unsigned long long >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< unsigned long long >}
{\xe \v Catch::StringMaker< unsigned long long >}
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (unsigned long long value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< unsigned long long >}
{\xe \v Catch::StringMaker< unsigned long long >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< unsigned long long >::convert (unsigned long long  {\i value}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< wchar_t * >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< wchar_t * >}
{\xe \v Catch::StringMaker< wchar_t * >}
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (wchar_t *str)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< wchar_t * >}
{\xe \v Catch::StringMaker< wchar_t * >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< wchar_t * >::convert (wchar_t *  {\i str}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< wchar_t const * >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< wchar_t const * >}
{\xe \v Catch::StringMaker< wchar_t const * >}
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (wchar_t const *str)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< wchar_t const * >}
{\xe \v Catch::StringMaker< wchar_t const * >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< wchar_t const * >::convert (wchar_t const *  {\i str}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Matchers::StdString::StringMatcherBase\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::StdString::StringMatcherBase}
{\xe \v Catch::Matchers::StdString::StringMatcherBase}
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::Matchers::StdString::StringMatcherBase:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_matchers_1_1_std_string_1_1_string_matcher_base.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringMatcherBase} (std::string const &operation, {\b CasedString} const &comparator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b describe} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherBase< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAllOf}< T > {\b operator&&} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAnyOf}< T > {\b operator||} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchNotOf}< T > {\b operator!} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ({\b MatcherUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} & {\b operator=} ({\b MatcherUntypedBase} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherMethod< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b match} (T const &arg) const=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CasedString} {\b m_comparator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_operation}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MatcherUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b describe} () const =0\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_cachedToString}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v StringMatcherBase\:Catch::Matchers::StdString::StringMatcherBase}
{\xe \v Catch::Matchers::StdString::StringMatcherBase\:StringMatcherBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Matchers::StdString::StringMatcherBase::StringMatcherBase (std::string const &  {\i operation}, {\b CasedString} const &  {\i comparator})}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v describe\:Catch::Matchers::StdString::StringMatcherBase}
{\xe \v Catch::Matchers::StdString::StringMatcherBase\:describe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::Matchers::StdString::StringMatcherBase::describe () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Matchers::Impl::MatcherUntypedBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_comparator\:Catch::Matchers::StdString::StringMatcherBase}
{\xe \v Catch::Matchers::StdString::StringMatcherBase\:m_comparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CasedString} Catch::Matchers::StdString::StringMatcherBase::m_comparator}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v m_operation\:Catch::Matchers::StdString::StringMatcherBase}
{\xe \v Catch::Matchers::StdString::StringMatcherBase\:m_operation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::Matchers::StdString::StringMatcherBase::m_operation}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::StringRef\par \pard\plain 
{\tc\tcl2 \v Catch::StringRef}
{\xe \v Catch::StringRef}
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b size_type} = std::size_t\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} ({\b StringRef} const &other) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} ({\b StringRef} &&other) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} (char const *rawChars) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} (char const *rawChars, {\b size_type} {\b size}) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} (std::string const &stdString) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~StringRef} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator=} ({\b StringRef} const &other) noexcept -> {\b StringRef} &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator std::string} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} ({\b StringRef} &other) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator==} ({\b StringRef} const &other) const noexcept -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator!=} ({\b StringRef} const &other) const noexcept -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator[]} ({\b size_type} index) const noexcept -> char\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b empty} () const noexcept -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b size} () const noexcept -> {\b size_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b numberOfCharacters} () const noexcept -> {\b size_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b c_str} () const -> char const *\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b substr} ({\b size_type} start, {\b size_type} {\b size}) const noexcept -> {\b StringRef}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b currentData} () const noexcept -> char const *\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringRefTestAccess}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descri\'E7\'E3o detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A non-owning string class (similar to the forthcoming std::string_view) Note that, because a {\b StringRef} may be a substring of another string, it may not be null terminated. {\b c_str()} must return a null terminated string, however, and so the {\b StringRef} will internally take ownership (taking a copy), if necessary. In theory this ownership is not externally visible - but it does mean (substring) StringRefs should not be shared between threads. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das defini\'E7\'F5es de tipos\par
\pard\plain 
{\xe \v size_type\:Catch::StringRef}
{\xe \v Catch::StringRef\:size_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::StringRef::size_type} =  std::size_t}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v StringRef\:Catch::StringRef}
{\xe \v Catch::StringRef\:StringRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::StringRef::StringRef (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 395         :   StringRef( s_empty, 0 )\par
396         \{\}\par
}
}
{\xe \v StringRef\:Catch::StringRef}
{\xe \v Catch::StringRef\:StringRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::StringRef::StringRef ({\b StringRef} const &  {\i other}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 399         :   m_start( other.m_start ),\par
400             m_size( other.m_size )\par
401         \{\}\par
}
}
{\xe \v StringRef\:Catch::StringRef}
{\xe \v Catch::StringRef\:StringRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::StringRef::StringRef ({\b StringRef} &&  {\i other}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 404         :   m_start( other.m_start ),\par
405             m_size( other.m_size ),\par
406             m_data( other.m_data )\par
407         \{\par
408             other.m_data = {\cf17 nullptr};\par
409         \}\par
}
}
{\xe \v StringRef\:Catch::StringRef}
{\xe \v Catch::StringRef\:StringRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::StringRef::StringRef (char const *  {\i rawChars}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v StringRef\:Catch::StringRef}
{\xe \v Catch::StringRef\:StringRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::StringRef::StringRef (char const *  {\i rawChars}, {\b size_type}  {\i size}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 414         :   m_start( rawChars ),\par
415             m_size( size )\par
416         \{\}\par
}
}
{\xe \v StringRef\:Catch::StringRef}
{\xe \v Catch::StringRef\:StringRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::StringRef::StringRef (std::string const &  {\i stdString}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 419         :   m_start( stdString.c_str() ),\par
420             m_size( stdString.size() )\par
421         \{\}\par
}
}
{\xe \v ~StringRef\:Catch::StringRef}
{\xe \v Catch::StringRef\:~StringRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::StringRef::~StringRef (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 423                               \{\par
424             {\cf17 delete}[] m_data;\par
425         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v c_str\:Catch::StringRef}
{\xe \v Catch::StringRef\:c_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::StringRef::c_str () const ->  char const *}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v currentData\:Catch::StringRef}
{\xe \v Catch::StringRef\:currentData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::StringRef::currentData () const ->  char const *{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v empty\:Catch::StringRef}
{\xe \v Catch::StringRef\:empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::StringRef::empty () const -> bool {\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 446                                             \{\par
447             {\cf19 return} m_size == 0;\par
448         \}\par
}
}
{\xe \v numberOfCharacters\:Catch::StringRef}
{\xe \v Catch::StringRef\:numberOfCharacters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::StringRef::numberOfCharacters () const ->  {\b size_type}{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator std::string\:Catch::StringRef}
{\xe \v Catch::StringRef\:operator std::string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::StringRef::operator std::string () const}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator!=\:Catch::StringRef}
{\xe \v Catch::StringRef\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::StringRef::operator!= ({\b StringRef} const &  {\i other}) const ->  bool{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:Catch::StringRef}
{\xe \v Catch::StringRef\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::StringRef::operator= ({\b StringRef} const &  {\i other}) -> {\b StringRef}& {\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 427                                                                           \{\par
428             {\cf17 delete}[] m_data;\par
429             m_data = {\cf17 nullptr};\par
430             m_start = other.m_start;\par
431             m_size = other.m_size;\par
432             {\cf19 return} *{\cf17 this};\par
433         \}\par
}
}
{\xe \v operator==\:Catch::StringRef}
{\xe \v Catch::StringRef\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::StringRef::operator== ({\b StringRef} const &  {\i other}) const ->  bool{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator[]\:Catch::StringRef}
{\xe \v Catch::StringRef\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::StringRef::operator[] ({\b size_type}  {\i index}) const ->  char{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v size\:Catch::StringRef}
{\xe \v Catch::StringRef\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::StringRef::size () const -> {\b size_type} {\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 449                                                 \{\par
450             {\cf19 return} m_size;\par
451         \}\par
}
}
{\xe \v substr\:Catch::StringRef}
{\xe \v Catch::StringRef\:substr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::StringRef::substr ({\b size_type}  {\i start}, {\b size_type}  {\i size}) const ->  {\b StringRef}{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v swap\:Catch::StringRef}
{\xe \v Catch::StringRef\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::StringRef::swap ({\b StringRef} &  {\i other}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v StringRefTestAccess\:Catch::StringRef}
{\xe \v Catch::StringRef\:StringRefTestAccess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend struct StringRefTestAccess{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::TestCase\par \pard\plain 
{\tc\tcl2 \v Catch::TestCase}
{\xe \v Catch::TestCase}
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::TestCase:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_test_case.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestCase} ({\b ITestInvoker} *testCase, {\b TestCaseInfo} &&info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestCase} {\b withName} (std::string const &_newName) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b invoke} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestCaseInfo} const & {\b getTestCaseInfo} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} ({\b TestCase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} ({\b TestCase} const &other) const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::TestCaseInfo}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestCaseInfo} (std::string const &_name, std::string const &_className, std::string const &_description, std::vector< std::string > const &_tags, {\b SourceLineInfo} const &_lineInfo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isHidden} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b throws} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b okToFail} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b expectedToFail} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b tagsAsString} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Tipos P\'FAblicos herdados de {\b Catch::TestCaseInfo}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SpecialProperties} \{ {\b None} = 0
, {\b IsHidden} = 1 << 1
, {\b ShouldFail} = 1 << 2
, {\b MayFail} = 1 << 3
, {\b Throws} = 1 << 4
, {\b NonPortable} = 1 << 5
, {\b Benchmark} = 1 << 6
 \}\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos P\'FAblicos herdados de {\b Catch::TestCaseInfo}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b name}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b className}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b description}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b tags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b lcaseTags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SourceLineInfo} {\b lineInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SpecialProperties} {\b properties}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v TestCase\:Catch::TestCase}
{\xe \v Catch::TestCase\:TestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::TestCase::TestCase ({\b ITestInvoker} *  {\i testCase}, {\b TestCaseInfo} &&  {\i info})}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getTestCaseInfo\:Catch::TestCase}
{\xe \v Catch::TestCase\:getTestCaseInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestCaseInfo} const  & Catch::TestCase::getTestCaseInfo () const}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v invoke\:Catch::TestCase}
{\xe \v Catch::TestCase\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::TestCase::invoke () const}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<\:Catch::TestCase}
{\xe \v Catch::TestCase\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::TestCase::operator< ({\b TestCase} const &  {\i other}) const}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:Catch::TestCase}
{\xe \v Catch::TestCase\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::TestCase::operator== ({\b TestCase} const &  {\i other}) const}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v withName\:Catch::TestCase}
{\xe \v Catch::TestCase\:withName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestCase} Catch::TestCase::withName (std::string const &  {\i _newName}) const}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::TestCaseInfo\par \pard\plain 
{\tc\tcl2 \v Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo}
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::TestCaseInfo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_test_case_info.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SpecialProperties} \{ {\b None} = 0
, {\b IsHidden} = 1 << 1
, {\b ShouldFail} = 1 << 2
, {\b MayFail} = 1 << 3
, {\b Throws} = 1 << 4
, {\b NonPortable} = 1 << 5
, {\b Benchmark} = 1 << 6
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestCaseInfo} (std::string const &_name, std::string const &_className, std::string const &_description, std::vector< std::string > const &_tags, {\b SourceLineInfo} const &_lineInfo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isHidden} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b throws} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b okToFail} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b expectedToFail} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b tagsAsString} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b name}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b className}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b description}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b tags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b lcaseTags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SourceLineInfo} {\b lineInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SpecialProperties} {\b properties}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTags} ({\b TestCaseInfo} &testCaseInfo, std::vector< std::string > {\b tags})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das enumera\'E7\'F5es\par
\pard\plain 
{\xe \v SpecialProperties\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:SpecialProperties}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Catch::TestCaseInfo::SpecialProperties}}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v None\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:None}
{\qr None{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
\cell }{\cell }{\row }
{\xe \v IsHidden\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:IsHidden}
{\qr IsHidden{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
\cell }{\cell }{\row }
{\xe \v ShouldFail\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:ShouldFail}
{\qr ShouldFail{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
\cell }{\cell }{\row }
{\xe \v MayFail\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:MayFail}
{\qr MayFail{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
\cell }{\cell }{\row }
{\xe \v Throws\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:Throws}
{\qr Throws{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
\cell }{\cell }{\row }
{\xe \v NonPortable\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:NonPortable}
{\qr NonPortable{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
\cell }{\cell }{\row }
{\xe \v Benchmark\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:Benchmark}
{\qr Benchmark{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
\cell }{\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2689                               \{\par
2690             None = 0,\par
2691             IsHidden = 1 << 1,\par
2692             ShouldFail = 1 << 2,\par
2693             MayFail = 1 << 3,\par
2694             Throws = 1 << 4,\par
2695             NonPortable = 1 << 5,\par
2696             Benchmark = 1 << 6\par
2697         \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v TestCaseInfo\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:TestCaseInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::TestCaseInfo::TestCaseInfo (std::string const &  {\i _name}, std::string const &  {\i _className}, std::string const &  {\i _description}, std::vector< std::string > const &  {\i _tags}, {\b SourceLineInfo} const &  {\i _lineInfo})}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v expectedToFail\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:expectedToFail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::TestCaseInfo::expectedToFail () const}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v isHidden\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:isHidden}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::TestCaseInfo::isHidden () const}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v okToFail\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:okToFail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::TestCaseInfo::okToFail () const}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tagsAsString\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:tagsAsString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::TestCaseInfo::tagsAsString () const}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v throws\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:throws}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::TestCaseInfo::throws () const}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v setTags\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:setTags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setTags ({\b TestCaseInfo} &  {\i testCaseInfo}, std::vector< std::string >  {\i tags}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v className\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:className}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::TestCaseInfo::className}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v description\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:description}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::TestCaseInfo::description}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lcaseTags\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:lcaseTags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<std::string> Catch::TestCaseInfo::lcaseTags}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lineInfo\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:lineInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SourceLineInfo} Catch::TestCaseInfo::lineInfo}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v name\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::TestCaseInfo::name}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v properties\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:properties}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SpecialProperties} Catch::TestCaseInfo::properties}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tags\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:tags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<std::string> Catch::TestCaseInfo::tags}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::TestFailureException\par \pard\plain 
{\tc\tcl2 \v Catch::TestFailureException}
{\xe \v Catch::TestFailureException}
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
\par
{
{\f2 #include <catch.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Classe Catch::TestInvokerAsMethod< C >\par \pard\plain 
{\tc\tcl2 \v Catch::TestInvokerAsMethod< C >}
{\xe \v Catch::TestInvokerAsMethod< C >}
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::TestInvokerAsMethod< C >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_test_invoker_as_method.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestInvokerAsMethod} (void(C::*testAsMethod)()) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b invoke} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::ITestInvoker}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b invoke} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ITestInvoker} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v TestInvokerAsMethod\:Catch::TestInvokerAsMethod< C >}
{\xe \v Catch::TestInvokerAsMethod< C >\:TestInvokerAsMethod}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C > {\b Catch::TestInvokerAsMethod}< C >::TestInvokerAsMethod (void(C::*)()  {\i testAsMethod}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 488 : m_testAsMethod( testAsMethod ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v invoke\:Catch::TestInvokerAsMethod< C >}
{\xe \v Catch::TestInvokerAsMethod< C >\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C > void {\b Catch::TestInvokerAsMethod}< C >::invoke () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::ITestInvoker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAALY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 490                                  \{\par
491         C obj;\par
492         (obj.*m_testAsMethod)();\par
493     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Timer\par \pard\plain 
{\tc\tcl2 \v Catch::Timer}
{\xe \v Catch::Timer}
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b start} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b getElapsedNanoseconds} () const -> uint64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b getElapsedMicroseconds} () const -> uint64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b getElapsedMilliseconds} () const -> unsigned int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b getElapsedSeconds} () const -> double\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getElapsedMicroseconds\:Catch::Timer}
{\xe \v Catch::Timer\:getElapsedMicroseconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Timer::getElapsedMicroseconds () const ->  uint64_t}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getElapsedMilliseconds\:Catch::Timer}
{\xe \v Catch::Timer\:getElapsedMilliseconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Timer::getElapsedMilliseconds () const ->  unsigned int}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getElapsedNanoseconds\:Catch::Timer}
{\xe \v Catch::Timer\:getElapsedNanoseconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Timer::getElapsedNanoseconds () const ->  uint64_t}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getElapsedSeconds\:Catch::Timer}
{\xe \v Catch::Timer\:getElapsedSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Timer::getElapsedSeconds () const ->  double}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v start\:Catch::Timer}
{\xe \v Catch::Timer\:start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::Timer::start ()}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Totals\par \pard\plain 
{\tc\tcl2 \v Catch::Totals}
{\xe \v Catch::Totals}
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
\par
{
{\f2 #include <catch.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Totals} {\b operator-} ({\b Totals} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Totals} & {\b operator+=} ({\b Totals} const &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Totals} {\b delta} ({\b Totals} const &prevTotals) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b error} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Counts} {\b assertions}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Counts} {\b testCases}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v delta\:Catch::Totals}
{\xe \v Catch::Totals\:delta}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Totals} Catch::Totals::delta ({\b Totals} const &  {\i prevTotals}) const}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator+=\:Catch::Totals}
{\xe \v Catch::Totals\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Totals} & Catch::Totals::operator+= ({\b Totals} const &  {\i other})}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator-\:Catch::Totals}
{\xe \v Catch::Totals\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Totals} Catch::Totals::operator- ({\b Totals} const &  {\i other}) const}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v assertions\:Catch::Totals}
{\xe \v Catch::Totals\:assertions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Counts} Catch::Totals::assertions}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v error\:Catch::Totals}
{\xe \v Catch::Totals\:error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Catch::Totals::error = 0}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v testCases\:Catch::Totals}
{\xe \v Catch::Totals\:testCases}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Counts} Catch::Totals::testCases}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Classe Catch::UnaryExpr< LhsT >\par \pard\plain 
{\tc\tcl2 \v Catch::UnaryExpr< LhsT >}
{\xe \v Catch::UnaryExpr< LhsT >}
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::UnaryExpr< LhsT >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_unary_expr.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UnaryExpr} (LhsT lhs)\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::ITransientExpression}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b isBinaryExpression} () const -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b getResult} () const -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b streamReconstructedExpression} (std::ostream &os) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ITransientExpression} (bool {\b isBinaryExpression}, bool result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ITransientExpression} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos P\'FAblicos herdados de {\b Catch::ITransientExpression}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_isBinaryExpression}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_result}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v UnaryExpr\:Catch::UnaryExpr< LhsT >}
{\xe \v Catch::UnaryExpr< LhsT >\:UnaryExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT > {\b Catch::UnaryExpr}< LhsT >::UnaryExpr (LhsT  {\i lhs}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1306         :   ITransientExpression\{ {\cf17 false}, lhs ? true : {\cf17 false} \},\par
1307             m_lhs( lhs )\par
1308         \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do <em>Template</em> da Estrutura Catch::Matchers::Vector::UnorderedEqualsMatcher< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::Vector::UnorderedEqualsMatcher< T >}
{\xe \v Catch::Matchers::Vector::UnorderedEqualsMatcher< T >}
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::Matchers::Vector::UnorderedEqualsMatcher< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_matchers_1_1_vector_1_1_unordered_equals_matcher.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UnorderedEqualsMatcher} (std::vector< T > const &target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b match} (std::vector< T > const &vec) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b describe} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherBase< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAllOf}< T > {\b operator&&} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAnyOf}< T > {\b operator||} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchNotOf}< T > {\b operator!} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ({\b MatcherUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} & {\b operator=} ({\b MatcherUntypedBase} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherMethod< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b match} (T const &arg) const=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MatcherUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b describe} () const =0\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_cachedToString}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v UnorderedEqualsMatcher\:Catch::Matchers::Vector::UnorderedEqualsMatcher< T >}
{\xe \v Catch::Matchers::Vector::UnorderedEqualsMatcher< T >\:UnorderedEqualsMatcher}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Matchers::Vector::UnorderedEqualsMatcher}< T >::UnorderedEqualsMatcher (std::vector< T > const &  {\i target}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2535 : m_target(target) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v describe\:Catch::Matchers::Vector::UnorderedEqualsMatcher< T >}
{\xe \v Catch::Matchers::Vector::UnorderedEqualsMatcher< T >\:describe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::string {\b Catch::Matchers::Vector::UnorderedEqualsMatcher}< T >::describe () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Matchers::Impl::MatcherUntypedBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2566                                                 \{\par
2567                 {\cf19 return} {\cf22 "UnorderedEquals: "} + ::Catch::Detail::stringify(m_target);\par
2568             \}\par
}
}
{\xe \v match\:Catch::Matchers::Vector::UnorderedEqualsMatcher< T >}
{\xe \v Catch::Matchers::Vector::UnorderedEqualsMatcher< T >\:match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b Catch::Matchers::Vector::UnorderedEqualsMatcher}< T >::match (std::vector< T > const &  {\i vec}) const{\f2 [inline]}, {\f2 [override]}}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2536                                                                \{\par
2537                 {\cf20 // Note: This is a reimplementation of std::is_permutation,}\par
2538                 {\cf20 //       because I don't want to include <algorithm> inside the common path}\par
2539                 {\cf19 if} (m_target.size() != vec.size()) \{\par
2540                     {\cf19 return} {\cf17 false};\par
2541                 \}\par
2542                 {\cf17 auto} lfirst = m_target.begin(), llast = m_target.end();\par
2543                 {\cf17 auto} rfirst = vec.begin(), rlast = vec.end();\par
2544                 {\cf20 // Cut common prefix to optimize checking of permuted parts}\par
2545                 {\cf19 while} (lfirst != llast && *lfirst != *rfirst) \{\par
2546                     ++lfirst; ++rfirst;\par
2547                 \}\par
2548                 {\cf19 if} (lfirst == llast) \{\par
2549                     {\cf19 return} {\cf17 true};\par
2550                 \}\par
2551 \par
2552                 {\cf19 for} ({\cf17 auto} mid = lfirst; mid != llast; ++mid) \{\par
2553                     {\cf20 // Skip already counted items}\par
2554                     {\cf19 if} (Detail::contains(lfirst, mid, *mid)) \{\par
2555                         {\cf19 continue};\par
2556                     \}\par
2557                     {\cf18 size_t} num_vec = Detail::count(rfirst, rlast, *mid);\par
2558                     {\cf19 if} (num_vec == 0 || Detail::count(lfirst, llast, *mid) != num_vec) \{\par
2559                         {\cf19 return} {\cf17 false};\par
2560                     \}\par
2561                 \}\par
2562 \par
2563                 {\cf19 return} {\cf17 true};\par
2564             \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Matchers::Floating::WithinAbsMatcher\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::Floating::WithinAbsMatcher}
{\xe \v Catch::Matchers::Floating::WithinAbsMatcher}
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::Matchers::Floating::WithinAbsMatcher:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_matchers_1_1_floating_1_1_within_abs_matcher.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WithinAbsMatcher} (double target, double margin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b match} (double const &matchee) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b describe} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherBase< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAllOf}< T > {\b operator&&} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAnyOf}< T > {\b operator||} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchNotOf}< T > {\b operator!} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ({\b MatcherUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} & {\b operator=} ({\b MatcherUntypedBase} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherMethod< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b match} (T const &arg) const=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MatcherUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b describe} () const =0\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_cachedToString}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v WithinAbsMatcher\:Catch::Matchers::Floating::WithinAbsMatcher}
{\xe \v Catch::Matchers::Floating::WithinAbsMatcher\:WithinAbsMatcher}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Matchers::Floating::WithinAbsMatcher::WithinAbsMatcher (double  {\i target}, double  {\i margin})}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v describe\:Catch::Matchers::Floating::WithinAbsMatcher}
{\xe \v Catch::Matchers::Floating::WithinAbsMatcher\:describe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::Matchers::Floating::WithinAbsMatcher::describe () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Matchers::Impl::MatcherUntypedBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v match\:Catch::Matchers::Floating::WithinAbsMatcher}
{\xe \v Catch::Matchers::Floating::WithinAbsMatcher\:match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Matchers::Floating::WithinAbsMatcher::match (double const &  {\i matchee}) const{\f2 [override]}}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Matchers::Floating::WithinUlpsMatcher\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::Floating::WithinUlpsMatcher}
{\xe \v Catch::Matchers::Floating::WithinUlpsMatcher}
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
\par
{
{\f2 #include <catch.hpp>}}\par
Diagrama de hierarquia da classe Catch::Matchers::Floating::WithinUlpsMatcher:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_matchers_1_1_floating_1_1_within_ulps_matcher.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WithinUlpsMatcher} (double target, int ulps, FloatingPointKind baseType)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b match} (double const &matchee) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b describe} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherBase< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAllOf}< T > {\b operator&&} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAnyOf}< T > {\b operator||} ({\b MatcherBase} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchNotOf}< T > {\b operator!} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} ({\b MatcherUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatcherUntypedBase} & {\b operator=} ({\b MatcherUntypedBase} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Matchers::Impl::MatcherMethod< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b match} (T const &arg) const=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MatcherUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b describe} () const =0\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_cachedToString}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v WithinUlpsMatcher\:Catch::Matchers::Floating::WithinUlpsMatcher}
{\xe \v Catch::Matchers::Floating::WithinUlpsMatcher\:WithinUlpsMatcher}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Matchers::Floating::WithinUlpsMatcher::WithinUlpsMatcher (double  {\i target}, int  {\i ulps}, FloatingPointKind  {\i baseType})}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v describe\:Catch::Matchers::Floating::WithinUlpsMatcher}
{\xe \v Catch::Matchers::Floating::WithinUlpsMatcher\:describe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::Matchers::Floating::WithinUlpsMatcher::describe () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Matchers::Impl::MatcherUntypedBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v match\:Catch::Matchers::Floating::WithinUlpsMatcher}
{\xe \v Catch::Matchers::Floating::WithinUlpsMatcher\:match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Matchers::Floating::WithinUlpsMatcher::match (double const &  {\i matchee}) const{\f2 [override]}}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
desafio_8_rainhas/{\b catch.hpp}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Arquivos{\tc \v Arquivos}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo desafio_8_rainhas/catch.hpp\par \pard\plain 
{\tc\tcl2 \v desafio_8_rainhas/catch.hpp}
{\xe \v desafio_8_rainhas/catch.hpp}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iosfwd>}\par
{\f2 #include <string>}\par
{\f2 #include <cstdint>}\par
{\f2 #include <vector>}\par
{\f2 #include <memory>}\par
{\f2 #include <cstddef>}\par
{\f2 #include <type_traits>}\par
{\f2 #include <ostream>}\par
{\f2 #include <exception>}\par
{\f2 #include <stdexcept>}\par
{\f2 #include <cmath>}\par
{\f2 #include <algorithm>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::CaseSensitive}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::NonCopyable}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::SourceLineInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StreamEndStop}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::RegistrarForTagAliases}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ITestInvoker}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ITestCaseRegistry}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::StringRef}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::TestInvokerAsMethod< C >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::NameAndTags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::AutoReg}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ResultWas}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ResultDisposition}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::AssertionInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::IStream}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::ReusableStringStream}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch_global_namespace_dummy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Detail::IsStreamInsertable< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< T, typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< std::string >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< std::wstring >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< char const * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< char * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< wchar_t const * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< wchar_t * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< char[SZ]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< signed char[SZ]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< unsigned char[SZ]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< int >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< long >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< long long >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< unsigned int >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< unsigned long >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< unsigned long long >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< bool >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< char >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< signed char >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< unsigned char >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< std::nullptr_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< float >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< double >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< T * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< R C::* >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::not_this_one}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::is_range< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< R, typename std::enable_if< is_range< R >::value &&!::Catch::Detail::IsStreamInsertable< R >::value >::type >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< T[SZ]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ITransientExpression}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::BinaryExpr< LhsT, RhsT >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::UnaryExpr< LhsT >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::ExprLhs< LhsT >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Decomposer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::IResultCapture}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::TestFailureException}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::LazyExpression}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::AssertionReaction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::AssertionHandler}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::MessageInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::MessageStream}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::MessageBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::ScopedMessage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Counts}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Totals}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::SectionInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::SectionEndInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Timer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Section}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::BenchmarkLooper}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::IRegistryHub}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::IMutableRegistryHub}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::IExceptionTranslator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::IExceptionTranslatorRegistry}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::ExceptionTranslatorRegistrar}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Detail::Approx}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< Catch::Detail::Approx >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::pluralise}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Matchers::Impl::MatcherUntypedBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Matchers::Impl::MatcherMethod< ObjectT >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Matchers::Impl::MatcherMethod< PtrT * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Matchers::Impl::MatcherBase< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Matchers::Impl::MatchAllOf< ArgT >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Matchers::Impl::MatchAnyOf< ArgT >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Matchers::Impl::MatchNotOf< ArgT >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Matchers::Floating::WithinAbsMatcher}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Matchers::Floating::WithinUlpsMatcher}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Matchers::StdString::CasedString}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Matchers::StdString::StringMatcherBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Matchers::StdString::EqualsMatcher}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Matchers::StdString::ContainsMatcher}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Matchers::StdString::StartsWithMatcher}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Matchers::StdString::EndsWithMatcher}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Matchers::StdString::RegexMatcher}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Matchers::Vector::ContainsElementMatcher< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Matchers::Vector::ContainsMatcher< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Matchers::Vector::EqualsMatcher< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Matchers::Vector::UnorderedEqualsMatcher< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::MatchExpr< ArgT, MatcherT >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::TestCaseInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::TestCase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::IRunner}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Detail}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Matchers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Matchers::Impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Matchers::Floating}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Matchers::StdString}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Matchers::Vector}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Matchers::Vector::Detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_VERSION_MAJOR}\~ 2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_VERSION_MINOR}\~ 2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_VERSION_PATCH}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_CONFIG_POSIX_SIGNALS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_CONFIG_COUNTER}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONFIG_COUNTER}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONFIG_POSIX_SIGNALS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONFIG_WCHAR}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_UNIQUE_NAME_LINE2}(name,  line)\~ name##line\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_UNIQUE_NAME_LINE}(name,  line)\~ {\b INTERNAL_CATCH_UNIQUE_NAME_LINE2}( name, line )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_UNIQUE_NAME}(name)\~ {\b INTERNAL_CATCH_UNIQUE_NAME_LINE}( name, __COUNTER__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_LINEINFO}\~     {\b ::Catch::SourceLineInfo}( __FILE__, static_cast<std::size_t>( __LINE__ ) )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REGISTER_TAG_ALIAS}(alias,  spec)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TESTCASE2}(TestName, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TESTCASE}(...)\~         {\b INTERNAL_CATCH_TESTCASE2}( {\b INTERNAL_CATCH_UNIQUE_NAME}( ____C_A_T_C_H____T_E_S_T____ ), __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_METHOD_AS_TEST_CASE}(QualifiedMethod, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEST_CASE_METHOD2}(TestName,  ClassName, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEST_CASE_METHOD}(ClassName, ...)\~         {\b INTERNAL_CATCH_TEST_CASE_METHOD2}( {\b INTERNAL_CATCH_UNIQUE_NAME}( ____C_A_T_C_H____T_E_S_T____ ), ClassName, __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_REGISTER_TESTCASE}(Function, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_STRINGIFY}(...)\~ #__VA_ARGS__\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TRY}\~ try\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_CATCH}(handler)\~ catch(...) \{ handler.handleUnexpectedInflightException(); \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_REACT}(handler)\~ handler.complete();\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEST}(macroName,  resultDisposition, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_IF}(macroName,  resultDisposition, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_ELSE}(macroName,  resultDisposition, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_NO_THROW}(macroName,  resultDisposition, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_THROWS}(macroName,  resultDisposition, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_THROWS_AS}(macroName,  exceptionType,  resultDisposition,  expr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_MSG}(macroName,  messageType,  resultDisposition, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_INFO}(macroName,  log)\~     {\b Catch::ScopedMessage} {\b INTERNAL_CATCH_UNIQUE_NAME}( scopedMessage )( {\b Catch::MessageBuilder}( macroName, {\b CATCH_INTERNAL_LINEINFO}, {\b Catch::ResultWas::Info} ) << log );\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_THROWS_STR_MATCHES}(macroName,  resultDisposition,  matcher, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_SECTION}(...)\~         if( {\b Catch::Section} const& {\b INTERNAL_CATCH_UNIQUE_NAME}( catch_internal_Section ) = {\b Catch::SectionInfo}( {\b CATCH_INTERNAL_LINEINFO}, __VA_ARGS__ ) )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BENCHMARK}(name)\~     for( {\b Catch::BenchmarkLooper} looper( name ); looper; looper.increment() )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TRANSLATE_EXCEPTION2}(translatorName,  signature)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TRANSLATE_EXCEPTION}(signature)\~ {\b INTERNAL_CATCH_TRANSLATE_EXCEPTION2}( {\b INTERNAL_CATCH_UNIQUE_NAME}( catch_internal_ExceptionTranslator ), signature )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CHECK_THAT}(macroName,  matcher,  resultDisposition,  arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_THROWS_MATCHES}(macroName,  exceptionType,  resultDisposition,  matcher, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REQUIRE}(...)\~ {\b INTERNAL_CATCH_TEST}( "REQUIRE", {\b Catch::ResultDisposition::Normal}, __VA_ARGS__  )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REQUIRE_FALSE}(...)\~ {\b INTERNAL_CATCH_TEST}( "REQUIRE_FALSE", {\b Catch::ResultDisposition::Normal} | {\b Catch::ResultDisposition::FalseTest}, __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REQUIRE_THROWS}(...)\~ {\b INTERNAL_CATCH_THROWS}( "REQUIRE_THROWS", {\b Catch::ResultDisposition::Normal}, __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REQUIRE_THROWS_AS}(expr,  exceptionType)\~ {\b INTERNAL_CATCH_THROWS_AS}( "REQUIRE_THROWS_AS", exceptionType, {\b Catch::ResultDisposition::Normal}, expr )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REQUIRE_THROWS_WITH}(expr,  matcher)\~ {\b INTERNAL_CATCH_THROWS_STR_MATCHES}( "REQUIRE_THROWS_WITH", {\b Catch::ResultDisposition::Normal}, matcher, expr )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REQUIRE_THROWS_MATCHES}(expr,  exceptionType,  matcher)\~ {\b INTERNAL_CATCH_THROWS_MATCHES}( "REQUIRE_THROWS_MATCHES", exceptionType, {\b Catch::ResultDisposition::Normal}, matcher, expr )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REQUIRE_NOTHROW}(...)\~ {\b INTERNAL_CATCH_NO_THROW}( "REQUIRE_NOTHROW", {\b Catch::ResultDisposition::Normal}, __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECK}(...)\~ {\b INTERNAL_CATCH_TEST}( "CHECK", {\b Catch::ResultDisposition::ContinueOnFailure}, __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECK_FALSE}(...)\~ {\b INTERNAL_CATCH_TEST}( "CHECK_FALSE", {\b Catch::ResultDisposition::ContinueOnFailure} | {\b Catch::ResultDisposition::FalseTest}, __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECKED_IF}(...)\~ {\b INTERNAL_CATCH_IF}( "CHECKED_IF", {\b Catch::ResultDisposition::ContinueOnFailure}, __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECKED_ELSE}(...)\~ {\b INTERNAL_CATCH_ELSE}( "CHECKED_ELSE", {\b Catch::ResultDisposition::ContinueOnFailure}, __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECK_NOFAIL}(...)\~ {\b INTERNAL_CATCH_TEST}( "CHECK_NOFAIL", {\b Catch::ResultDisposition::ContinueOnFailure} | {\b Catch::ResultDisposition::SuppressFail}, __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECK_THROWS}(...)\~ {\b INTERNAL_CATCH_THROWS}( "CHECK_THROWS", {\b Catch::ResultDisposition::ContinueOnFailure}, __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECK_THROWS_AS}(expr,  exceptionType)\~ {\b INTERNAL_CATCH_THROWS_AS}( "CHECK_THROWS_AS", exceptionType, {\b Catch::ResultDisposition::ContinueOnFailure}, expr )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECK_THROWS_WITH}(expr,  matcher)\~ {\b INTERNAL_CATCH_THROWS_STR_MATCHES}( "CHECK_THROWS_WITH", {\b Catch::ResultDisposition::ContinueOnFailure}, matcher, expr )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECK_THROWS_MATCHES}(expr,  exceptionType,  matcher)\~ {\b INTERNAL_CATCH_THROWS_MATCHES}( "CHECK_THROWS_MATCHES", exceptionType, {\b Catch::ResultDisposition::ContinueOnFailure}, matcher, expr )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECK_NOTHROW}(...)\~ {\b INTERNAL_CATCH_NO_THROW}( "CHECK_NOTHROW", {\b Catch::ResultDisposition::ContinueOnFailure}, __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECK_THAT}(arg,  matcher)\~ {\b INTERNAL_CHECK_THAT}( "CHECK_THAT", matcher, {\b Catch::ResultDisposition::ContinueOnFailure}, arg )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REQUIRE_THAT}(arg,  matcher)\~ {\b INTERNAL_CHECK_THAT}( "REQUIRE_THAT", matcher, {\b Catch::ResultDisposition::Normal}, arg )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INFO}(msg)\~ {\b INTERNAL_CATCH_INFO}( "INFO", msg )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WARN}(msg)\~ {\b INTERNAL_CATCH_MSG}( "WARN", {\b Catch::ResultWas::Warning}, {\b Catch::ResultDisposition::ContinueOnFailure}, msg )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CAPTURE}(msg)\~ {\b INTERNAL_CATCH_INFO}( "CAPTURE", #msg " := " << {\b ::Catch::Detail::stringify}(msg) )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_CASE}(...)\~ {\b INTERNAL_CATCH_TESTCASE}( __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_CASE_METHOD}(className, ...)\~ {\b INTERNAL_CATCH_TEST_CASE_METHOD}( className, __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b METHOD_AS_TEST_CASE}(method, ...)\~ {\b INTERNAL_CATCH_METHOD_AS_TEST_CASE}( method, __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REGISTER_TEST_CASE}(Function, ...)\~ {\b INTERNAL_CATCH_REGISTER_TESTCASE}( Function, __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SECTION}(...)\~ {\b INTERNAL_CATCH_SECTION}( __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FAIL}(...)\~ {\b INTERNAL_CATCH_MSG}( "FAIL", {\b Catch::ResultWas::ExplicitFailure}, {\b Catch::ResultDisposition::Normal}, __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FAIL_CHECK}(...)\~ {\b INTERNAL_CATCH_MSG}( "FAIL_CHECK", {\b Catch::ResultWas::ExplicitFailure}, {\b Catch::ResultDisposition::ContinueOnFailure}, __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SUCCEED}(...)\~ {\b INTERNAL_CATCH_MSG}( "SUCCEED", {\b Catch::ResultWas::Ok}, {\b Catch::ResultDisposition::ContinueOnFailure}, __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ANON_TEST_CASE}()\~ {\b INTERNAL_CATCH_TESTCASE}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_TRANSLATE_EXCEPTION}(signature)\~ {\b INTERNAL_CATCH_TRANSLATE_EXCEPTION}( signature )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SCENARIO}(...)\~ {\b TEST_CASE}( "Scenario: " __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SCENARIO_METHOD}(className, ...)\~ {\b INTERNAL_CATCH_TEST_CASE_METHOD}( className, "Scenario: " __VA_ARGS__ )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GIVEN}(desc)\~ {\b SECTION}( std::string("   Given: ") + desc )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WHEN}(desc)\~ {\b SECTION}( std::string("    When: ") + desc )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AND_WHEN}(desc)\~ {\b SECTION}( std::string("And when: ") + desc )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b THEN}(desc)\~ {\b SECTION}( std::string("    Then: ") + desc )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AND_THEN}(desc)\~ {\b SECTION}( std::string("     And: ") + desc )\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de Tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Catch::ITestCasePtr} = std::shared_ptr< {\b ITestInvoker} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Catch::IReporterFactoryPtr} = std::shared_ptr< IReporterFactory >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Catch::exceptionTranslateFunction} = std::string(*)()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Catch::ExceptionTranslators} = std::vector< std::unique_ptr< {\b IExceptionTranslator} const  > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Catch::StringMatcher} = {\b Matchers::Impl::MatcherBase}< std::string >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b Catch::rngSeed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::operator<<} (std::ostream &os, {\b SourceLineInfo} const &info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > T const & {\b Catch::operator+} (T const &value, {\b StreamEndStop})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::matchTest} ({\b TestCase} const &testCase, TestSpec const &testSpec, IConfig const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b TestCase} > {\b Catch::filterTests} (std::vector< {\b TestCase} > const &testCases, TestSpec const &testSpec, IConfig const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b TestCase} > const & {\b Catch::getAllTestCasesSorted} (IConfig const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b Catch::operator+} ({\b StringRef} const &lhs, {\b StringRef} const &rhs) -> std::string\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b Catch::operator+} ({\b StringRef} const &lhs, char const *rhs) -> std::string\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b Catch::operator+} (char const *lhs, {\b StringRef} const &rhs) -> std::string\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b Catch::operator+=} (std::string &lhs, {\b StringRef} const &sr) -> std::string &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b Catch::operator<<} (std::ostream &os, {\b StringRef} const &sr) -> std::ostream &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b Catch::operator""_sr} (char const *rawChars, std::size_t size) noexcept -> {\b StringRef}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b Catch::makeTestInvoker} (void(*testAsFunction)()) noexcept -> {\b ITestInvoker} *\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C > auto {\b Catch::makeTestInvoker} (void(C::*testAsMethod)()) noexcept -> {\b ITestInvoker} *\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isOk} ({\b ResultWas::OfType} resultType)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isJustInfo} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultDisposition::Flags} {\b Catch::operator|} ({\b ResultDisposition::Flags} lhs, {\b ResultDisposition::Flags} rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::shouldContinueOnFailure} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isFalseTest} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::shouldSuppressFailure} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::cout} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::cerr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::clog} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b Catch::makeStream} ({\b StringRef} const &filename) -> {\b IStream} const *\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &, {\b Catch_global_namespace_dummy})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::Detail::rawMemoryToString} (const void *object, std::size_t size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::string {\b Catch::Detail::rawMemoryToString} (const T &object)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename E > std::string {\b Catch::Detail::convertUnknownEnumToString} (E e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::enable_if<!std::is_enum< T >::value, std::string >::type {\b Catch::Detail::convertUnstreamable} (T const &value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::enable_if< std::is_enum< T >::value, std::string >::type {\b Catch::Detail::convertUnstreamable} (T const &value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::string {\b Catch::Detail::stringify} (const T &e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputIterator > std::string {\b Catch::Detail::rangeToString} (InputIterator first, InputIterator last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Range > std::string {\b Catch::rangeToString} (Range const &range)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Allocator > std::string {\b Catch::rangeToString} (std::vector< bool, Allocator > const &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::formatReconstructedExpression} (std::ostream &os, std::string const &lhs, {\b StringRef} op, std::string const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename LhsT , typename RhsT > auto {\b Catch::compareEqual} (LhsT const &lhs, RhsT const &rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b Catch::compareEqual} (T *const &lhs, int rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b Catch::compareEqual} (T *const &lhs, long rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b Catch::compareEqual} (int lhs, T *const &rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b Catch::compareEqual} (long lhs, T *const &rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename LhsT , typename RhsT > auto {\b Catch::compareNotEqual} (LhsT const &lhs, RhsT &&rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b Catch::compareNotEqual} (T *const &lhs, int rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b Catch::compareNotEqual} (T *const &lhs, long rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b Catch::compareNotEqual} (int lhs, T *const &rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b Catch::compareNotEqual} (long lhs, T *const &rhs) -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::handleExpression} ({\b ITransientExpression} const &expr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b Catch::handleExpression} ({\b ExprLhs}< T > const &expr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IResultCapture} & {\b Catch::getResultCapture} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::handleExceptionMatchExpr} ({\b AssertionHandler} &handler, std::string const &str, {\b StringRef} matcherString)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b Catch::getCurrentNanosecondsSinceEpoch} () -> uint64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b Catch::getEstimatedClockResolution} () -> uint64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IRegistryHub} & {\b Catch::getRegistryHub} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IMutableRegistryHub} & {\b Catch::getMutableRegistryHub} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::cleanUp} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::translateActiveException} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::startsWith} (std::string const &s, std::string const &prefix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::startsWith} (std::string const &s, char prefix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::endsWith} (std::string const &s, std::string const &suffix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::endsWith} (std::string const &s, char suffix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::contains} (std::string const &s, std::string const &infix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::toLowerInPlace} (std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::toLower} (std::string const &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::trim} (std::string const &str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::replaceInPlace} (std::string &str, std::string const &replaceThis, std::string const &withThis)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Floating::WithinUlpsMatcher} {\b Catch::Matchers::WithinULP} (double target, int maxUlpDiff)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Floating::WithinUlpsMatcher} {\b Catch::Matchers::WithinULP} (float target, int maxUlpDiff)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Floating::WithinAbsMatcher} {\b Catch::Matchers::WithinAbs} (double target, double margin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StdString::EqualsMatcher} {\b Catch::Matchers::Equals} (std::string const &str, {\b CaseSensitive::Choice} caseSensitivity={\b CaseSensitive::Yes})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StdString::ContainsMatcher} {\b Catch::Matchers::Contains} (std::string const &str, {\b CaseSensitive::Choice} caseSensitivity={\b CaseSensitive::Yes})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StdString::EndsWithMatcher} {\b Catch::Matchers::EndsWith} (std::string const &str, {\b CaseSensitive::Choice} caseSensitivity={\b CaseSensitive::Yes})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StdString::StartsWithMatcher} {\b Catch::Matchers::StartsWith} (std::string const &str, {\b CaseSensitive::Choice} caseSensitivity={\b CaseSensitive::Yes})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StdString::RegexMatcher} {\b Catch::Matchers::Matches} (std::string const &regex, {\b CaseSensitive::Choice} caseSensitivity={\b CaseSensitive::Yes})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputIterator , typename T > size_t {\b Catch::Matchers::Vector::Detail::count} (InputIterator first, InputIterator last, T const &item)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputIterator , typename T > bool {\b Catch::Matchers::Vector::Detail::contains} (InputIterator first, InputIterator last, T const &item)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b Vector::ContainsMatcher}< T > {\b Catch::Matchers::Contains} (std::vector< T > const &comparator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b Vector::ContainsElementMatcher}< T > {\b Catch::Matchers::VectorContains} (T const &comparator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b Vector::EqualsMatcher}< T > {\b Catch::Matchers::Equals} (std::vector< T > const &comparator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b Vector::UnorderedEqualsMatcher}< T > {\b Catch::Matchers::UnorderedEquals} (std::vector< T > const &target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::handleExceptionMatchExpr} ({\b AssertionHandler} &handler, {\b StringMatcher} const &matcher, {\b StringRef} matcherString)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ArgT , typename MatcherT > auto {\b Catch::makeMatchExpr} (ArgT const &arg, MatcherT const &matcher, {\b StringRef} matcherString) -> {\b MatchExpr}< ArgT, MatcherT >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestCase} {\b Catch::makeTestCase} ({\b ITestInvoker} *testCase, std::string const &className, {\b NameAndTags} const &nameAndTags, {\b SourceLineInfo} const &lineInfo)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Vari\'E1veis\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string {\b Catch::Detail::unprintableString}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b not_this_one} {\b Catch::begin} (...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b not_this_one} {\b Catch::end} (...)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e macros\par
\pard\plain 
{\xe \v AND_THEN\:catch.hpp}
{\xe \v catch.hpp\:AND_THEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AND_THEN( desc)\~ {\b SECTION}( std::string("     And: ") + desc )}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v AND_WHEN\:catch.hpp}
{\xe \v catch.hpp\:AND_WHEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AND_WHEN( desc)\~ {\b SECTION}( std::string("And when: ") + desc )}}
\par
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ANON_TEST_CASE\:catch.hpp}
{\xe \v catch.hpp\:ANON_TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ANON_TEST_CASE()\~ {\b INTERNAL_CATCH_TESTCASE}()}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v BENCHMARK\:catch.hpp}
{\xe \v catch.hpp\:BENCHMARK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BENCHMARK( name)\~     for( {\b Catch::BenchmarkLooper} looper( name ); looper; looper.increment() )}}
\par
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CAPTURE\:catch.hpp}
{\xe \v catch.hpp\:CAPTURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CAPTURE( msg)\~ {\b INTERNAL_CATCH_INFO}( "CAPTURE", #msg " := " << {\b ::Catch::Detail::stringify}(msg) )}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CONFIG_COUNTER\:catch.hpp}
{\xe \v catch.hpp\:CATCH_CONFIG_COUNTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONFIG_COUNTER}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CONFIG_POSIX_SIGNALS\:catch.hpp}
{\xe \v catch.hpp\:CATCH_CONFIG_POSIX_SIGNALS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONFIG_POSIX_SIGNALS}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CONFIG_WCHAR\:catch.hpp}
{\xe \v catch.hpp\:CATCH_CONFIG_WCHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONFIG_WCHAR}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_CONFIG_COUNTER\:catch.hpp}
{\xe \v catch.hpp\:CATCH_INTERNAL_CONFIG_COUNTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_CONFIG_COUNTER}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_CONFIG_POSIX_SIGNALS\:catch.hpp}
{\xe \v catch.hpp\:CATCH_INTERNAL_CONFIG_POSIX_SIGNALS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_CONFIG_POSIX_SIGNALS}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_LINEINFO\:catch.hpp}
{\xe \v catch.hpp\:CATCH_INTERNAL_LINEINFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_LINEINFO\~     {\b ::Catch::SourceLineInfo}( __FILE__, static_cast<std::size_t>( __LINE__ ) )}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_STRINGIFY\:catch.hpp}
{\xe \v catch.hpp\:CATCH_INTERNAL_STRINGIFY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_STRINGIFY(  {\i ...})\~ #__VA_ARGS__}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS\:catch.hpp}
{\xe \v catch.hpp\:CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS\:catch.hpp}
{\xe \v catch.hpp\:CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\:catch.hpp}
{\xe \v catch.hpp\:CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS\:catch.hpp}
{\xe \v catch.hpp\:CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_REGISTER_TAG_ALIAS\:catch.hpp}
{\xe \v catch.hpp\:CATCH_REGISTER_TAG_ALIAS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REGISTER_TAG_ALIAS( alias,  spec)}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\par
    namespace\{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); \} \\\par
    CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\par
}
}
{\xe \v CATCH_TRANSLATE_EXCEPTION\:catch.hpp}
{\xe \v catch.hpp\:CATCH_TRANSLATE_EXCEPTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_TRANSLATE_EXCEPTION( signature)\~ {\b INTERNAL_CATCH_TRANSLATE_EXCEPTION}( signature )}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_VERSION_MAJOR\:catch.hpp}
{\xe \v catch.hpp\:CATCH_VERSION_MAJOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_VERSION_MAJOR\~ 2}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_VERSION_MINOR\:catch.hpp}
{\xe \v catch.hpp\:CATCH_VERSION_MINOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_VERSION_MINOR\~ 2}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_VERSION_PATCH\:catch.hpp}
{\xe \v catch.hpp\:CATCH_VERSION_PATCH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_VERSION_PATCH\~ 1}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CHECK\:catch.hpp}
{\xe \v catch.hpp\:CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECK(  {\i ...})\~ {\b INTERNAL_CATCH_TEST}( "CHECK", {\b Catch::ResultDisposition::ContinueOnFailure}, __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CHECK_FALSE\:catch.hpp}
{\xe \v catch.hpp\:CHECK_FALSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECK_FALSE(  {\i ...})\~ {\b INTERNAL_CATCH_TEST}( "CHECK_FALSE", {\b Catch::ResultDisposition::ContinueOnFailure} | {\b Catch::ResultDisposition::FalseTest}, __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CHECK_NOFAIL\:catch.hpp}
{\xe \v catch.hpp\:CHECK_NOFAIL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECK_NOFAIL(  {\i ...})\~ {\b INTERNAL_CATCH_TEST}( "CHECK_NOFAIL", {\b Catch::ResultDisposition::ContinueOnFailure} | {\b Catch::ResultDisposition::SuppressFail}, __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CHECK_NOTHROW\:catch.hpp}
{\xe \v catch.hpp\:CHECK_NOTHROW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECK_NOTHROW(  {\i ...})\~ {\b INTERNAL_CATCH_NO_THROW}( "CHECK_NOTHROW", {\b Catch::ResultDisposition::ContinueOnFailure}, __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CHECK_THAT\:catch.hpp}
{\xe \v catch.hpp\:CHECK_THAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECK_THAT( arg,  matcher)\~ {\b INTERNAL_CHECK_THAT}( "CHECK_THAT", matcher, {\b Catch::ResultDisposition::ContinueOnFailure}, arg )}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CHECK_THROWS\:catch.hpp}
{\xe \v catch.hpp\:CHECK_THROWS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECK_THROWS(  {\i ...})\~ {\b INTERNAL_CATCH_THROWS}( "CHECK_THROWS", {\b Catch::ResultDisposition::ContinueOnFailure}, __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CHECK_THROWS_AS\:catch.hpp}
{\xe \v catch.hpp\:CHECK_THROWS_AS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECK_THROWS_AS( expr,  exceptionType)\~ {\b INTERNAL_CATCH_THROWS_AS}( "CHECK_THROWS_AS", exceptionType, {\b Catch::ResultDisposition::ContinueOnFailure}, expr )}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CHECK_THROWS_MATCHES\:catch.hpp}
{\xe \v catch.hpp\:CHECK_THROWS_MATCHES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECK_THROWS_MATCHES( expr,  exceptionType,  matcher)\~ {\b INTERNAL_CATCH_THROWS_MATCHES}( "CHECK_THROWS_MATCHES", exceptionType, {\b Catch::ResultDisposition::ContinueOnFailure}, matcher, expr )}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CHECK_THROWS_WITH\:catch.hpp}
{\xe \v catch.hpp\:CHECK_THROWS_WITH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECK_THROWS_WITH( expr,  matcher)\~ {\b INTERNAL_CATCH_THROWS_STR_MATCHES}( "CHECK_THROWS_WITH", {\b Catch::ResultDisposition::ContinueOnFailure}, matcher, expr )}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CHECKED_ELSE\:catch.hpp}
{\xe \v catch.hpp\:CHECKED_ELSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECKED_ELSE(  {\i ...})\~ {\b INTERNAL_CATCH_ELSE}( "CHECKED_ELSE", {\b Catch::ResultDisposition::ContinueOnFailure}, __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CHECKED_IF\:catch.hpp}
{\xe \v catch.hpp\:CHECKED_IF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECKED_IF(  {\i ...})\~ {\b INTERNAL_CATCH_IF}( "CHECKED_IF", {\b Catch::ResultDisposition::ContinueOnFailure}, __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v FAIL\:catch.hpp}
{\xe \v catch.hpp\:FAIL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FAIL(  {\i ...})\~ {\b INTERNAL_CATCH_MSG}( "FAIL", {\b Catch::ResultWas::ExplicitFailure}, {\b Catch::ResultDisposition::Normal}, __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v FAIL_CHECK\:catch.hpp}
{\xe \v catch.hpp\:FAIL_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FAIL_CHECK(  {\i ...})\~ {\b INTERNAL_CATCH_MSG}( "FAIL_CHECK", {\b Catch::ResultWas::ExplicitFailure}, {\b Catch::ResultDisposition::ContinueOnFailure}, __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GIVEN\:catch.hpp}
{\xe \v catch.hpp\:GIVEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GIVEN( desc)\~ {\b SECTION}( std::string("   Given: ") + desc )}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INFO\:catch.hpp}
{\xe \v catch.hpp\:INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INFO( msg)\~ {\b INTERNAL_CATCH_INFO}( "INFO", msg )}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CATCH_CATCH\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_CATCH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_CATCH( handler)\~ catch(...) \{ handler.handleUnexpectedInflightException(); \}}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CATCH_ELSE\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_ELSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_ELSE( macroName,  resultDisposition,   {\i ...})}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \\\par
    if( !Catch::getResultCapture().lastAssertionPassed() )\par
}
}
{\xe \v INTERNAL_CATCH_IF\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_IF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_IF( macroName,  resultDisposition,   {\i ...})}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \\\par
    if( Catch::getResultCapture().lastAssertionPassed() )\par
}
}
{\xe \v INTERNAL_CATCH_INFO\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_INFO( macroName,  log)\~     {\b Catch::ScopedMessage} {\b INTERNAL_CATCH_UNIQUE_NAME}( scopedMessage )( {\b Catch::MessageBuilder}( macroName, {\b CATCH_INTERNAL_LINEINFO}, {\b Catch::ResultWas::Info} ) << log );}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CATCH_METHOD_AS_TEST_CASE\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_METHOD_AS_TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod,   {\i ...})}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\par
        namespace\{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &QualifiedMethod ), CATCH_INTERNAL_LINEINFO, {\cf22 "&"} #QualifiedMethod, Catch::NameAndTags\{ __VA_ARGS__ \} ); \} {\cf20 /* NOLINT */} \\\par
        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\par
}
}
{\xe \v INTERNAL_CATCH_MSG\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_MSG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_MSG( macroName,  messageType,  resultDisposition,   {\i ...})}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 do} \{ \\\par
        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, {\cf22 ""}, resultDisposition ); \\\par
        catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() << __VA_ARGS__ + ::Catch::StreamEndStop() ).m_stream.str() ); \\\par
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\par
    \} {\cf19 while}( {\cf17 false} )\par
}
}
{\xe \v INTERNAL_CATCH_NO_THROW\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_NO_THROW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_NO_THROW( macroName,  resultDisposition,   {\i ...})}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 do} \{ \\\par
        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \\\par
        {\cf19 try} \{ \\\par
            static_cast<void>(__VA_ARGS__); \\\par
            catchAssertionHandler.handleExceptionNotThrownAsExpected(); \\\par
        \} \\\par
        catch( ... ) \{ \\\par
            catchAssertionHandler.handleUnexpectedInflightException(); \\\par
        \} \\\par
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\par
    \} {\cf19 while}( {\cf17 false} )\par
}
}
{\xe \v INTERNAL_CATCH_REACT\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_REACT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_REACT( handler)\~ handler.complete();}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CATCH_REGISTER_TESTCASE\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_REGISTER_TESTCASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_REGISTER_TESTCASE( Function,   {\i ...})}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\par
        Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH_INTERNAL_LINEINFO, {\cf22 ""}, Catch::NameAndTags\{ __VA_ARGS__ \} ); {\cf20 /* NOLINT */} \\\par
        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\par
}
}
{\xe \v INTERNAL_CATCH_SECTION\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_SECTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_SECTION(  {\i ...})\~         if( {\b Catch::Section} const& {\b INTERNAL_CATCH_UNIQUE_NAME}( catch_internal_Section ) = {\b Catch::SectionInfo}( {\b CATCH_INTERNAL_LINEINFO}, __VA_ARGS__ ) )}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CATCH_TEST\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_TEST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEST( macroName,  resultDisposition,   {\i ...})}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 do} \{ \\\par
        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \\\par
        INTERNAL_CATCH_TRY \{ \\\par
            CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \\\par
            catchAssertionHandler.handleExpr( Catch::Decomposer() <= __VA_ARGS__ ); \\\par
            CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS \\\par
        \} INTERNAL_CATCH_CATCH( catchAssertionHandler ) \\\par
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\par
    \} {\cf19 while}( ({\cf18 void})0, {\cf17 false} && {\cf17 static_cast<}{\cf18 bool}{\cf17 >}( !!(__VA_ARGS__) ) )\par
}
}
{\xe \v INTERNAL_CATCH_TEST_CASE_METHOD\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_TEST_CASE_METHOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName,   {\i ...})\~         {\b INTERNAL_CATCH_TEST_CASE_METHOD2}( {\b INTERNAL_CATCH_UNIQUE_NAME}( ____C_A_T_C_H____T_E_S_T____ ), ClassName, __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CATCH_TEST_CASE_METHOD2\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_TEST_CASE_METHOD2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName,  ClassName,   {\i ...})}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\par
        namespace\{ \\\par
            {\cf17 struct }TestName : ClassName\{ \\\par
                {\cf18 void} test(); \\\par
            \}; \\\par
            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( Catch::makeTestInvoker( &TestName::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags\{ __VA_ARGS__ \} ); {\cf20 /* NOLINT */} \\\par
        \} \\\par
        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\par
        void TestName::test()\par
}
}
{\xe \v INTERNAL_CATCH_TESTCASE\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_TESTCASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TESTCASE(  {\i ...})\~         {\b INTERNAL_CATCH_TESTCASE2}( {\b INTERNAL_CATCH_UNIQUE_NAME}( ____C_A_T_C_H____T_E_S_T____ ), __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CATCH_TESTCASE2\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_TESTCASE2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TESTCASE2( TestName,   {\i ...})}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         {\cf17 static} {\cf18 void} TestName(); \\\par
        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\par
        namespace\{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &TestName ), CATCH_INTERNAL_LINEINFO, {\cf22 ""}, Catch::NameAndTags\{ __VA_ARGS__ \} ); \} {\cf20 /* NOLINT */} \\\par
        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\par
        static {\cf18 void} TestName()\par
}
}
{\xe \v INTERNAL_CATCH_THROWS\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_THROWS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_THROWS( macroName,  resultDisposition,   {\i ...})}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 do} \{ \\\par
        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition); \\\par
        if( catchAssertionHandler.allowThrows() ) \\\par
            {\cf19 try} \{ \\\par
                static_cast<void>(__VA_ARGS__); \\\par
                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\par
            \} \\\par
            catch( ... ) \{ \\\par
                catchAssertionHandler.handleExceptionThrownAsExpected(); \\\par
            \} \\\par
        else \\\par
            catchAssertionHandler.handleThrowingCallSkipped(); \\\par
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\par
    \} {\cf19 while}( {\cf17 false} )\par
}
}
{\xe \v INTERNAL_CATCH_THROWS_AS\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_THROWS_AS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_THROWS_AS( macroName,  exceptionType,  resultDisposition,  expr)}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 do} \{ \\\par
        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr) {\cf22 ", "} CATCH_INTERNAL_STRINGIFY(exceptionType), resultDisposition ); \\\par
        if( catchAssertionHandler.allowThrows() ) \\\par
            {\cf19 try} \{ \\\par
                static_cast<void>(expr); \\\par
                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\par
            \} \\\par
            catch( exceptionType {\cf17 const}& ) \{ \\\par
                catchAssertionHandler.handleExceptionThrownAsExpected(); \\\par
            \} \\\par
            catch( ... ) \{ \\\par
                catchAssertionHandler.handleUnexpectedInflightException(); \\\par
            \} \\\par
        else \\\par
            catchAssertionHandler.handleThrowingCallSkipped(); \\\par
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\par
    \} {\cf19 while}( {\cf17 false} )\par
}
}
{\xe \v INTERNAL_CATCH_THROWS_MATCHES\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_THROWS_MATCHES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_THROWS_MATCHES( macroName,  exceptionType,  resultDisposition,  matcher,   {\i ...})}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 do} \{ \\\par
        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) {\cf22 ", "} CATCH_INTERNAL_STRINGIFY(exceptionType) {\cf22 ", "} CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\\par
        if( catchAssertionHandler.allowThrows() ) \\\par
            {\cf19 try} \{ \\\par
                static_cast<void>(__VA_ARGS__ ); \\\par
                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\par
            \} \\\par
            catch( exceptionType {\cf17 const}& ex ) \{ \\\par
                catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher, #matcher ) ); \\\par
            \} \\\par
            catch( ... ) \{ \\\par
                catchAssertionHandler.handleUnexpectedInflightException(); \\\par
            \} \\\par
        else \\\par
            catchAssertionHandler.handleThrowingCallSkipped(); \\\par
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\par
    \} {\cf19 while}( {\cf17 false} )\par
}
}
{\xe \v INTERNAL_CATCH_THROWS_STR_MATCHES\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_THROWS_STR_MATCHES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_THROWS_STR_MATCHES( macroName,  resultDisposition,  matcher,   {\i ...})}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 do} \{ \\\par
        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) {\cf22 ", "} CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\\par
        if( catchAssertionHandler.allowThrows() ) \\\par
            {\cf19 try} \{ \\\par
                static_cast<void>(__VA_ARGS__); \\\par
                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\par
            \} \\\par
            catch( ... ) \{ \\\par
                Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher, #matcher ); \\\par
            \} \\\par
        else \\\par
            catchAssertionHandler.handleThrowingCallSkipped(); \\\par
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\par
    \} {\cf19 while}( {\cf17 false} )\par
}
}
{\xe \v INTERNAL_CATCH_TRANSLATE_EXCEPTION\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_TRANSLATE_EXCEPTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature)\~ {\b INTERNAL_CATCH_TRANSLATE_EXCEPTION2}( {\b INTERNAL_CATCH_UNIQUE_NAME}( catch_internal_ExceptionTranslator ), signature )}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CATCH_TRANSLATE_EXCEPTION2\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_TRANSLATE_EXCEPTION2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName,  signature)}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 static} std::string translatorName( signature ); \\\par
    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\par
    namespace\{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &translatorName ); \} \\\par
    CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\par
    static std::string translatorName( signature )\par
}
}
{\xe \v INTERNAL_CATCH_TRY\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_TRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TRY\~ try}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CATCH_UNIQUE_NAME\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_UNIQUE_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_UNIQUE_NAME( name)\~ {\b INTERNAL_CATCH_UNIQUE_NAME_LINE}( name, __COUNTER__ )}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CATCH_UNIQUE_NAME_LINE\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_UNIQUE_NAME_LINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_UNIQUE_NAME_LINE( name,  line)\~ {\b INTERNAL_CATCH_UNIQUE_NAME_LINE2}( name, line )}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CATCH_UNIQUE_NAME_LINE2\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CATCH_UNIQUE_NAME_LINE2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name,  line)\~ name##line}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CHECK_THAT\:catch.hpp}
{\xe \v catch.hpp\:INTERNAL_CHECK_THAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CHECK_THAT( macroName,  matcher,  resultDisposition,  arg)}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 do} \{ \\\par
        Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(arg) {\cf22 ", "} CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\\par
        INTERNAL_CATCH_TRY \{ \\\par
            catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher, #matcher ) ); \\\par
        \} INTERNAL_CATCH_CATCH( catchAssertionHandler ) \\\par
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\par
    \} {\cf19 while}( {\cf17 false} )\par
}
}
{\xe \v METHOD_AS_TEST_CASE\:catch.hpp}
{\xe \v catch.hpp\:METHOD_AS_TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define METHOD_AS_TEST_CASE( method,   {\i ...})\~ {\b INTERNAL_CATCH_METHOD_AS_TEST_CASE}( method, __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v REGISTER_TEST_CASE\:catch.hpp}
{\xe \v catch.hpp\:REGISTER_TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REGISTER_TEST_CASE( Function,   {\i ...})\~ {\b INTERNAL_CATCH_REGISTER_TESTCASE}( Function, __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v REQUIRE\:catch.hpp}
{\xe \v catch.hpp\:REQUIRE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REQUIRE(  {\i ...})\~ {\b INTERNAL_CATCH_TEST}( "REQUIRE", {\b Catch::ResultDisposition::Normal}, __VA_ARGS__  )}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v REQUIRE_FALSE\:catch.hpp}
{\xe \v catch.hpp\:REQUIRE_FALSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REQUIRE_FALSE(  {\i ...})\~ {\b INTERNAL_CATCH_TEST}( "REQUIRE_FALSE", {\b Catch::ResultDisposition::Normal} | {\b Catch::ResultDisposition::FalseTest}, __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v REQUIRE_NOTHROW\:catch.hpp}
{\xe \v catch.hpp\:REQUIRE_NOTHROW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REQUIRE_NOTHROW(  {\i ...})\~ {\b INTERNAL_CATCH_NO_THROW}( "REQUIRE_NOTHROW", {\b Catch::ResultDisposition::Normal}, __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v REQUIRE_THAT\:catch.hpp}
{\xe \v catch.hpp\:REQUIRE_THAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REQUIRE_THAT( arg,  matcher)\~ {\b INTERNAL_CHECK_THAT}( "REQUIRE_THAT", matcher, {\b Catch::ResultDisposition::Normal}, arg )}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v REQUIRE_THROWS\:catch.hpp}
{\xe \v catch.hpp\:REQUIRE_THROWS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REQUIRE_THROWS(  {\i ...})\~ {\b INTERNAL_CATCH_THROWS}( "REQUIRE_THROWS", {\b Catch::ResultDisposition::Normal}, __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v REQUIRE_THROWS_AS\:catch.hpp}
{\xe \v catch.hpp\:REQUIRE_THROWS_AS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REQUIRE_THROWS_AS( expr,  exceptionType)\~ {\b INTERNAL_CATCH_THROWS_AS}( "REQUIRE_THROWS_AS", exceptionType, {\b Catch::ResultDisposition::Normal}, expr )}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v REQUIRE_THROWS_MATCHES\:catch.hpp}
{\xe \v catch.hpp\:REQUIRE_THROWS_MATCHES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REQUIRE_THROWS_MATCHES( expr,  exceptionType,  matcher)\~ {\b INTERNAL_CATCH_THROWS_MATCHES}( "REQUIRE_THROWS_MATCHES", exceptionType, {\b Catch::ResultDisposition::Normal}, matcher, expr )}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v REQUIRE_THROWS_WITH\:catch.hpp}
{\xe \v catch.hpp\:REQUIRE_THROWS_WITH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REQUIRE_THROWS_WITH( expr,  matcher)\~ {\b INTERNAL_CATCH_THROWS_STR_MATCHES}( "REQUIRE_THROWS_WITH", {\b Catch::ResultDisposition::Normal}, matcher, expr )}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SCENARIO\:catch.hpp}
{\xe \v catch.hpp\:SCENARIO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SCENARIO(  {\i ...})\~ {\b TEST_CASE}( "Scenario: " __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SCENARIO_METHOD\:catch.hpp}
{\xe \v catch.hpp\:SCENARIO_METHOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SCENARIO_METHOD( className,   {\i ...})\~ {\b INTERNAL_CATCH_TEST_CASE_METHOD}( className, "Scenario: " __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SECTION\:catch.hpp}
{\xe \v catch.hpp\:SECTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SECTION(  {\i ...})\~ {\b INTERNAL_CATCH_SECTION}( __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SUCCEED\:catch.hpp}
{\xe \v catch.hpp\:SUCCEED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SUCCEED(  {\i ...})\~ {\b INTERNAL_CATCH_MSG}( "SUCCEED", {\b Catch::ResultWas::Ok}, {\b Catch::ResultDisposition::ContinueOnFailure}, __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TEST_CASE\:catch.hpp}
{\xe \v catch.hpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_CASE(  {\i ...})\~ {\b INTERNAL_CATCH_TESTCASE}( __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TEST_CASE_METHOD\:catch.hpp}
{\xe \v catch.hpp\:TEST_CASE_METHOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_CASE_METHOD( className,   {\i ...})\~ {\b INTERNAL_CATCH_TEST_CASE_METHOD}( className, __VA_ARGS__ )}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v THEN\:catch.hpp}
{\xe \v catch.hpp\:THEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define THEN( desc)\~ {\b SECTION}( std::string("    Then: ") + desc )}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v WARN\:catch.hpp}
{\xe \v catch.hpp\:WARN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WARN( msg)\~ {\b INTERNAL_CATCH_MSG}( "WARN", {\b Catch::ResultWas::Warning}, {\b Catch::ResultDisposition::ContinueOnFailure}, msg )}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v WHEN\:catch.hpp}
{\xe \v catch.hpp\:WHEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WHEN( desc)\~ {\b SECTION}( std::string("    When: ") + desc )}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator<<\:catch.hpp}
{\xe \v catch.hpp\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream & , {\b Catch_global_namespace_dummy} )}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
catch.hpp\par \pard\plain 
{\tc\tcl2 \v desafio_8_rainhas/catch.hpp}
{\xe \v desafio_8_rainhas/catch.hpp}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Ir para a documenta\'E7\'E3o desse arquivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 /*}\par
2 {\cf20  *  Catch v2.2.1}\par
3 {\cf20  *  Generated: 2018-03-11 12:01:31.654719}\par
4 {\cf20  *  ----------------------------------------------------------}\par
5 {\cf20  *  This file has been merged from multiple headers. Please don't edit it directly}\par
6 {\cf20  *  Copyright (c) 2018 Two Blue Cubes Ltd. All rights reserved.}\par
7 {\cf20  *}\par
8 {\cf20  *  Distributed under the Boost Software License, Version 1.0. (See accompanying}\par
9 {\cf20  *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)}\par
10 {\cf20  */}\par
11 {\cf21 #ifndef TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED}\par
12 {\cf21 #define TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED}\par
13 {\cf20 // start catch.hpp}\par
14 \par
15 \par
16 {\cf21 #define CATCH_VERSION_MAJOR 2}\par
17 {\cf21 #define CATCH_VERSION_MINOR 2}\par
18 {\cf21 #define CATCH_VERSION_PATCH 1}\par
19 \par
20 {\cf21 #ifdef __clang__}\par
21 {\cf21 #    pragma clang system_header}\par
22 {\cf21 #elif defined __GNUC__}\par
23 {\cf21 #    pragma GCC system_header}\par
24 {\cf21 #endif}\par
25 \par
26 {\cf20 // start catch_suppress_warnings.h}\par
27 \par
28 {\cf21 #ifdef __clang__}\par
29 {\cf21 #   ifdef __ICC }{\cf20 // icpc defines the __clang__ macro}\par
30 {\cf21 #       pragma warning(push)}\par
31 {\cf21 #       pragma warning(disable: 161 1682)}\par
32 {\cf21 #   else }{\cf20 // __ICC}\par
33 {\cf21 #       pragma clang diagnostic ignored "-Wunused-variable"}\par
34 {\cf21 #       pragma clang diagnostic push}\par
35 {\cf21 #       pragma clang diagnostic ignored "-Wpadded"}\par
36 {\cf21 #       pragma clang diagnostic ignored "-Wswitch-enum"}\par
37 {\cf21 #       pragma clang diagnostic ignored "-Wcovered-switch-default"}\par
38 {\cf21 #    endif}\par
39 {\cf21 #elif defined __GNUC__}\par
40 {\cf21 #    pragma GCC diagnostic ignored "-Wunused-variable"}\par
41 {\cf21 #    pragma GCC diagnostic ignored "-Wparentheses"}\par
42 {\cf21 #    pragma GCC diagnostic push}\par
43 {\cf21 #    pragma GCC diagnostic ignored "-Wpadded"}\par
44 {\cf21 #endif}\par
45 {\cf20 // end catch_suppress_warnings.h}\par
46 {\cf21 #if defined(CATCH_CONFIG_MAIN) || defined(CATCH_CONFIG_RUNNER)}\par
47 {\cf21 #  define CATCH_IMPL}\par
48 {\cf21 #  define CATCH_CONFIG_ALL_PARTS}\par
49 {\cf21 #endif}\par
50 \par
51 {\cf20 // In the impl file, we want to have access to all parts of the headers}\par
52 {\cf20 // Can also be used to sanely support PCHs}\par
53 {\cf21 #if defined(CATCH_CONFIG_ALL_PARTS)}\par
54 {\cf21 #  define CATCH_CONFIG_EXTERNAL_INTERFACES}\par
55 {\cf21 #  if defined(CATCH_CONFIG_DISABLE_MATCHERS)}\par
56 {\cf21 #    undef CATCH_CONFIG_DISABLE_MATCHERS}\par
57 {\cf21 #  endif}\par
58 {\cf21 #  define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER}\par
59 {\cf21 #endif}\par
60 \par
61 {\cf21 #if !defined(CATCH_CONFIG_IMPL_ONLY)}\par
62 {\cf20 // start catch_platform.h}\par
63 \par
64 {\cf21 #ifdef __APPLE__}\par
65 {\cf21 # include <TargetConditionals.h>}\par
66 {\cf21 # if TARGET_OS_OSX == 1}\par
67 {\cf21 #  define CATCH_PLATFORM_MAC}\par
68 {\cf21 # elif TARGET_OS_IPHONE == 1}\par
69 {\cf21 #  define CATCH_PLATFORM_IPHONE}\par
70 {\cf21 # endif}\par
71 \par
72 {\cf21 #elif defined(linux) || defined(__linux) || defined(__linux__)}\par
73 {\cf21 #  define CATCH_PLATFORM_LINUX}\par
74 \par
75 {\cf21 #elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER)}\par
76 {\cf21 #  define CATCH_PLATFORM_WINDOWS}\par
77 {\cf21 #endif}\par
78 \par
79 {\cf20 // end catch_platform.h}\par
80 \par
81 {\cf21 #ifdef CATCH_IMPL}\par
82 {\cf21 #  ifndef CLARA_CONFIG_MAIN}\par
83 {\cf21 #    define CLARA_CONFIG_MAIN_NOT_DEFINED}\par
84 {\cf21 #    define CLARA_CONFIG_MAIN}\par
85 {\cf21 #  endif}\par
86 {\cf21 #endif}\par
87 \par
88 {\cf20 // start catch_user_interfaces.h}\par
89 \par
90 {\cf17 namespace }Catch \{\par
91     {\cf18 unsigned} {\cf18 int} rngSeed();\par
92 \}\par
93 \par
94 {\cf20 // end catch_user_interfaces.h}\par
95 {\cf20 // start catch_tag_alias_autoregistrar.h}\par
96 \par
97 {\cf20 // start catch_common.h}\par
98 \par
99 {\cf20 // start catch_compiler_capabilities.h}\par
100 \par
101 {\cf20 // Detect a number of compiler features - by compiler}\par
102 {\cf20 // The following features are defined:}\par
103 {\cf20 //}\par
104 {\cf20 // CATCH_CONFIG_COUNTER : is the __COUNTER__ macro supported?}\par
105 {\cf20 // CATCH_CONFIG_WINDOWS_SEH : is Windows SEH supported?}\par
106 {\cf20 // CATCH_CONFIG_POSIX_SIGNALS : are POSIX signals supported?}\par
107 {\cf20 // ****************}\par
108 {\cf20 // Note to maintainers: if new toggles are added please document them}\par
109 {\cf20 // in configuration.md, too}\par
110 {\cf20 // ****************}\par
111 \par
112 {\cf20 // In general each macro has a _NO_<feature name> form}\par
113 {\cf20 // (e.g. CATCH_CONFIG_NO_POSIX_SIGNALS) which disables the feature.}\par
114 {\cf20 // Many features, at point of detection, define an _INTERNAL_ macro, so they}\par
115 {\cf20 // can be combined, en-mass, with the _NO_ forms later.}\par
116 \par
117 {\cf21 #ifdef __cplusplus}\par
118 \par
119 {\cf21 #  if __cplusplus >= 201402L}\par
120 {\cf21 #    define CATCH_CPP14_OR_GREATER}\par
121 {\cf21 #  endif}\par
122 \par
123 {\cf21 #  if __cplusplus >= 201703L}\par
124 {\cf21 #    define CATCH_CPP17_OR_GREATER}\par
125 {\cf21 #  endif}\par
126 \par
127 {\cf21 #endif}\par
128 \par
129 {\cf21 #if defined(CATCH_CPP17_OR_GREATER)}\par
130 {\cf21 #  define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS}\par
131 {\cf21 #endif}\par
132 \par
133 {\cf21 #ifdef __clang__}\par
134 \par
135 {\cf21 #       define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
136 {\cf21             _Pragma( "clang diagnostic push"} ) \\\par
137             _Pragma( "clang diagnostic ignored \\"-Wexit-time-destructors\\"" ) \\\par
138             _Pragma( "clang diagnostic ignored \\"-Wglobal-constructors\\"")\par
139 {\cf21 #       define CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\}\par
140 {\cf21             _Pragma( "clang diagnostic pop"} )\par
141 \par
142 {\cf21 #       define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \\}\par
143 {\cf21             _Pragma( "clang diagnostic push"} ) \\\par
144             _Pragma( "clang diagnostic ignored \\"-Wparentheses\\"" )\par
145 {\cf21 #       define CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS \\}\par
146 {\cf21             _Pragma( "clang diagnostic pop"} )\par
147 \par
148 {\cf21 #endif }{\cf20 // __clang__}\par
149 \par
151 {\cf20 // Assume that non-Windows platforms support posix signals by default}\par
152 {\cf21 #if !defined(CATCH_PLATFORM_WINDOWS)}\par
153 {\cf21     #define CATCH_INTERNAL_CONFIG_POSIX_SIGNALS}\par
154 {\cf21 #endif}\par
155 \par
157 {\cf20 // We know some environments not to support full POSIX signals}\par
158 {\cf21 #if defined(__CYGWIN__) || defined(__QNX__) || defined(__EMSCRIPTEN__) || defined(__DJGPP__)}\par
159 {\cf21     #define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS}\par
160 {\cf21 #endif}\par
161 \par
162 {\cf21 #ifdef __OS400__}\par
163 {\cf21 #       define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS}\par
164 {\cf21 #       define CATCH_CONFIG_COLOUR_NONE}\par
165 {\cf21 #endif}\par
166 \par
168 {\cf20 // Cygwin}\par
169 {\cf21 #ifdef __CYGWIN__}\par
170 \par
171 {\cf20 // Required for some versions of Cygwin to declare gettimeofday}\par
172 {\cf20 // see: http://stackoverflow.com/questions/36901803/gettimeofday-not-declared-in-this-scope-cygwin}\par
173 {\cf21 #   define _BSD_SOURCE}\par
174 \par
175 {\cf21 #endif }{\cf20 // __CYGWIN__}\par
176 \par
178 {\cf20 // Visual C++}\par
179 {\cf21 #ifdef _MSC_VER}\par
180 \par
181 {\cf21 #  if _MSC_VER >= 1900 }{\cf20 // Visual Studio 2015 or newer}\par
182 {\cf21 #    define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS}\par
183 {\cf21 #  endif}\par
184 \par
185 {\cf20 // Universal Windows platform does not support SEH}\par
186 {\cf20 // Or console colours (or console at all...)}\par
187 {\cf21 #  if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)}\par
188 {\cf21 #    define CATCH_CONFIG_COLOUR_NONE}\par
189 {\cf21 #  else}\par
190 {\cf21 #    define CATCH_INTERNAL_CONFIG_WINDOWS_SEH}\par
191 {\cf21 #  endif}\par
192 \par
193 {\cf21 #endif }{\cf20 // _MSC_VER}\par
194 \par
196 \par
197 {\cf20 // DJGPP}\par
198 {\cf21 #ifdef __DJGPP__}\par
199 {\cf21 #  define CATCH_INTERNAL_CONFIG_NO_WCHAR}\par
200 {\cf21 #endif }{\cf20 // __DJGPP__}\par
201 \par
203 \par
204 {\cf20 // Use of __COUNTER__ is suppressed during code analysis in}\par
205 {\cf20 // CLion/AppCode 2017.2.x and former, because __COUNTER__ is not properly}\par
206 {\cf20 // handled by it.}\par
207 {\cf20 // Otherwise all supported compilers support COUNTER macro,}\par
208 {\cf20 // but user still might want to turn it off}\par
209 {\cf21 #if ( !defined(__JETBRAINS_IDE__) || __JETBRAINS_IDE__ >= 20170300L )}\par
210 {\cf21     #define CATCH_INTERNAL_CONFIG_COUNTER}\par
211 {\cf21 #endif}\par
212 \par
213 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_COUNTER) && !defined(CATCH_CONFIG_NO_COUNTER) && !defined(CATCH_CONFIG_COUNTER)}\par
214 {\cf21 #   define CATCH_CONFIG_COUNTER}\par
215 {\cf21 #endif}\par
216 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_WINDOWS_SEH) && !defined(CATCH_CONFIG_NO_WINDOWS_SEH) && !defined(CATCH_CONFIG_WINDOWS_SEH)}\par
217 {\cf21 #   define CATCH_CONFIG_WINDOWS_SEH}\par
218 {\cf21 #endif}\par
219 {\cf20 // This is set by default, because we assume that unix compilers are posix-signal-compatible by default.}\par
220 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_POSIX_SIGNALS) && !defined(CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_POSIX_SIGNALS)}\par
221 {\cf21 #   define CATCH_CONFIG_POSIX_SIGNALS}\par
222 {\cf21 #endif}\par
223 {\cf20 // This is set by default, because we assume that compilers with no wchar_t support are just rare exceptions.}\par
224 {\cf21 #if !defined(CATCH_INTERNAL_CONFIG_NO_WCHAR) && !defined(CATCH_CONFIG_NO_WCHAR) && !defined(CATCH_CONFIG_WCHAR)}\par
225 {\cf21 #   define CATCH_CONFIG_WCHAR}\par
226 {\cf21 #endif}\par
227 \par
228 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS) && !defined(CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS) && !defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)}\par
229 {\cf21 #  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS}\par
230 {\cf21 #endif}\par
231 \par
232 {\cf21 #if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS)}\par
233 {\cf21 #   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS}\par
234 {\cf21 #   define CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS}\par
235 {\cf21 #endif}\par
236 {\cf21 #if !defined(CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS)}\par
237 {\cf21 #   define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS}\par
238 {\cf21 #   define CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS}\par
239 {\cf21 #endif}\par
240 \par
241 {\cf20 // end catch_compiler_capabilities.h}\par
242 {\cf21 #define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line}\par
243 {\cf21 #define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )}\par
244 {\cf21 #ifdef CATCH_CONFIG_COUNTER}\par
245 {\cf21 #  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __COUNTER__ )}\par
246 {\cf21 #else}\par
247 {\cf21 #  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )}\par
248 {\cf21 #endif}\par
249 \par
250 {\cf21 #include <iosfwd>}\par
251 {\cf21 #include <string>}\par
252 {\cf21 #include <cstdint>}\par
253 \par
254 {\cf17 namespace }Catch \{\par
255 \par
256     {\cf17 struct }CaseSensitive \{ {\cf17 enum} Choice \{\par
257         Yes,\par
258         No\par
259     \}; \};\par
260 \par
261     {\cf17 class }NonCopyable \{\par
262         NonCopyable( NonCopyable {\cf17 const}& )              = {\cf17 delete};\par
263         NonCopyable( NonCopyable && )                  = {\cf17 delete};\par
264         NonCopyable& operator = ( NonCopyable {\cf17 const}& ) = {\cf17 delete};\par
265         NonCopyable& operator = ( NonCopyable && )     = {\cf17 delete};\par
266 \par
267     {\cf17 protected}:\par
268         NonCopyable();\par
269         {\cf17 virtual} ~NonCopyable();\par
270     \};\par
271 \par
272     {\cf17 struct }SourceLineInfo \{\par
273 \par
274         SourceLineInfo() = {\cf17 delete};\par
275         SourceLineInfo( {\cf18 char} {\cf17 const}* _file, std::size_t _line ) noexcept\par
276         :   file( _file ),\par
277             line( _line )\par
278         \{\}\par
279 \par
280         SourceLineInfo( SourceLineInfo {\cf17 const}& other )        = {\cf19 default};\par
281         SourceLineInfo( SourceLineInfo && )                  = {\cf19 default};\par
282         SourceLineInfo& operator = ( SourceLineInfo {\cf17 const}& ) = {\cf19 default};\par
283         SourceLineInfo& operator = ( SourceLineInfo && )     = {\cf19 default};\par
284 \par
285         {\cf18 bool} empty() const noexcept;\par
286         {\cf18 bool} operator == ( SourceLineInfo const& other ) const noexcept;\par
287         {\cf18 bool} operator < ( SourceLineInfo const& other ) const noexcept;\par
288 \par
289         {\cf18 char} const* file;\par
290         std::{\cf18 size_t} line;\par
291     \};\par
292 \par
293     std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info );\par
294 \par
295     {\cf20 // Use this in variadic streaming macros to allow}\par
296     {\cf20 //    >> +StreamEndStop}\par
297     {\cf20 // as well as}\par
298     {\cf20 //    >> stuff +StreamEndStop}\par
299     struct StreamEndStop \{\par
300         std::string operator+() {\cf17 const};\par
301     \};\par
302     {\cf17 template}<{\cf17 typename} T>\par
303     T {\cf17 const}& operator + ( T {\cf17 const}& value, StreamEndStop ) \{\par
304         {\cf19 return} value;\par
305     \}\par
306 \}\par
307 \par
308 {\cf21 #define CATCH_INTERNAL_LINEINFO \\}\par
309 {\cf21     ::Catch::SourceLineInfo( __FILE__, static_cast<std::size_t>( __LINE__ ) )}\par
310 \par
311 {\cf20 // end catch_common.h}\par
312 {\cf17 namespace }Catch \{\par
313 \par
314     {\cf17 struct }RegistrarForTagAliases \{\par
315         RegistrarForTagAliases( {\cf18 char} {\cf17 const}* alias, {\cf18 char} {\cf17 const}* tag, SourceLineInfo {\cf17 const}& lineInfo );\par
316     \};\par
317 \par
318 \} {\cf20 // end namespace Catch}\par
319 \par
320 {\cf21 #define CATCH_REGISTER_TAG_ALIAS( alias, spec ) \\}\par
321 {\cf21     CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
322 {\cf21     namespace\{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); \} \\}\par
323 {\cf21     CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS}\par
324 \par
325 {\cf20 // end catch_tag_alias_autoregistrar.h}\par
326 {\cf20 // start catch_test_registry.h}\par
327 \par
328 {\cf20 // start catch_interfaces_testcase.h}\par
329 \par
330 {\cf21 #include <vector>}\par
331 {\cf21 #include <memory>}\par
332 \par
333 {\cf17 namespace }Catch \{\par
334 \par
335     {\cf17 class }TestSpec;\par
336 \par
337     {\cf17 struct }ITestInvoker \{\par
338         {\cf17 virtual} {\cf18 void} invoke () {\cf17 const} = 0;\par
339         {\cf17 virtual} ~ITestInvoker();\par
340     \};\par
341 \par
342     {\cf17 using }ITestCasePtr = std::shared_ptr<ITestInvoker>;\par
343 \par
344     {\cf17 class }TestCase;\par
345     {\cf17 struct }IConfig;\par
346 \par
347     {\cf17 struct }ITestCaseRegistry \{\par
348         {\cf17 virtual} ~ITestCaseRegistry();\par
349         {\cf17 virtual} std::vector<TestCase> {\cf17 const}& getAllTests() {\cf17 const} = 0;\par
350         {\cf17 virtual} std::vector<TestCase> {\cf17 const}& getAllTestsSorted( IConfig {\cf17 const}& config ) {\cf17 const} = 0;\par
351     \};\par
352 \par
353     {\cf18 bool} matchTest( TestCase {\cf17 const}& testCase, TestSpec {\cf17 const}& testSpec, IConfig {\cf17 const}& config );\par
354     std::vector<TestCase> filterTests( std::vector<TestCase> {\cf17 const}& testCases, TestSpec {\cf17 const}& testSpec, IConfig {\cf17 const}& config );\par
355     std::vector<TestCase> {\cf17 const}& getAllTestCasesSorted( IConfig {\cf17 const}& config );\par
356 \par
357 \}\par
358 \par
359 {\cf20 // end catch_interfaces_testcase.h}\par
360 {\cf20 // start catch_stringref.h}\par
361 \par
362 {\cf21 #include <cstddef>}\par
363 {\cf21 #include <string>}\par
364 {\cf21 #include <iosfwd>}\par
365 \par
366 {\cf17 namespace }Catch \{\par
367 \par
368     {\cf17 class }StringData;\par
369 \par
377     {\cf17 class }StringRef \{\par
378     {\cf17 public}:\par
379         {\cf17 using }size_type = std::size_t;\par
380 \par
381     {\cf17 private}:\par
382         {\cf17 friend} {\cf17 struct }StringRefTestAccess;\par
383 \par
384         {\cf18 char} {\cf17 const}* m_start;\par
385         size_type m_size;\par
386 \par
387         {\cf18 char}* m_data = {\cf17 nullptr};\par
388 \par
389         {\cf18 void} takeOwnership();\par
390 \par
391         {\cf17 static} {\cf17 constexpr} {\cf18 char} {\cf17 const}* {\cf17 const} s_empty = {\cf22 ""};\par
392 \par
393     {\cf17 public}: {\cf20 // construction/ assignment}\par
394         StringRef() noexcept\par
395         :   StringRef( s_empty, 0 )\par
396         \{\}\par
397 \par
398         StringRef( StringRef {\cf17 const}& other ) noexcept\par
399         :   m_start( other.m_start ),\par
400             m_size( other.m_size )\par
401         \{\}\par
402 \par
403         StringRef( StringRef&& other ) noexcept\par
404         :   m_start( other.m_start ),\par
405             m_size( other.m_size ),\par
406             m_data( other.m_data )\par
407         \{\par
408             other.m_data = {\cf17 nullptr};\par
409         \}\par
410 \par
411         StringRef( {\cf18 char} {\cf17 const}* rawChars ) {\cf17 noexcept};\par
412 \par
413         StringRef( {\cf18 char} {\cf17 const}* rawChars, size_type size ) noexcept\par
414         :   m_start( rawChars ),\par
415             m_size( size )\par
416         \{\}\par
417 \par
418         StringRef( std::string {\cf17 const}& stdString ) noexcept\par
419         :   m_start( stdString.c_str() ),\par
420             m_size( stdString.size() )\par
421         \{\}\par
422 \par
423         ~StringRef() noexcept \{\par
424             {\cf17 delete}[] m_data;\par
425         \}\par
426 \par
427         {\cf17 auto} operator = ( StringRef {\cf17 const} &other ) {\cf17 noexcept} -> StringRef& \{\par
428             {\cf17 delete}[] m_data;\par
429             m_data = {\cf17 nullptr};\par
430             m_start = other.m_start;\par
431             m_size = other.m_size;\par
432             {\cf19 return} *{\cf17 this};\par
433         \}\par
434 \par
435         {\cf17 operator} std::string() {\cf17 const};\par
436 \par
437         {\cf18 void} swap( StringRef& other ) {\cf17 noexcept};\par
438 \par
439     {\cf17 public}: {\cf20 // operators}\par
440         {\cf17 auto} operator == ( StringRef {\cf17 const}& other ) {\cf17 const} {\cf17 noexcept} -> bool;\par
441         {\cf17 auto} operator != ( StringRef {\cf17 const}& other ) {\cf17 const} {\cf17 noexcept} -> bool;\par
442 \par
443         {\cf17 auto} operator[] ( size_type index ) {\cf17 const} {\cf17 noexcept} -> char;\par
444 \par
445     {\cf17 public}: {\cf20 // named queries}\par
446         {\cf17 auto} empty() const noexcept -> {\cf18 bool} \{\par
447             {\cf19 return} m_size == 0;\par
448         \}\par
449         {\cf17 auto} size() const noexcept -> size_type \{\par
450             {\cf19 return} m_size;\par
451         \}\par
452 \par
453         {\cf17 auto} numberOfCharacters() const noexcept -> size_type;\par
454         auto c_str() const -> {\cf18 char} const*;\par
455 \par
456     public: {\cf20 // substrings and searches}\par
457         auto substr( size_type start, size_type size ) const noexcept -> StringRef;\par
458 \par
459         {\cf20 // Returns the current start pointer.}\par
460         {\cf20 // Note that the pointer can change when if the StringRef is a substring}\par
461         auto currentData() const noexcept -> {\cf18 char} const*;\par
462 \par
463     private: {\cf20 // ownership queries - may not be consistent between calls}\par
464         auto isOwned() const noexcept -> {\cf18 bool};\par
465         auto isSubstring() const noexcept -> {\cf18 bool};\par
466     \};\par
467 \par
468     auto operator + ( StringRef const& lhs, StringRef const& rhs ) -> std::{\cf18 string};\par
469     auto operator + ( StringRef const& lhs, {\cf18 char} const* rhs ) -> std::{\cf18 string};\par
470     auto operator + ( {\cf18 char} const* lhs, StringRef const& rhs ) -> std::{\cf18 string};\par
471 \par
472     auto operator += ( std::{\cf18 string}& lhs, StringRef const& sr ) -> std::{\cf18 string}&;\par
473     auto operator << ( std::ostream& os, StringRef const& sr ) -> std::ostream&;\par
474 \par
475     inline auto operator "" _sr( {\cf18 char} const* rawChars, std::{\cf18 size_t} size ) noexcept -> StringRef \{\par
476         {\cf19 return} StringRef( rawChars, size );\par
477     \}\par
478 \par
479 \} {\cf20 // namespace Catch}\par
480 \par
481 {\cf20 // end catch_stringref.h}\par
482 {\cf17 namespace }Catch \{\par
483 \par
484 {\cf17 template}<{\cf17 typename} C>\par
485 {\cf17 class }TestInvokerAsMethod : {\cf17 public} ITestInvoker \{\par
486     void (C::*m_testAsMethod)();\par
487 {\cf17 public}:\par
488     TestInvokerAsMethod( {\cf18 void} (C::*testAsMethod)() ) noexcept : m_testAsMethod( testAsMethod ) \{\}\par
489 \par
490     {\cf18 void} invoke(){\cf17  const override }\{\par
491         C obj;\par
492         (obj.*m_testAsMethod)();\par
493     \}\par
494 \};\par
495 \par
496 {\cf17 auto} makeTestInvoker( {\cf18 void}(*testAsFunction)() ) noexcept -> ITestInvoker*;\par
497 \par
498 template<typename C>\par
499 auto makeTestInvoker( {\cf18 void} (C::*testAsMethod)() ) noexcept -> ITestInvoker* \{\par
500     {\cf19 return} {\cf17 new}(std::nothrow) TestInvokerAsMethod<C>( testAsMethod );\par
501 \}\par
502 \par
503 {\cf17 struct }NameAndTags \{\par
504     NameAndTags( StringRef {\cf17 const}& name_ = StringRef(), StringRef {\cf17 const}& tags_ = StringRef() ) noexcept;\par
505     StringRef name;\par
506     StringRef tags;\par
507 \};\par
508 \par
509 struct AutoReg : NonCopyable \{\par
510     AutoReg( ITestInvoker* invoker, SourceLineInfo {\cf17 const}& lineInfo, StringRef {\cf17 const}& classOrMethod, NameAndTags {\cf17 const}& nameAndTags ) {\cf17 noexcept};\par
511     ~AutoReg();\par
512 \};\par
513 \par
514 \} {\cf20 // end namespace Catch}\par
515 \par
516 {\cf21 #if defined(CATCH_CONFIG_DISABLE)}\par
517 {\cf21     #define INTERNAL_CATCH_TESTCASE_NO_REGISTRATION( TestName, ... ) \\}\par
518 {\cf21         static void TestName()}\par
519 {\cf21     #define INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION( TestName, ClassName, ... ) \\}\par
520 {\cf21         namespace\{                        \\}\par
521 {\cf21             struct TestName : ClassName \{ \\}\par
522 {\cf21                 void test();              \\}\par
523 {\cf21             \};                            \\}\par
524 {\cf21         \}                                 \\}\par
525 {\cf21         void TestName::test()}\par
526 \par
527 {\cf21 #endif}\par
528 \par
530 {\cf21     #define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \\}\par
531 {\cf21         static void TestName(); \\}\par
532 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
533 {\cf21         namespace\{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &TestName ), CATCH_INTERNAL_LINEINFO, ""}, Catch::NameAndTags\{ __VA_ARGS__ \} ); \} {\cf20 /* NOLINT */}{\cf21  \\}\par
534 {\cf21         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\}\par
535 {\cf21         static void TestName()}\par
536 {\cf21     #define INTERNAL_CATCH_TESTCASE( ... ) \\}\par
537 {\cf21         INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), __VA_ARGS__ )}\par
538 \par
540 {\cf21     #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \\}\par
541 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
542 {\cf21         namespace\{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &QualifiedMethod ), CATCH_INTERNAL_LINEINFO, "&"} #QualifiedMethod, Catch::NameAndTags\{ __VA_ARGS__ \} ); \} {\cf20 /* NOLINT */}{\cf21  \\}\par
543 {\cf21         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS}\par
544 \par
546 {\cf21     #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\\}\par
547 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
548 {\cf21         namespace\{ \\}\par
549 {\cf21             struct TestName : ClassName\{ \\}\par
550 {\cf21                 void test(); \\}\par
551 {\cf21             \}; \\}\par
552 {\cf21             Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( Catch::makeTestInvoker( &TestName::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags\{ __VA_ARGS__ \} ); }{\cf20 /* NOLINT */}{\cf21  \\}\par
553 {\cf21         \} \\}\par
554 {\cf21         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\}\par
555 {\cf21         void TestName::test()}\par
556 {\cf21     #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \\}\par
557 {\cf21         INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, __VA_ARGS__ )}\par
558 \par
560 {\cf21     #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \\}\par
561 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
562 {\cf21         Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH_INTERNAL_LINEINFO, ""}, Catch::NameAndTags\{ __VA_ARGS__ \} ); {\cf20 /* NOLINT */}{\cf21  \\}\par
563 {\cf21         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS}\par
564 \par
565 {\cf20 // end catch_test_registry.h}\par
566 {\cf20 // start catch_capture.hpp}\par
567 \par
568 {\cf20 // start catch_assertionhandler.h}\par
569 \par
570 {\cf20 // start catch_assertioninfo.h}\par
571 \par
572 {\cf20 // start catch_result_type.h}\par
573 \par
574 {\cf17 namespace }Catch \{\par
575 \par
576     {\cf20 // ResultWas::OfType enum}\par
577     {\cf17 struct }ResultWas \{ {\cf17 enum} OfType \{\par
578         Unknown = -1,\par
579         Ok = 0,\par
580         Info = 1,\par
581         Warning = 2,\par
582 \par
583         FailureBit = 0x10,\par
584 \par
585         ExpressionFailed = FailureBit | 1,\par
586         ExplicitFailure = FailureBit | 2,\par
587 \par
588         Exception = 0x100 | FailureBit,\par
589 \par
590         ThrewException = Exception | 1,\par
591         DidntThrowException = Exception | 2,\par
592 \par
593         FatalErrorCondition = 0x200 | FailureBit\par
594 \par
595     \}; \};\par
596 \par
597     {\cf18 bool} isOk( ResultWas::OfType resultType );\par
598     {\cf18 bool} isJustInfo( {\cf18 int} flags );\par
599 \par
600     {\cf20 // ResultDisposition::Flags enum}\par
601     {\cf17 struct }ResultDisposition \{ {\cf17 enum} Flags \{\par
602         Normal = 0x01,\par
603 \par
604         ContinueOnFailure = 0x02,   {\cf20 // Failures fail test, but execution continues}\par
605         FalseTest = 0x04,           {\cf20 // Prefix expression with !}\par
606         SuppressFail = 0x08         {\cf20 // Failures are reported but do not fail the test}\par
607     \}; \};\par
608 \par
609     ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs );\par
610 \par
611     {\cf18 bool} shouldContinueOnFailure( {\cf18 int} flags );\par
612     {\cf17 inline} {\cf18 bool} isFalseTest( {\cf18 int} flags ) \{ {\cf19 return} ( flags & ResultDisposition::FalseTest ) != 0; \}\par
613     {\cf18 bool} shouldSuppressFailure( {\cf18 int} flags );\par
614 \par
615 \} {\cf20 // end namespace Catch}\par
616 \par
617 {\cf20 // end catch_result_type.h}\par
618 {\cf17 namespace }Catch \{\par
619 \par
620     {\cf17 struct }AssertionInfo\par
621     \{\par
622         StringRef macroName;\par
623         SourceLineInfo lineInfo;\par
624         StringRef capturedExpression;\par
625         ResultDisposition::Flags resultDisposition;\par
626 \par
627         {\cf20 // We want to delete this constructor but a compiler bug in 4.8 means}\par
628         {\cf20 // the struct is then treated as non-aggregate}\par
629         {\cf20 //AssertionInfo() = delete;}\par
630     \};\par
631 \par
632 \} {\cf20 // end namespace Catch}\par
633 \par
634 {\cf20 // end catch_assertioninfo.h}\par
635 {\cf20 // start catch_decomposer.h}\par
636 \par
637 {\cf20 // start catch_tostring.h}\par
638 \par
639 {\cf21 #include <vector>}\par
640 {\cf21 #include <cstddef>}\par
641 {\cf21 #include <type_traits>}\par
642 {\cf21 #include <string>}\par
643 {\cf20 // start catch_stream.h}\par
644 \par
645 {\cf21 #include <iosfwd>}\par
646 {\cf21 #include <cstddef>}\par
647 {\cf21 #include <ostream>}\par
648 \par
649 {\cf17 namespace }Catch \{\par
650 \par
651     std::ostream& cout();\par
652     std::ostream& cerr();\par
653     std::ostream& clog();\par
654 \par
655     {\cf17 class }StringRef;\par
656 \par
657     {\cf17 struct }IStream \{\par
658         {\cf17 virtual} ~IStream();\par
659         {\cf17 virtual} std::ostream& stream() {\cf17 const} = 0;\par
660     \};\par
661 \par
662     {\cf17 auto} makeStream( StringRef {\cf17 const} &filename ) -> IStream {\cf17 const}*;\par
663 \par
664     {\cf17 class }ReusableStringStream \{\par
665         std::size_t m_index;\par
666         std::ostream* m_oss;\par
667     {\cf17 public}:\par
668         ReusableStringStream();\par
669         ~ReusableStringStream();\par
670 \par
671         {\cf17 auto} str() const -> std::{\cf18 string};\par
672 \par
673         template<typename T>\par
674         auto operator << ( T const& value ) -> ReusableStringStream& \{\par
675             *m_oss << value;\par
676             {\cf19 return} *{\cf17 this};\par
677         \}\par
678         {\cf17 auto} get() -> std::ostream& \{ {\cf19 return} *m_oss; \}\par
679 \par
680         {\cf17 static} {\cf18 void} cleanup();\par
681     \};\par
682 \}\par
683 \par
684 {\cf20 // end catch_stream.h}\par
685 \par
686 {\cf21 #ifdef __OBJC__}\par
687 {\cf20 // start catch_objc_arc.hpp}\par
688 \par
689 {\cf21 #import <Foundation/Foundation.h>}\par
690 \par
691 {\cf21 #ifdef __has_feature}\par
692 {\cf21 #define CATCH_ARC_ENABLED __has_feature(objc_arc)}\par
693 {\cf21 #else}\par
694 {\cf21 #define CATCH_ARC_ENABLED 0}\par
695 {\cf21 #endif}\par
696 \par
697 {\cf18 void} arcSafeRelease( NSObject* obj );\par
698 {\cf18 id} performOptionalSelector( {\cf18 id} obj, {\cf18 SEL} sel );\par
699 \par
700 {\cf21 #if !CATCH_ARC_ENABLED}\par
701 {\cf17 inline} {\cf18 void} arcSafeRelease( NSObject* obj ) \{\par
702     [obj release];\par
703 \}\par
704 {\cf17 inline} {\cf18 id} performOptionalSelector( {\cf18 id} obj, {\cf18 SEL} sel ) \{\par
705     {\cf19 if}( [obj respondsToSelector: sel] )\par
706         return [obj performSelector: sel];\par
707     {\cf19 return} nil;\par
708 \}\par
709 {\cf21 #define CATCH_UNSAFE_UNRETAINED}\par
710 {\cf21 #define CATCH_ARC_STRONG}\par
711 {\cf21 #else}\par
712 {\cf17 inline} {\cf18 void} arcSafeRelease( NSObject* )\{\}\par
713 {\cf17 inline} {\cf18 id} performOptionalSelector( {\cf18 id} obj, {\cf18 SEL} sel ) \{\par
714 {\cf21 #ifdef __clang__}\par
715 {\cf21 #pragma clang diagnostic push}\par
716 {\cf21 #pragma clang diagnostic ignored "-Warc-performSelector-leaks"}\par
717 {\cf21 #endif}\par
718     {\cf19 if}( [obj respondsToSelector: sel] )\par
719         return [obj performSelector: sel];\par
720 {\cf21 #ifdef __clang__}\par
721 {\cf21 #pragma clang diagnostic pop}\par
722 {\cf21 #endif}\par
723     {\cf19 return} nil;\par
724 \}\par
725 {\cf21 #define CATCH_UNSAFE_UNRETAINED __unsafe_unretained}\par
726 {\cf21 #define CATCH_ARC_STRONG __strong}\par
727 {\cf21 #endif}\par
728 \par
729 {\cf20 // end catch_objc_arc.hpp}\par
730 {\cf21 #endif}\par
731 \par
732 {\cf21 #ifdef _MSC_VER}\par
733 {\cf21 #pragma warning(push)}\par
734 {\cf21 #pragma warning(disable:4180) }{\cf20 // We attempt to stream a function (address) by const&, which MSVC complains about but is harmless}\par
735 {\cf21 #endif}\par
736 \par
737 {\cf20 // We need a dummy global operator<< so we can bring it into Catch namespace later}\par
738 {\cf17 struct }Catch_global_namespace_dummy \{\};\par
739 std::ostream& operator<<(std::ostream&, Catch_global_namespace_dummy);\par
740 \par
741 {\cf17 namespace }Catch \{\par
742     {\cf20 // Bring in operator<< from global namespace into Catch namespace}\par
743     using ::operator<<;\par
744 \par
745     {\cf17 namespace }Detail \{\par
746 \par
747         {\cf17 extern} {\cf17 const} std::string unprintableString;\par
748 \par
749         std::string rawMemoryToString( {\cf17 const} {\cf18 void} *{\cf18 object}, std::size_t size );\par
750 \par
751         {\cf17 template}<{\cf17 typename} T>\par
752         std::string rawMemoryToString( {\cf17 const} T& {\cf18 object} ) \{\par
753           {\cf19 return} rawMemoryToString( &{\cf18 object}, {\cf17 sizeof}({\cf18 object}) );\par
754         \}\par
755 \par
756         {\cf17 template}<{\cf17 typename} T>\par
757         {\cf17 class }IsStreamInsertable \{\par
758             {\cf17 template}<{\cf17 typename} SS, {\cf17 typename} TT>\par
759             {\cf17 static} {\cf17 auto} test({\cf18 int})\par
760                 -> {\cf17 decltype}(std::declval<SS&>() << std::declval<TT>(), std::true_type());\par
761 \par
762             {\cf17 template}<{\cf17 typename}, {\cf17 typename}>\par
763             {\cf17 static} {\cf17 auto} test(...)->std::false_type;\par
764 \par
765         {\cf17 public}:\par
766             {\cf17 static} {\cf17 const} {\cf18 bool} value = {\cf17 decltype}(test<std::ostream, const T&>(0))::value;\par
767         \};\par
768 \par
769         {\cf17 template}<{\cf17 typename} E>\par
770         std::string convertUnknownEnumToString( E e );\par
771 \par
772         {\cf17 template}<{\cf17 typename} T>\par
773         {\cf17 typename} std::enable_if<!std::is_enum<T>::value, std::string>::type convertUnstreamable( T {\cf17 const}& value ) \{\par
774 {\cf21 #if !defined(CATCH_CONFIG_FALLBACK_STRINGIFIER)}\par
775             (void)value;\par
776             {\cf19 return} Detail::unprintableString;\par
777 {\cf21 #else}\par
778             {\cf19 return} CATCH_CONFIG_FALLBACK_STRINGIFIER(value);\par
779 {\cf21 #endif}\par
780         \}\par
781         {\cf17 template}<{\cf17 typename} T>\par
782         {\cf17 typename} std::enable_if<std::is_enum<T>::value, std::string>::type convertUnstreamable( T {\cf17 const}& value ) \{\par
783             {\cf19 return} convertUnknownEnumToString( value );\par
784         \}\par
785 \par
786     \} {\cf20 // namespace Detail}\par
787 \par
788     {\cf20 // If we decide for C++14, change these to enable_if_ts}\par
789     {\cf17 template} <{\cf17 typename} T, {\cf17 typename} = {\cf18 void}>\par
790     {\cf17 struct }StringMaker \{\par
791         {\cf17 template} <{\cf17 typename} Fake = T>\par
792         {\cf17 static}\par
793         {\cf17 typename} std::enable_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type\par
794             convert({\cf17 const} Fake& value) \{\par
795                 ReusableStringStream rss;\par
796                 rss << value;\par
797                 {\cf19 return} rss.str();\par
798         \}\par
799 \par
800         {\cf17 template} <{\cf17 typename} Fake = T>\par
801         {\cf17 static}\par
802         {\cf17 typename} std::enable_if<!::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type\par
803             convert( {\cf17 const} Fake& value ) \{\par
804                 {\cf19 return} Detail::convertUnstreamable( value );\par
805         \}\par
806     \};\par
807 \par
808     {\cf17 namespace }Detail \{\par
809 \par
810         {\cf20 // This function dispatches all stringification requests inside of Catch.}\par
811         {\cf20 // Should be preferably called fully qualified, like ::Catch::Detail::stringify}\par
812         {\cf17 template} <{\cf17 typename} T>\par
813         std::string stringify({\cf17 const} T& e) \{\par
814             return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);\par
815         \}\par
816 \par
817         {\cf17 template}<{\cf17 typename} E>\par
818         std::string convertUnknownEnumToString( E e ) \{\par
819             return ::Catch::Detail::stringify({\cf17 static_cast<}typename std::underlying_type<E>::type{\cf17 >}(e));\par
820         \}\par
821 \par
822     \} {\cf20 // namespace Detail}\par
823 \par
824     {\cf20 // Some predefined specializations}\par
825 \par
826     {\cf17 template}<>\par
827     {\cf17 struct }StringMaker<std::string> \{\par
828         {\cf17 static} std::string convert({\cf17 const} std::string& str);\par
829     \};\par
830 {\cf21 #ifdef CATCH_CONFIG_WCHAR}\par
831     {\cf17 template}<>\par
832     {\cf17 struct }StringMaker<std::wstring> \{\par
833         {\cf17 static} std::string convert({\cf17 const} std::wstring& wstr);\par
834     \};\par
835 {\cf21 #endif}\par
836 \par
837     {\cf17 template}<>\par
838     {\cf17 struct }StringMaker<char const *> \{\par
839         {\cf17 static} std::string convert({\cf18 char} {\cf17 const} * str);\par
840     \};\par
841     {\cf17 template}<>\par
842     {\cf17 struct }StringMaker<char *> \{\par
843         {\cf17 static} std::string convert({\cf18 char} * str);\par
844     \};\par
845 {\cf21 #ifdef CATCH_CONFIG_WCHAR}\par
846     {\cf17 template}<>\par
847     {\cf17 struct }StringMaker<wchar_t const *> \{\par
848         {\cf17 static} std::string convert({\cf18 wchar_t} {\cf17 const} * str);\par
849     \};\par
850     {\cf17 template}<>\par
851     {\cf17 struct }StringMaker<wchar_t *> \{\par
852         {\cf17 static} std::string convert({\cf18 wchar_t} * str);\par
853     \};\par
854 {\cf21 #endif}\par
855 \par
856     {\cf17 template}<{\cf18 int} SZ>\par
857     {\cf17 struct }StringMaker<char[SZ]> \{\par
858         {\cf17 static} std::string convert({\cf17 const} {\cf18 char}* str) \{\par
859             return ::Catch::Detail::stringify(std::string\{ str \});\par
860         \}\par
861     \};\par
862     {\cf17 template}<{\cf18 int} SZ>\par
863     {\cf17 struct }StringMaker<signed char[SZ]> \{\par
864         {\cf17 static} std::string convert({\cf17 const} {\cf18 char}* str) \{\par
865             return ::Catch::Detail::stringify(std::string\{ str \});\par
866         \}\par
867     \};\par
868     {\cf17 template}<{\cf18 int} SZ>\par
869     {\cf17 struct }StringMaker<unsigned char[SZ]> \{\par
870         {\cf17 static} std::string convert({\cf17 const} {\cf18 char}* str) \{\par
871             return ::Catch::Detail::stringify(std::string\{ str \});\par
872         \}\par
873     \};\par
874 \par
875     {\cf17 template}<>\par
876     {\cf17 struct }StringMaker<int> \{\par
877         {\cf17 static} std::string convert({\cf18 int} value);\par
878     \};\par
879     {\cf17 template}<>\par
880     {\cf17 struct }StringMaker<long> \{\par
881         {\cf17 static} std::string convert({\cf18 long} value);\par
882     \};\par
883     {\cf17 template}<>\par
884     {\cf17 struct }StringMaker<long long> \{\par
885         {\cf17 static} std::string convert({\cf18 long} {\cf18 long} value);\par
886     \};\par
887     {\cf17 template}<>\par
888     {\cf17 struct }StringMaker<unsigned int> \{\par
889         {\cf17 static} std::string convert({\cf18 unsigned} {\cf18 int} value);\par
890     \};\par
891     {\cf17 template}<>\par
892     {\cf17 struct }StringMaker<unsigned long> \{\par
893         {\cf17 static} std::string convert({\cf18 unsigned} {\cf18 long} value);\par
894     \};\par
895     {\cf17 template}<>\par
896     {\cf17 struct }StringMaker<unsigned long long> \{\par
897         {\cf17 static} std::string convert({\cf18 unsigned} {\cf18 long} {\cf18 long} value);\par
898     \};\par
899 \par
900     {\cf17 template}<>\par
901     {\cf17 struct }StringMaker<bool> \{\par
902         {\cf17 static} std::string convert({\cf18 bool} b);\par
903     \};\par
904 \par
905     {\cf17 template}<>\par
906     {\cf17 struct }StringMaker<char> \{\par
907         {\cf17 static} std::string convert({\cf18 char} c);\par
908     \};\par
909     {\cf17 template}<>\par
910     {\cf17 struct }StringMaker<signed char> \{\par
911         {\cf17 static} std::string convert({\cf18 signed} {\cf18 char} c);\par
912     \};\par
913     {\cf17 template}<>\par
914     {\cf17 struct }StringMaker<unsigned char> \{\par
915         {\cf17 static} std::string convert({\cf18 unsigned} {\cf18 char} c);\par
916     \};\par
917 \par
918     {\cf17 template}<>\par
919     {\cf17 struct }StringMaker<std::nullptr_t> \{\par
920         {\cf17 static} std::string convert(std::nullptr_t);\par
921     \};\par
922 \par
923     {\cf17 template}<>\par
924     {\cf17 struct }StringMaker<float> \{\par
925         {\cf17 static} std::string convert({\cf18 float} value);\par
926     \};\par
927     {\cf17 template}<>\par
928     {\cf17 struct }StringMaker<double> \{\par
929         {\cf17 static} std::string convert({\cf18 double} value);\par
930     \};\par
931 \par
932     {\cf17 template} <{\cf17 typename} T>\par
933     {\cf17 struct }StringMaker<T*> \{\par
934         {\cf17 template} <{\cf17 typename} U>\par
935         {\cf17 static} std::string convert(U* p) \{\par
936             {\cf19 if} (p) \{\par
937                 return ::Catch::Detail::rawMemoryToString(p);\par
938             \} {\cf19 else} \{\par
939                 {\cf19 return} {\cf22 "nullptr"};\par
940             \}\par
941         \}\par
942     \};\par
943 \par
944     {\cf17 template} <{\cf17 typename} R, {\cf17 typename} C>\par
945     {\cf17 struct }StringMaker<R C::*> \{\par
946         {\cf17 static} std::string convert(R C::* p) \{\par
947             {\cf19 if} (p) \{\par
948                 return ::Catch::Detail::rawMemoryToString(p);\par
949             \} {\cf19 else} \{\par
950                 {\cf19 return} {\cf22 "nullptr"};\par
951             \}\par
952         \}\par
953     \};\par
954 \par
955     {\cf17 namespace }Detail \{\par
956         {\cf17 template}<{\cf17 typename} InputIterator>\par
957         std::string rangeToString(InputIterator first, InputIterator last) \{\par
958             ReusableStringStream rss;\par
959             rss << {\cf22 "\{ "};\par
960             {\cf19 if} (first != last) \{\par
961                 rss << ::Catch::Detail::stringify(*first);\par
962                 {\cf19 for} (++first; first != last; ++first)\par
963                     rss << {\cf22 ", "} << ::Catch::Detail::stringify(*first);\par
964             \}\par
965             rss << {\cf22 " \}"};\par
966             {\cf19 return} rss.str();\par
967         \}\par
968     \}\par
969 \par
970 {\cf21 #ifdef __OBJC__}\par
971     {\cf17 template}<>\par
972     {\cf17 struct }StringMaker<NSString*> \{\par
973         {\cf17 static} std::string convert(NSString * nsstring) \{\par
974             {\cf19 if} (!nsstring)\par
975                 {\cf19 return} {\cf22 "nil"};\par
976             {\cf19 return} std::string({\cf22 "@"}) + [nsstring UTF8String];\par
977         \}\par
978     \};\par
979     {\cf17 template}<>\par
980     {\cf17 struct }StringMaker<NSObject*> \{\par
981         {\cf17 static} std::string convert(NSObject* nsObject) \{\par
982             return ::Catch::Detail::stringify([nsObject description]);\par
983         \}\par
984 \par
985     \};\par
986     {\cf17 namespace }Detail \{\par
987         {\cf17 inline} std::string stringify( NSString* nsstring ) \{\par
988             {\cf19 return} StringMaker<NSString*>::convert( nsstring );\par
989         \}\par
990 \par
991     \} {\cf20 // namespace Detail}\par
992 {\cf21 #endif }{\cf20 // __OBJC__}\par
993 \par
994 \} {\cf20 // namespace Catch}\par
995 \par
997 {\cf20 // Separate std-lib types stringification, so it can be selectively enabled}\par
998 {\cf20 // This means that we do not bring in}\par
999 \par
1000 {\cf21 #if defined(CATCH_CONFIG_ENABLE_ALL_STRINGMAKERS)}\par
1001 {\cf21 #  define CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER}\par
1002 {\cf21 #  define CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER}\par
1003 {\cf21 #  define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER}\par
1004 {\cf21 #endif}\par
1005 \par
1006 {\cf20 // Separate std::pair specialization}\par
1007 {\cf21 #if defined(CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER)}\par
1008 {\cf21 #include <utility>}\par
1009 {\cf17 namespace }Catch \{\par
1010     {\cf17 template}<{\cf17 typename} T1, {\cf17 typename} T2>\par
1011     {\cf17 struct }StringMaker<std::pair<T1, T2> > \{\par
1012         {\cf17 static} std::string convert({\cf17 const} std::pair<T1, T2>& pair) \{\par
1013             ReusableStringStream rss;\par
1014             rss << {\cf22 "\{ "}\par
1015                 << ::Catch::Detail::stringify(pair.first)\par
1016                 << {\cf22 ", "}\par
1017                 << ::Catch::Detail::stringify(pair.second)\par
1018                 << {\cf22 " \}"};\par
1019             {\cf19 return} rss.str();\par
1020         \}\par
1021     \};\par
1022 \}\par
1023 {\cf21 #endif }{\cf20 // CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER}\par
1024 \par
1025 {\cf20 // Separate std::tuple specialization}\par
1026 {\cf21 #if defined(CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER)}\par
1027 {\cf21 #include <tuple>}\par
1028 {\cf17 namespace }Catch \{\par
1029     {\cf17 namespace }Detail \{\par
1030         {\cf17 template}<\par
1031             {\cf17 typename} Tuple,\par
1032             std::size_t N = 0,\par
1033             {\cf18 bool} = (N < std::tuple_size<Tuple>::value)\par
1034             >\par
1035             {\cf17 struct} TupleElementPrinter \{\par
1036             {\cf17 static} {\cf18 void} print({\cf17 const} Tuple& tuple, std::ostream& os) \{\par
1037                 os << (N ? {\cf22 ", "} : {\cf22 " "})\par
1038                     << ::Catch::Detail::stringify(std::get<N>(tuple));\par
1039                 TupleElementPrinter<Tuple, N + 1>::print(tuple, os);\par
1040             \}\par
1041         \};\par
1042 \par
1043         {\cf17 template}<\par
1044             {\cf17 typename} Tuple,\par
1045             std::size_t N\par
1046         >\par
1047             {\cf17 struct }TupleElementPrinter<Tuple, N, false> \{\par
1048             {\cf17 static} {\cf18 void} print({\cf17 const} Tuple&, std::ostream&) \{\}\par
1049         \};\par
1050 \par
1051     \}\par
1052 \par
1053     {\cf17 template}<{\cf17 typename} ...Types>\par
1054     {\cf17 struct }StringMaker<std::tuple<Types...>> \{\par
1055         {\cf17 static} std::string convert({\cf17 const} std::tuple<Types...>& tuple) \{\par
1056             ReusableStringStream rss;\par
1057             rss << {\cf23 '\{'};\par
1058             Detail::TupleElementPrinter<std::tuple<Types...>>::print(tuple, rss.get());\par
1059             rss << {\cf22 " \}"};\par
1060             {\cf19 return} rss.str();\par
1061         \}\par
1062     \};\par
1063 \}\par
1064 {\cf21 #endif }{\cf20 // CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER}\par
1065 \par
1066 {\cf17 namespace }Catch \{\par
1067     {\cf17 struct }not_this_one \{\}; {\cf20 // Tag type for detecting which begin/ end are being selected}\par
1068 \par
1069     {\cf20 // Import begin/ end from std here so they are considered alongside the fallback (...) overloads in this namespace}\par
1070     {\cf17 using }std::begin;\par
1071     {\cf17 using }std::end;\par
1072 \par
1073     not_this_one begin( ... );\par
1074     not_this_one end( ... );\par
1075 \par
1076     {\cf17 template} <{\cf17 typename} T>\par
1077     {\cf17 struct }is_range \{\par
1078         {\cf17 static} {\cf17 const} {\cf18 bool} value =\par
1079             !std::is_same<decltype(begin(std::declval<T>())), not_this_one>::value &&\par
1080             !std::is_same<decltype(end(std::declval<T>())), not_this_one>::value;\par
1081     \};\par
1082 \par
1083     {\cf17 template}<{\cf17 typename} Range>\par
1084     std::string rangeToString( Range {\cf17 const}& range ) \{\par
1085         return ::Catch::Detail::rangeToString( begin( range ), end( range ) );\par
1086     \}\par
1087 \par
1088     {\cf20 // Handle vector<bool> specially}\par
1089     {\cf17 template}<{\cf17 typename} Allocator>\par
1090     std::string rangeToString( std::vector<bool, Allocator> {\cf17 const}& v ) \{\par
1091         ReusableStringStream rss;\par
1092         rss << {\cf22 "\{ "};\par
1093         {\cf18 bool} first = {\cf17 true};\par
1094         {\cf19 for}( {\cf18 bool} b : v ) \{\par
1095             {\cf19 if}( first )\par
1096                 first = {\cf17 false};\par
1097             {\cf19 else}\par
1098                 rss << {\cf22 ", "};\par
1099             rss << ::Catch::Detail::stringify( b );\par
1100         \}\par
1101         rss << {\cf22 " \}"};\par
1102         {\cf19 return} rss.str();\par
1103     \}\par
1104 \par
1105     {\cf17 template}<{\cf17 typename} R>\par
1106     {\cf17 struct }StringMaker<R, typename std::enable_if<is_range<R>::value && !::Catch::Detail::IsStreamInsertable<R>::value>::type> \{\par
1107         {\cf17 static} std::string convert( R {\cf17 const}& range ) \{\par
1108             {\cf19 return} rangeToString( range );\par
1109         \}\par
1110     \};\par
1111 \par
1112     {\cf17 template} <{\cf17 typename} T, {\cf18 int} SZ>\par
1113     {\cf17 struct }StringMaker<T[SZ]> \{\par
1114         {\cf17 static} std::string convert(T {\cf17 const}(&arr)[SZ]) \{\par
1115             {\cf19 return} rangeToString(arr);\par
1116         \}\par
1117     \};\par
1118 \par
1119 \} {\cf20 // namespace Catch}\par
1120 \par
1121 {\cf20 // Separate std::chrono::duration specialization}\par
1122 {\cf21 #if defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)}\par
1123 {\cf21 #include <ctime>}\par
1124 {\cf21 #include <ratio>}\par
1125 {\cf21 #include <chrono>}\par
1126 \par
1127 {\cf17 namespace }Catch \{\par
1128 \par
1129 {\cf17 template} <{\cf17 class} Ratio>\par
1130 {\cf17 struct }ratio_string \{\par
1131     {\cf17 static} std::string symbol();\par
1132 \};\par
1133 \par
1134 {\cf17 template} <{\cf17 class} Ratio>\par
1135 std::string ratio_string<Ratio>::symbol() \{\par
1136     Catch::ReusableStringStream rss;\par
1137     rss << {\cf23 '['} << Ratio::num << {\cf23 '/'}\par
1138         << Ratio::den << {\cf23 ']'};\par
1139     {\cf19 return} rss.str();\par
1140 \}\par
1141 {\cf17 template} <>\par
1142 {\cf17 struct }ratio_string<std::atto> \{\par
1143     {\cf17 static} std::string symbol();\par
1144 \};\par
1145 {\cf17 template} <>\par
1146 {\cf17 struct }ratio_string<std::femto> \{\par
1147     {\cf17 static} std::string symbol();\par
1148 \};\par
1149 {\cf17 template} <>\par
1150 {\cf17 struct }ratio_string<std::pico> \{\par
1151     {\cf17 static} std::string symbol();\par
1152 \};\par
1153 {\cf17 template} <>\par
1154 {\cf17 struct }ratio_string<std::nano> \{\par
1155     {\cf17 static} std::string symbol();\par
1156 \};\par
1157 {\cf17 template} <>\par
1158 {\cf17 struct }ratio_string<std::micro> \{\par
1159     {\cf17 static} std::string symbol();\par
1160 \};\par
1161 {\cf17 template} <>\par
1162 {\cf17 struct }ratio_string<std::milli> \{\par
1163     {\cf17 static} std::string symbol();\par
1164 \};\par
1165 \par
1167     {\cf20 // std::chrono::duration specializations}\par
1168     {\cf17 template}<{\cf17 typename} Value, {\cf17 typename} Ratio>\par
1169     {\cf17 struct }StringMaker<std::chrono::duration<Value, Ratio>> \{\par
1170         {\cf17 static} std::string convert(std::chrono::duration<Value, Ratio> {\cf17 const}& duration) \{\par
1171             ReusableStringStream rss;\par
1172             rss << duration.count() << {\cf23 ' '} << ratio_string<Ratio>::symbol() << {\cf23 's'};\par
1173             {\cf19 return} rss.str();\par
1174         \}\par
1175     \};\par
1176     {\cf17 template}<{\cf17 typename} Value>\par
1177     {\cf17 struct }StringMaker<std::chrono::duration<Value, std::ratio<1>>> \{\par
1178         {\cf17 static} std::string convert(std::chrono::duration<Value, std::ratio<1>> {\cf17 const}& duration) \{\par
1179             ReusableStringStream rss;\par
1180             rss << duration.count() << {\cf22 " s"};\par
1181             {\cf19 return} rss.str();\par
1182         \}\par
1183     \};\par
1184     {\cf17 template}<{\cf17 typename} Value>\par
1185     {\cf17 struct }StringMaker<std::chrono::duration<Value, std::ratio<60>>> \{\par
1186         {\cf17 static} std::string convert(std::chrono::duration<Value, std::ratio<60>> {\cf17 const}& duration) \{\par
1187             ReusableStringStream rss;\par
1188             rss << duration.count() << {\cf22 " m"};\par
1189             {\cf19 return} rss.str();\par
1190         \}\par
1191     \};\par
1192     {\cf17 template}<{\cf17 typename} Value>\par
1193     {\cf17 struct }StringMaker<std::chrono::duration<Value, std::ratio<3600>>> \{\par
1194         {\cf17 static} std::string convert(std::chrono::duration<Value, std::ratio<3600>> {\cf17 const}& duration) \{\par
1195             ReusableStringStream rss;\par
1196             rss << duration.count() << {\cf22 " h"};\par
1197             {\cf19 return} rss.str();\par
1198         \}\par
1199     \};\par
1200 \par
1202     {\cf20 // std::chrono::time_point specialization}\par
1203     {\cf20 // Generic time_point cannot be specialized, only std::chrono::time_point<system_clock>}\par
1204     {\cf17 template}<{\cf17 typename} Clock, {\cf17 typename} Duration>\par
1205     {\cf17 struct }StringMaker<std::chrono::time_point<Clock, Duration>> \{\par
1206         {\cf17 static} std::string convert(std::chrono::time_point<Clock, Duration> {\cf17 const}& time_point) \{\par
1207             return ::Catch::Detail::stringify(time_point.time_since_epoch()) + {\cf22 " since epoch"};\par
1208         \}\par
1209     \};\par
1210     {\cf20 // std::chrono::time_point<system_clock> specialization}\par
1211     {\cf17 template}<{\cf17 typename} Duration>\par
1212     {\cf17 struct }StringMaker<std::chrono::time_point<std::chrono::system_clock, Duration>> \{\par
1213         {\cf17 static} std::string convert(std::chrono::time_point<std::chrono::system_clock, Duration> {\cf17 const}& time_point) \{\par
1214             {\cf17 auto} converted = std::chrono::system_clock::to_time_t(time_point);\par
1215 \par
1216 {\cf21 #ifdef _MSC_VER}\par
1217             std::tm timeInfo = \{\};\par
1218             gmtime_s(&timeInfo, &converted);\par
1219 {\cf21 #else}\par
1220             std::tm* timeInfo = std::gmtime(&converted);\par
1221 {\cf21 #endif}\par
1222 \par
1223             {\cf17 auto} {\cf17 const} timeStampSize = {\cf17 sizeof}({\cf22 "2017-01-16T17:06:45Z"});\par
1224             {\cf18 char} timeStamp[timeStampSize];\par
1225             {\cf17 const} {\cf18 char} * {\cf17 const} fmt = {\cf22 "%Y-%m-%dT%H:%M:%SZ"};\par
1226 \par
1227 {\cf21 #ifdef _MSC_VER}\par
1228             std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);\par
1229 {\cf21 #else}\par
1230             std::strftime(timeStamp, timeStampSize, fmt, timeInfo);\par
1231 {\cf21 #endif}\par
1232             {\cf19 return} std::string(timeStamp);\par
1233         \}\par
1234     \};\par
1235 \}\par
1236 {\cf21 #endif }{\cf20 // CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER}\par
1237 \par
1238 {\cf21 #ifdef _MSC_VER}\par
1239 {\cf21 #pragma warning(pop)}\par
1240 {\cf21 #endif}\par
1241 \par
1242 {\cf20 // end catch_tostring.h}\par
1243 {\cf21 #include <iosfwd>}\par
1244 \par
1245 {\cf21 #ifdef _MSC_VER}\par
1246 {\cf21 #pragma warning(push)}\par
1247 {\cf21 #pragma warning(disable:4389) }{\cf20 // '==' : signed/unsigned mismatch}\par
1248 {\cf21 #pragma warning(disable:4018) }{\cf20 // more "signed/unsigned mismatch"}\par
1249 {\cf21 #pragma warning(disable:4312) }{\cf20 // Converting int to T* using reinterpret_cast (issue on x64 platform)}\par
1250 {\cf21 #pragma warning(disable:4180) }{\cf20 // qualifier applied to function type has no meaning}\par
1251 {\cf21 #endif}\par
1252 \par
1253 {\cf17 namespace }Catch \{\par
1254 \par
1255     {\cf17 struct }ITransientExpression \{\par
1256         {\cf17 auto} isBinaryExpression() const -> {\cf18 bool} \{ {\cf19 return} m_isBinaryExpression; \}\par
1257         {\cf17 auto} getResult() const -> {\cf18 bool} \{ {\cf19 return} m_result; \}\par
1258         {\cf17 virtual} {\cf18 void} streamReconstructedExpression( std::ostream &os ) {\cf17 const} = 0;\par
1259 \par
1260         ITransientExpression( {\cf18 bool} isBinaryExpression, {\cf18 bool} result )\par
1261         :   m_isBinaryExpression( isBinaryExpression ),\par
1262             m_result( result )\par
1263         \{\}\par
1264 \par
1265         {\cf20 // We don't actually need a virtual destructor, but many static analysers}\par
1266         {\cf20 // complain if it's not here :-(}\par
1267         {\cf17 virtual} ~ITransientExpression();\par
1268 \par
1269         {\cf18 bool} m_isBinaryExpression;\par
1270         {\cf18 bool} m_result;\par
1271 \par
1272     \};\par
1273 \par
1274     {\cf18 void} formatReconstructedExpression( std::ostream &os, std::string {\cf17 const}& lhs, StringRef op, std::string {\cf17 const}& rhs );\par
1275 \par
1276     {\cf17 template}<{\cf17 typename} LhsT, {\cf17 typename} RhsT>\par
1277     {\cf17 class }BinaryExpr  : {\cf17 public} ITransientExpression \{\par
1278         LhsT m_lhs;\par
1279         StringRef m_op;\par
1280         RhsT m_rhs;\par
1281 \par
1282         {\cf18 void} streamReconstructedExpression( std::ostream &os ){\cf17  const override }\{\par
1283             formatReconstructedExpression\par
1284                     ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );\par
1285         \}\par
1286 \par
1287     {\cf17 public}:\par
1288         BinaryExpr( {\cf18 bool} comparisonResult, LhsT lhs, StringRef op, RhsT rhs )\par
1289         :   ITransientExpression\{ true, comparisonResult \},\par
1290             m_lhs( lhs ),\par
1291             m_op( op ),\par
1292             m_rhs( rhs )\par
1293         \{\}\par
1294     \};\par
1295 \par
1296     {\cf17 template}<{\cf17 typename} LhsT>\par
1297     {\cf17 class }UnaryExpr : {\cf17 public} ITransientExpression \{\par
1298         LhsT m_lhs;\par
1299 \par
1300         {\cf18 void} streamReconstructedExpression( std::ostream &os ){\cf17  const override }\{\par
1301             os << Catch::Detail::stringify( m_lhs );\par
1302         \}\par
1303 \par
1304     {\cf17 public}:\par
1305         {\cf17 explicit} UnaryExpr( LhsT lhs )\par
1306         :   ITransientExpression\{ false, lhs ? true : false \},\par
1307             m_lhs( lhs )\par
1308         \{\}\par
1309     \};\par
1310 \par
1311     {\cf20 // Specialised comparison functions to handle equality comparisons between ints and pointers (NULL deduces as an int)}\par
1312     {\cf17 template}<{\cf17 typename} LhsT, {\cf17 typename} RhsT>\par
1313     {\cf17 auto} compareEqual( LhsT {\cf17 const}& lhs, RhsT {\cf17 const}& rhs ) -> {\cf18 bool} \{ {\cf19 return} {\cf17 static_cast<}{\cf18 bool}{\cf17 >}(lhs == rhs); \}\par
1314     {\cf17 template}<{\cf17 typename} T>\par
1315     {\cf17 auto} compareEqual( T* {\cf17 const}& lhs, {\cf18 int} rhs ) -> {\cf18 bool} \{ {\cf19 return} lhs == {\cf17 reinterpret_cast<}{\cf18 void} const*{\cf17 >}( rhs ); \}\par
1316     {\cf17 template}<{\cf17 typename} T>\par
1317     {\cf17 auto} compareEqual( T* {\cf17 const}& lhs, {\cf18 long} rhs ) -> {\cf18 bool} \{ {\cf19 return} lhs == {\cf17 reinterpret_cast<}{\cf18 void} const*{\cf17 >}( rhs ); \}\par
1318     {\cf17 template}<{\cf17 typename} T>\par
1319     {\cf17 auto} compareEqual( {\cf18 int} lhs, T* {\cf17 const}& rhs ) -> {\cf18 bool} \{ {\cf19 return} {\cf17 reinterpret_cast<}{\cf18 void} const*{\cf17 >}( lhs ) == rhs; \}\par
1320     {\cf17 template}<{\cf17 typename} T>\par
1321     {\cf17 auto} compareEqual( {\cf18 long} lhs, T* {\cf17 const}& rhs ) -> {\cf18 bool} \{ {\cf19 return} {\cf17 reinterpret_cast<}{\cf18 void} const*{\cf17 >}( lhs ) == rhs; \}\par
1322 \par
1323     {\cf17 template}<{\cf17 typename} LhsT, {\cf17 typename} RhsT>\par
1324     {\cf17 auto} compareNotEqual( LhsT {\cf17 const}& lhs, RhsT&& rhs ) -> {\cf18 bool} \{ {\cf19 return} {\cf17 static_cast<}{\cf18 bool}{\cf17 >}(lhs != rhs); \}\par
1325     {\cf17 template}<{\cf17 typename} T>\par
1326     {\cf17 auto} compareNotEqual( T* {\cf17 const}& lhs, {\cf18 int} rhs ) -> {\cf18 bool} \{ {\cf19 return} lhs != {\cf17 reinterpret_cast<}{\cf18 void} const*{\cf17 >}( rhs ); \}\par
1327     {\cf17 template}<{\cf17 typename} T>\par
1328     {\cf17 auto} compareNotEqual( T* {\cf17 const}& lhs, {\cf18 long} rhs ) -> {\cf18 bool} \{ {\cf19 return} lhs != {\cf17 reinterpret_cast<}{\cf18 void} const*{\cf17 >}( rhs ); \}\par
1329     {\cf17 template}<{\cf17 typename} T>\par
1330     {\cf17 auto} compareNotEqual( {\cf18 int} lhs, T* {\cf17 const}& rhs ) -> {\cf18 bool} \{ {\cf19 return} {\cf17 reinterpret_cast<}{\cf18 void} const*{\cf17 >}( lhs ) != rhs; \}\par
1331     {\cf17 template}<{\cf17 typename} T>\par
1332     {\cf17 auto} compareNotEqual( {\cf18 long} lhs, T* {\cf17 const}& rhs ) -> {\cf18 bool} \{ {\cf19 return} {\cf17 reinterpret_cast<}{\cf18 void} const*{\cf17 >}( lhs ) != rhs; \}\par
1333 \par
1334     {\cf17 template}<{\cf17 typename} LhsT>\par
1335     {\cf17 class }ExprLhs \{\par
1336         LhsT m_lhs;\par
1337     {\cf17 public}:\par
1338         {\cf17 explicit} ExprLhs( LhsT lhs ) : m_lhs( lhs ) \{\}\par
1339 \par
1340         {\cf17 template}<{\cf17 typename} RhsT>\par
1341         {\cf17 auto} operator == ( RhsT {\cf17 const}& rhs ) -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
1342             {\cf19 return} \{ compareEqual( m_lhs, rhs ), m_lhs, {\cf22 "=="}, rhs \};\par
1343         \}\par
1344         {\cf17 auto} operator == ( {\cf18 bool} rhs ) -> BinaryExpr<LhsT, bool> {\cf17 const} \{\par
1345             {\cf19 return} \{ m_lhs == rhs, m_lhs, {\cf22 "=="}, rhs \};\par
1346         \}\par
1347 \par
1348         {\cf17 template}<{\cf17 typename} RhsT>\par
1349         {\cf17 auto} operator != ( RhsT {\cf17 const}& rhs ) -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
1350             {\cf19 return} \{ compareNotEqual( m_lhs, rhs ), m_lhs, {\cf22 "!="}, rhs \};\par
1351         \}\par
1352         {\cf17 auto} operator != ( {\cf18 bool} rhs ) -> BinaryExpr<LhsT, bool> {\cf17 const} \{\par
1353             {\cf19 return} \{ m_lhs != rhs, m_lhs, {\cf22 "!="}, rhs \};\par
1354         \}\par
1355 \par
1356         {\cf17 template}<{\cf17 typename} RhsT>\par
1357         {\cf17 auto} operator > ( RhsT {\cf17 const}& rhs ) -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
1358             {\cf19 return} \{ {\cf17 static_cast<}{\cf18 bool}{\cf17 >}(m_lhs > rhs), m_lhs, {\cf22 ">"}, rhs \};\par
1359         \}\par
1360         {\cf17 template}<{\cf17 typename} RhsT>\par
1361         {\cf17 auto} operator < ( RhsT {\cf17 const}& rhs ) -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
1362             {\cf19 return} \{ {\cf17 static_cast<}{\cf18 bool}{\cf17 >}(m_lhs < rhs), m_lhs, {\cf22 "<"}, rhs \};\par
1363         \}\par
1364         {\cf17 template}<{\cf17 typename} RhsT>\par
1365         {\cf17 auto} operator >= ( RhsT {\cf17 const}& rhs ) -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
1366             {\cf19 return} \{ {\cf17 static_cast<}{\cf18 bool}{\cf17 >}(m_lhs >= rhs), m_lhs, {\cf22 ">="}, rhs \};\par
1367         \}\par
1368         {\cf17 template}<{\cf17 typename} RhsT>\par
1369         {\cf17 auto} operator <= ( RhsT {\cf17 const}& rhs ) -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
1370             {\cf19 return} \{ {\cf17 static_cast<}{\cf18 bool}{\cf17 >}(m_lhs <= rhs), m_lhs, {\cf22 "<="}, rhs \};\par
1371         \}\par
1372 \par
1373         {\cf17 auto} makeUnaryExpr() const -> UnaryExpr<LhsT> \{\par
1374             {\cf19 return} UnaryExpr<LhsT>\{ m_lhs \};\par
1375         \}\par
1376     \};\par
1377 \par
1378     {\cf18 void} handleExpression( ITransientExpression {\cf17 const}& expr );\par
1379 \par
1380     {\cf17 template}<{\cf17 typename} T>\par
1381     {\cf18 void} handleExpression( ExprLhs<T> {\cf17 const}& expr ) \{\par
1382         handleExpression( expr.makeUnaryExpr() );\par
1383     \}\par
1384 \par
1385     {\cf17 struct }Decomposer \{\par
1386         {\cf17 template}<{\cf17 typename} T>\par
1387         {\cf17 auto} operator <= ( T {\cf17 const}& lhs ) -> ExprLhs<T const&> \{\par
1388             {\cf19 return} ExprLhs<T const&>\{ lhs \};\par
1389         \}\par
1390 \par
1391         {\cf17 auto} operator <=( {\cf18 bool} value ) -> ExprLhs<bool> \{\par
1392             {\cf19 return} ExprLhs<bool>\{ value \};\par
1393         \}\par
1394     \};\par
1395 \par
1396 \} {\cf20 // end namespace Catch}\par
1397 \par
1398 {\cf21 #ifdef _MSC_VER}\par
1399 {\cf21 #pragma warning(pop)}\par
1400 {\cf21 #endif}\par
1401 \par
1402 {\cf20 // end catch_decomposer.h}\par
1403 {\cf20 // start catch_interfaces_capture.h}\par
1404 \par
1405 {\cf21 #include <string>}\par
1406 \par
1407 {\cf17 namespace }Catch \{\par
1408 \par
1409     {\cf17 class }AssertionResult;\par
1410     {\cf17 struct }AssertionInfo;\par
1411     {\cf17 struct }SectionInfo;\par
1412     {\cf17 struct }SectionEndInfo;\par
1413     {\cf17 struct }MessageInfo;\par
1414     {\cf17 struct }Counts;\par
1415     {\cf17 struct }BenchmarkInfo;\par
1416     {\cf17 struct }BenchmarkStats;\par
1417     {\cf17 struct }AssertionReaction;\par
1418 \par
1419     {\cf17 struct }ITransientExpression;\par
1420 \par
1421     {\cf17 struct }IResultCapture \{\par
1422 \par
1423         {\cf17 virtual} ~IResultCapture();\par
1424 \par
1425         {\cf17 virtual} {\cf18 bool} sectionStarted(    SectionInfo {\cf17 const}& sectionInfo,\par
1426                                         Counts& assertions ) = 0;\par
1427         {\cf17 virtual} {\cf18 void} sectionEnded( SectionEndInfo {\cf17 const}& endInfo ) = 0;\par
1428         {\cf17 virtual} {\cf18 void} sectionEndedEarly( SectionEndInfo {\cf17 const}& endInfo ) = 0;\par
1429 \par
1430         {\cf17 virtual} {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& info ) = 0;\par
1431         {\cf17 virtual} {\cf18 void} benchmarkEnded( BenchmarkStats {\cf17 const}& stats ) = 0;\par
1432 \par
1433         {\cf17 virtual} {\cf18 void} pushScopedMessage( MessageInfo {\cf17 const}& message ) = 0;\par
1434         {\cf17 virtual} {\cf18 void} popScopedMessage( MessageInfo {\cf17 const}& message ) = 0;\par
1435 \par
1436         {\cf17 virtual} {\cf18 void} handleFatalErrorCondition( StringRef message ) = 0;\par
1437 \par
1438         {\cf17 virtual} {\cf18 void} handleExpr\par
1439                 (   AssertionInfo {\cf17 const}& info,\par
1440                     ITransientExpression {\cf17 const}& expr,\par
1441                     AssertionReaction& reaction ) = 0;\par
1442         {\cf17 virtual} {\cf18 void} handleMessage\par
1443                 (   AssertionInfo {\cf17 const}& info,\par
1444                     ResultWas::OfType resultType,\par
1445                     StringRef {\cf17 const}& message,\par
1446                     AssertionReaction& reaction ) = 0;\par
1447         {\cf17 virtual} {\cf18 void} handleUnexpectedExceptionNotThrown\par
1448                 (   AssertionInfo {\cf17 const}& info,\par
1449                     AssertionReaction& reaction ) = 0;\par
1450         {\cf17 virtual} {\cf18 void} handleUnexpectedInflightException\par
1451                 (   AssertionInfo {\cf17 const}& info,\par
1452                     std::string {\cf17 const}& message,\par
1453                     AssertionReaction& reaction ) = 0;\par
1454         {\cf17 virtual} {\cf18 void} handleIncomplete\par
1455                 (   AssertionInfo {\cf17 const}& info ) = 0;\par
1456         {\cf17 virtual} {\cf18 void} handleNonExpr\par
1457                 (   AssertionInfo {\cf17 const} &info,\par
1458                     ResultWas::OfType resultType,\par
1459                     AssertionReaction &reaction ) = 0;\par
1460 \par
1461         {\cf17 virtual} {\cf18 bool} lastAssertionPassed() = 0;\par
1462         {\cf17 virtual} {\cf18 void} assertionPassed() = 0;\par
1463 \par
1464         {\cf20 // Deprecated, do not use:}\par
1465         {\cf17 virtual} std::string getCurrentTestName() {\cf17 const} = 0;\par
1466         {\cf17 virtual} {\cf17 const} AssertionResult* getLastResult() {\cf17 const} = 0;\par
1467         {\cf17 virtual} {\cf18 void} exceptionEarlyReported() = 0;\par
1468     \};\par
1469 \par
1470     IResultCapture& getResultCapture();\par
1471 \}\par
1472 \par
1473 {\cf20 // end catch_interfaces_capture.h}\par
1474 {\cf17 namespace }Catch \{\par
1475 \par
1476     {\cf17 struct }TestFailureException\{\};\par
1477     {\cf17 struct }AssertionResultData;\par
1478     {\cf17 struct }IResultCapture;\par
1479     {\cf17 class }RunContext;\par
1480 \par
1481     {\cf17 class }LazyExpression \{\par
1482         {\cf17 friend} {\cf17 class }AssertionHandler;\par
1483         {\cf17 friend} {\cf17 struct }AssertionStats;\par
1484         {\cf17 friend} {\cf17 class }RunContext;\par
1485 \par
1486         ITransientExpression {\cf17 const}* m_transientExpression = {\cf17 nullptr};\par
1487         {\cf18 bool} m_isNegated;\par
1488     {\cf17 public}:\par
1489         LazyExpression( {\cf18 bool} isNegated );\par
1490         LazyExpression( LazyExpression {\cf17 const}& other );\par
1491         LazyExpression& operator = ( LazyExpression {\cf17 const}& ) = {\cf17 delete};\par
1492 \par
1493         {\cf17 explicit} {\cf17 operator} bool() {\cf17 const};\par
1494 \par
1495         {\cf17 friend} {\cf17 auto} operator << ( std::ostream& os, LazyExpression {\cf17 const}& lazyExpr ) -> std::ostream&;\par
1496     \};\par
1497 \par
1498     {\cf17 struct }AssertionReaction \{\par
1499         {\cf18 bool} shouldDebugBreak = {\cf17 false};\par
1500         {\cf18 bool} shouldThrow = {\cf17 false};\par
1501     \};\par
1502 \par
1503     {\cf17 class }AssertionHandler \{\par
1504         AssertionInfo m_assertionInfo;\par
1505         AssertionReaction m_reaction;\par
1506         {\cf18 bool} m_completed = {\cf17 false};\par
1507         IResultCapture& m_resultCapture;\par
1508 \par
1509     {\cf17 public}:\par
1510         AssertionHandler\par
1511             (   StringRef macroName,\par
1512                 SourceLineInfo {\cf17 const}& lineInfo,\par
1513                 StringRef capturedExpression,\par
1514                 ResultDisposition::Flags resultDisposition );\par
1515         ~AssertionHandler() \{\par
1516             {\cf19 if} ( !m_completed ) \{\par
1517                 m_resultCapture.handleIncomplete( m_assertionInfo );\par
1518             \}\par
1519         \}\par
1520 \par
1521         {\cf17 template}<{\cf17 typename} T>\par
1522         {\cf18 void} handleExpr( ExprLhs<T> {\cf17 const}& expr ) \{\par
1523             handleExpr( expr.makeUnaryExpr() );\par
1524         \}\par
1525         {\cf18 void} handleExpr( ITransientExpression {\cf17 const}& expr );\par
1526 \par
1527         {\cf18 void} handleMessage(ResultWas::OfType resultType, StringRef {\cf17 const}& message);\par
1528 \par
1529         {\cf18 void} handleExceptionThrownAsExpected();\par
1530         {\cf18 void} handleUnexpectedExceptionNotThrown();\par
1531         {\cf18 void} handleExceptionNotThrownAsExpected();\par
1532         {\cf18 void} handleThrowingCallSkipped();\par
1533         {\cf18 void} handleUnexpectedInflightException();\par
1534 \par
1535         {\cf18 void} complete();\par
1536         {\cf18 void} setCompleted();\par
1537 \par
1538         {\cf20 // query}\par
1539         {\cf17 auto} allowThrows() const -> {\cf18 bool};\par
1540     \};\par
1541 \par
1542     {\cf18 void} handleExceptionMatchExpr( AssertionHandler& handler, std::{\cf18 string} const& str, StringRef matcherString );\par
1543 \par
1544 \} {\cf20 // namespace Catch}\par
1545 \par
1546 {\cf20 // end catch_assertionhandler.h}\par
1547 {\cf20 // start catch_message.h}\par
1548 \par
1549 {\cf21 #include <string>}\par
1550 \par
1551 {\cf17 namespace }Catch \{\par
1552 \par
1553     {\cf17 struct }MessageInfo \{\par
1554         MessageInfo(    std::string {\cf17 const}& _macroName,\par
1555                         SourceLineInfo {\cf17 const}& _lineInfo,\par
1556                         ResultWas::OfType _type );\par
1557 \par
1558         std::string macroName;\par
1559         std::string message;\par
1560         SourceLineInfo lineInfo;\par
1561         ResultWas::OfType type;\par
1562         {\cf18 unsigned} {\cf18 int} sequence;\par
1563 \par
1564         {\cf18 bool} operator == ( MessageInfo {\cf17 const}& other ) {\cf17 const};\par
1565         {\cf18 bool} operator < ( MessageInfo {\cf17 const}& other ) {\cf17 const};\par
1566     {\cf17 private}:\par
1567         {\cf17 static} {\cf18 unsigned} {\cf18 int} globalCount;\par
1568     \};\par
1569 \par
1570     {\cf17 struct }MessageStream \{\par
1571 \par
1572         {\cf17 template}<{\cf17 typename} T>\par
1573         MessageStream& operator << ( T {\cf17 const}& value ) \{\par
1574             m_stream << value;\par
1575             {\cf19 return} *{\cf17 this};\par
1576         \}\par
1577 \par
1578         ReusableStringStream m_stream;\par
1579     \};\par
1580 \par
1581     {\cf17 struct }MessageBuilder : MessageStream \{\par
1582         MessageBuilder( std::string {\cf17 const}& macroName,\par
1583                         SourceLineInfo {\cf17 const}& lineInfo,\par
1584                         ResultWas::OfType type );\par
1585 \par
1586         {\cf17 template}<{\cf17 typename} T>\par
1587         MessageBuilder& operator << ( T {\cf17 const}& value ) \{\par
1588             m_stream << value;\par
1589             {\cf19 return} *{\cf17 this};\par
1590         \}\par
1591 \par
1592         MessageInfo m_info;\par
1593     \};\par
1594 \par
1595     {\cf17 class }ScopedMessage \{\par
1596     {\cf17 public}:\par
1597         {\cf17 explicit} ScopedMessage( MessageBuilder {\cf17 const}& builder );\par
1598         ~ScopedMessage();\par
1599 \par
1600         MessageInfo m_info;\par
1601     \};\par
1602 \par
1603 \} {\cf20 // end namespace Catch}\par
1604 \par
1605 {\cf20 // end catch_message.h}\par
1606 {\cf21 #if !defined(CATCH_CONFIG_DISABLE)}\par
1607 \par
1608 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_STRINGIFICATION)}\par
1609 {\cf21   #define CATCH_INTERNAL_STRINGIFY(...) #__VA_ARGS__}\par
1610 {\cf21 #else}\par
1611 {\cf21   #define CATCH_INTERNAL_STRINGIFY(...) "Disabled by CATCH_CONFIG_DISABLE_STRINGIFICATION"}\par
1612 {\cf21 #endif}\par
1613 \par
1614 {\cf21 #if defined(CATCH_CONFIG_FAST_COMPILE)}\par
1615 \par
1617 {\cf20 // Another way to speed-up compilation is to omit local try-catch for REQUIRE*}\par
1618 {\cf20 // macros.}\par
1619 {\cf21 #define INTERNAL_CATCH_TRY}\par
1620 {\cf21 #define INTERNAL_CATCH_CATCH( capturer )}\par
1621 \par
1622 {\cf21 #else }{\cf20 // CATCH_CONFIG_FAST_COMPILE}\par
1623 \par
1624 {\cf21 #define INTERNAL_CATCH_TRY try}\par
1625 {\cf21 #define INTERNAL_CATCH_CATCH( handler ) catch(...) \{ handler.handleUnexpectedInflightException(); \}}\par
1626 \par
1627 {\cf21 #endif}\par
1628 \par
1629 {\cf21 #define INTERNAL_CATCH_REACT( handler ) handler.complete();}\par
1630 \par
1632 {\cf21 #define INTERNAL_CATCH_TEST( macroName, resultDisposition, ... ) \\}\par
1633 {\cf21     do \{ \\}\par
1634 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \\}\par
1635 {\cf21         INTERNAL_CATCH_TRY \{ \\}\par
1636 {\cf21             CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \\}\par
1637 {\cf21             catchAssertionHandler.handleExpr( Catch::Decomposer() <= __VA_ARGS__ ); \\}\par
1638 {\cf21             CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS \\}\par
1639 {\cf21         \} INTERNAL_CATCH_CATCH( catchAssertionHandler ) \\}\par
1640 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
1641 {\cf21     \} while( (void)0, false && static_cast<bool>( !!(__VA_ARGS__) ) ) }{\cf20 // the expression here is never evaluated at runtime but it forces the compiler to give it a look}\par
1642     {\cf20 // The double negation silences MSVC's C4800 warning, the static_cast forces short-circuit evaluation if the type has overloaded &&.}\par
1643 \par
1645 {\cf21 #define INTERNAL_CATCH_IF( macroName, resultDisposition, ... ) \\}\par
1646 {\cf21     INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \\}\par
1647 {\cf21     if( Catch::getResultCapture().lastAssertionPassed() )}\par
1648 \par
1650 {\cf21 #define INTERNAL_CATCH_ELSE( macroName, resultDisposition, ... ) \\}\par
1651 {\cf21     INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \\}\par
1652 {\cf21     if( !Catch::getResultCapture().lastAssertionPassed() )}\par
1653 \par
1655 {\cf21 #define INTERNAL_CATCH_NO_THROW( macroName, resultDisposition, ... ) \\}\par
1656 {\cf21     do \{ \\}\par
1657 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \\}\par
1658 {\cf21         try \{ \\}\par
1659 {\cf21             static_cast<void>(__VA_ARGS__); \\}\par
1660 {\cf21             catchAssertionHandler.handleExceptionNotThrownAsExpected(); \\}\par
1661 {\cf21         \} \\}\par
1662 {\cf21         catch( ... ) \{ \\}\par
1663 {\cf21             catchAssertionHandler.handleUnexpectedInflightException(); \\}\par
1664 {\cf21         \} \\}\par
1665 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
1666 {\cf21     \} while( false )}\par
1667 \par
1669 {\cf21 #define INTERNAL_CATCH_THROWS( macroName, resultDisposition, ... ) \\}\par
1670 {\cf21     do \{ \\}\par
1671 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition); \\}\par
1672 {\cf21         if( catchAssertionHandler.allowThrows() ) \\}\par
1673 {\cf21             try \{ \\}\par
1674 {\cf21                 static_cast<void>(__VA_ARGS__); \\}\par
1675 {\cf21                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\}\par
1676 {\cf21             \} \\}\par
1677 {\cf21             catch( ... ) \{ \\}\par
1678 {\cf21                 catchAssertionHandler.handleExceptionThrownAsExpected(); \\}\par
1679 {\cf21             \} \\}\par
1680 {\cf21         else \\}\par
1681 {\cf21             catchAssertionHandler.handleThrowingCallSkipped(); \\}\par
1682 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
1683 {\cf21     \} while( false )}\par
1684 \par
1686 {\cf21 #define INTERNAL_CATCH_THROWS_AS( macroName, exceptionType, resultDisposition, expr ) \\}\par
1687 {\cf21     do \{ \\}\par
1688 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr) ", "} CATCH_INTERNAL_STRINGIFY(exceptionType), resultDisposition ); \\\par
1689         if( catchAssertionHandler.allowThrows() ) \\\par
1690             try \{ \\\par
1691                 static_cast<void>(expr); \\\par
1692                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\par
1693             \} \\\par
1694             catch( exceptionType const& ) \{ \\\par
1695                 catchAssertionHandler.handleExceptionThrownAsExpected(); \\\par
1696             \} \\\par
1697             catch( ... ) \{ \\\par
1698                 catchAssertionHandler.handleUnexpectedInflightException(); \\\par
1699             \} \\\par
1700         else \\\par
1701             catchAssertionHandler.handleThrowingCallSkipped(); \\\par
1702         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\par
1703     \} while( false )\par
1704 \par
1706 {\cf21 #define INTERNAL_CATCH_MSG( macroName, messageType, resultDisposition, ... ) \\}\par
1707 {\cf21     do \{ \\}\par
1708 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, ""}, resultDisposition ); \\\par
1709         catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() << __VA_ARGS__ + ::Catch::StreamEndStop() ).m_stream.str() ); \\\par
1710         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\par
1711     \} while( false )\par
1712 \par
1714 {\cf21 #define INTERNAL_CATCH_INFO( macroName, log ) \\}\par
1715 {\cf21     Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage )( Catch::MessageBuilder( macroName, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log );}\par
1716 \par
1718 {\cf20 // Although this is matcher-based, it can be used with just a string}\par
1719 {\cf21 #define INTERNAL_CATCH_THROWS_STR_MATCHES( macroName, resultDisposition, matcher, ... ) \\}\par
1720 {\cf21     do \{ \\}\par
1721 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", "} CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\\par
1722         if( catchAssertionHandler.allowThrows() ) \\\par
1723             try \{ \\\par
1724                 static_cast<void>(__VA_ARGS__); \\\par
1725                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\par
1726             \} \\\par
1727             catch( ... ) \{ \\\par
1728                 Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher, #matcher ); \\\par
1729             \} \\\par
1730         else \\\par
1731             catchAssertionHandler.handleThrowingCallSkipped(); \\\par
1732         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\par
1733     \} while( false )\par
1734 \par
1735 {\cf21 #endif }{\cf20 // CATCH_CONFIG_DISABLE}\par
1736 \par
1737 {\cf20 // end catch_capture.hpp}\par
1738 {\cf20 // start catch_section.h}\par
1739 \par
1740 {\cf20 // start catch_section_info.h}\par
1741 \par
1742 {\cf20 // start catch_totals.h}\par
1743 \par
1744 {\cf21 #include <cstddef>}\par
1745 \par
1746 {\cf17 namespace }Catch \{\par
1747 \par
1748     {\cf17 struct }Counts \{\par
1749         Counts operator - ( Counts {\cf17 const}& other ) {\cf17 const};\par
1750         Counts& operator += ( Counts {\cf17 const}& other );\par
1751 \par
1752         std::size_t total() {\cf17 const};\par
1753         {\cf18 bool} allPassed() {\cf17 const};\par
1754         {\cf18 bool} allOk() {\cf17 const};\par
1755 \par
1756         std::size_t passed = 0;\par
1757         std::size_t failed = 0;\par
1758         std::size_t failedButOk = 0;\par
1759     \};\par
1760 \par
1761     {\cf17 struct }Totals \{\par
1762 \par
1763         Totals operator - ( Totals {\cf17 const}& other ) {\cf17 const};\par
1764         Totals& operator += ( Totals {\cf17 const}& other );\par
1765 \par
1766         Totals delta( Totals {\cf17 const}& prevTotals ) {\cf17 const};\par
1767 \par
1768         {\cf18 int} error = 0;\par
1769         Counts assertions;\par
1770         Counts testCases;\par
1771     \};\par
1772 \}\par
1773 \par
1774 {\cf20 // end catch_totals.h}\par
1775 {\cf21 #include <string>}\par
1776 \par
1777 {\cf17 namespace }Catch \{\par
1778 \par
1779     {\cf17 struct }SectionInfo \{\par
1780         SectionInfo\par
1781             (   SourceLineInfo {\cf17 const}& _lineInfo,\par
1782                 std::string {\cf17 const}& _name,\par
1783                 std::string {\cf17 const}& _description = std::string() );\par
1784 \par
1785         std::string name;\par
1786         std::string description;\par
1787         SourceLineInfo lineInfo;\par
1788     \};\par
1789 \par
1790     {\cf17 struct }SectionEndInfo \{\par
1791         SectionEndInfo( SectionInfo {\cf17 const}& _sectionInfo, Counts {\cf17 const}& _prevAssertions, {\cf18 double} _durationInSeconds );\par
1792 \par
1793         SectionInfo sectionInfo;\par
1794         Counts prevAssertions;\par
1795         {\cf18 double} durationInSeconds;\par
1796     \};\par
1797 \par
1798 \} {\cf20 // end namespace Catch}\par
1799 \par
1800 {\cf20 // end catch_section_info.h}\par
1801 {\cf20 // start catch_timer.h}\par
1802 \par
1803 {\cf21 #include <cstdint>}\par
1804 \par
1805 {\cf17 namespace }Catch \{\par
1806 \par
1807     {\cf17 auto} getCurrentNanosecondsSinceEpoch() -> uint64_t;\par
1808     {\cf17 auto} getEstimatedClockResolution() -> uint64_t;\par
1809 \par
1810     {\cf17 class }Timer \{\par
1811         uint64_t m_nanoseconds = 0;\par
1812     {\cf17 public}:\par
1813         {\cf18 void} start();\par
1814         {\cf17 auto} getElapsedNanoseconds() const -> uint64_t;\par
1815         auto getElapsedMicroseconds() const -> uint64_t;\par
1816         auto getElapsedMilliseconds() const -> {\cf18 unsigned} {\cf18 int};\par
1817         auto getElapsedSeconds() const -> {\cf18 double};\par
1818     \};\par
1819 \par
1820 \} {\cf20 // namespace Catch}\par
1821 \par
1822 {\cf20 // end catch_timer.h}\par
1823 {\cf21 #include <string>}\par
1824 \par
1825 {\cf17 namespace }Catch \{\par
1826 \par
1827     {\cf17 class }Section : NonCopyable \{\par
1828     {\cf17 public}:\par
1829         Section( SectionInfo {\cf17 const}& info );\par
1830         ~Section();\par
1831 \par
1832         {\cf20 // This indicates whether the section should be executed or not}\par
1833         {\cf17 explicit} {\cf17 operator} bool() {\cf17 const};\par
1834 \par
1835     {\cf17 private}:\par
1836         SectionInfo m_info;\par
1837 \par
1838         std::string m_name;\par
1839         Counts m_assertions;\par
1840         {\cf18 bool} m_sectionIncluded;\par
1841         Timer m_timer;\par
1842     \};\par
1843 \par
1844 \} {\cf20 // end namespace Catch}\par
1845 \par
1846 {\cf21     #define INTERNAL_CATCH_SECTION( ... ) \\}\par
1847 {\cf21         if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) )}\par
1848 \par
1849 {\cf20 // end catch_section.h}\par
1850 {\cf20 // start catch_benchmark.h}\par
1851 \par
1852 {\cf21 #include <cstdint>}\par
1853 {\cf21 #include <string>}\par
1854 \par
1855 {\cf17 namespace }Catch \{\par
1856 \par
1857     {\cf17 class }BenchmarkLooper \{\par
1858 \par
1859         std::string m_name;\par
1860         std::size_t m_count = 0;\par
1861         std::size_t m_iterationsToRun = 1;\par
1862         uint64_t m_resolution;\par
1863         Timer m_timer;\par
1864 \par
1865         {\cf17 static} {\cf17 auto} getResolution() -> uint64_t;\par
1866     {\cf17 public}:\par
1867         {\cf20 // Keep most of this inline as it's on the code path that is being timed}\par
1868         BenchmarkLooper( StringRef name )\par
1869         :   m_name( name ),\par
1870             m_resolution( getResolution() )\par
1871         \{\par
1872             reportStart();\par
1873             m_timer.start();\par
1874         \}\par
1875 \par
1876         {\cf17 explicit} {\cf17 operator} bool() \{\par
1877             {\cf19 if}( m_count < m_iterationsToRun )\par
1878                 {\cf19 return} {\cf17 true};\par
1879             {\cf19 return} needsMoreIterations();\par
1880         \}\par
1881 \par
1882         {\cf18 void} increment() \{\par
1883             ++m_count;\par
1884         \}\par
1885 \par
1886         {\cf18 void} reportStart();\par
1887         {\cf17 auto} needsMoreIterations() -> bool;\par
1888     \};\par
1889 \par
1890 \} {\cf20 // end namespace Catch}\par
1891 \par
1892 {\cf21 #define BENCHMARK( name ) \\}\par
1893 {\cf21     for( Catch::BenchmarkLooper looper( name ); looper; looper.increment() )}\par
1894 \par
1895 {\cf20 // end catch_benchmark.h}\par
1896 {\cf20 // start catch_interfaces_exception.h}\par
1897 \par
1898 {\cf20 // start catch_interfaces_registry_hub.h}\par
1899 \par
1900 {\cf21 #include <string>}\par
1901 {\cf21 #include <memory>}\par
1902 \par
1903 {\cf17 namespace }Catch \{\par
1904 \par
1905     {\cf17 class }TestCase;\par
1906     {\cf17 struct }ITestCaseRegistry;\par
1907     {\cf17 struct }IExceptionTranslatorRegistry;\par
1908     {\cf17 struct }IExceptionTranslator;\par
1909     {\cf17 struct }IReporterRegistry;\par
1910     {\cf17 struct }IReporterFactory;\par
1911     {\cf17 struct }ITagAliasRegistry;\par
1912     {\cf17 class }StartupExceptionRegistry;\par
1913 \par
1914     {\cf17 using }IReporterFactoryPtr = std::shared_ptr<IReporterFactory>;\par
1915 \par
1916     {\cf17 struct }IRegistryHub \{\par
1917         {\cf17 virtual} ~IRegistryHub();\par
1918 \par
1919         {\cf17 virtual} IReporterRegistry {\cf17 const}& getReporterRegistry() {\cf17 const} = 0;\par
1920         {\cf17 virtual} ITestCaseRegistry {\cf17 const}& getTestCaseRegistry() {\cf17 const} = 0;\par
1921         {\cf17 virtual} ITagAliasRegistry {\cf17 const}& getTagAliasRegistry() {\cf17 const} = 0;\par
1922 \par
1923         {\cf17 virtual} IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() = 0;\par
1924 \par
1925         {\cf17 virtual} StartupExceptionRegistry {\cf17 const}& getStartupExceptionRegistry() {\cf17 const} = 0;\par
1926     \};\par
1927 \par
1928     {\cf17 struct }IMutableRegistryHub \{\par
1929         {\cf17 virtual} ~IMutableRegistryHub();\par
1930         {\cf17 virtual} {\cf18 void} registerReporter( std::string {\cf17 const}& name, IReporterFactoryPtr {\cf17 const}& factory ) = 0;\par
1931         {\cf17 virtual} {\cf18 void} registerListener( IReporterFactoryPtr {\cf17 const}& factory ) = 0;\par
1932         {\cf17 virtual} {\cf18 void} registerTest( TestCase {\cf17 const}& testInfo ) = 0;\par
1933         {\cf17 virtual} {\cf18 void} registerTranslator( {\cf17 const} IExceptionTranslator* translator ) = 0;\par
1934         {\cf17 virtual} {\cf18 void} registerTagAlias( std::string {\cf17 const}& alias, std::string {\cf17 const}& tag, SourceLineInfo {\cf17 const}& lineInfo ) = 0;\par
1935         {\cf17 virtual} {\cf18 void} registerStartupException() noexcept = 0;\par
1936     \};\par
1937 \par
1938     IRegistryHub& getRegistryHub();\par
1939     IMutableRegistryHub& getMutableRegistryHub();\par
1940     {\cf18 void} cleanUp();\par
1941     std::{\cf18 string} translateActiveException();\par
1942 \par
1943 \}\par
1944 \par
1945 {\cf20 // end catch_interfaces_registry_hub.h}\par
1946 {\cf21 #if defined(CATCH_CONFIG_DISABLE)}\par
1947 {\cf21     #define INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( translatorName, signature) \\}\par
1948 {\cf21         static std::string translatorName( signature )}\par
1949 {\cf21 #endif}\par
1950 \par
1951 {\cf21 #include <exception>}\par
1952 {\cf21 #include <string>}\par
1953 {\cf21 #include <vector>}\par
1954 \par
1955 {\cf17 namespace }Catch \{\par
1956     {\cf17 using }exceptionTranslateFunction = std::string(*)();\par
1957 \par
1958     {\cf17 struct }IExceptionTranslator;\par
1959     {\cf17 using }ExceptionTranslators = std::vector<std::unique_ptr<IExceptionTranslator const>>;\par
1960 \par
1961     {\cf17 struct }IExceptionTranslator \{\par
1962         {\cf17 virtual} ~IExceptionTranslator();\par
1963         {\cf17 virtual} std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) {\cf17 const} = 0;\par
1964     \};\par
1965 \par
1966     {\cf17 struct }IExceptionTranslatorRegistry \{\par
1967         {\cf17 virtual} ~IExceptionTranslatorRegistry();\par
1968 \par
1969         {\cf17 virtual} std::string translateActiveException() {\cf17 const} = 0;\par
1970     \};\par
1971 \par
1972     {\cf17 class }ExceptionTranslatorRegistrar \{\par
1973         {\cf17 template}<{\cf17 typename} T>\par
1974         {\cf17 class }ExceptionTranslator : {\cf17 public} IExceptionTranslator \{\par
1975         {\cf17 public}:\par
1976 \par
1977             ExceptionTranslator( std::string(*translateFunction)( T& ) )\par
1978             : m_translateFunction( translateFunction )\par
1979             \{\}\par
1980 \par
1981             std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ){\cf17  const override }\{\par
1982                 {\cf19 try} \{\par
1983                     {\cf19 if}( it == itEnd )\par
1984                         std::rethrow_exception(std::current_exception());\par
1985                     {\cf19 else}\par
1986                         {\cf19 return} (*it)->translate( it+1, itEnd );\par
1987                 \}\par
1988                 {\cf19 catch}( T& ex ) \{\par
1989                     {\cf19 return} m_translateFunction( ex );\par
1990                 \}\par
1991             \}\par
1992 \par
1993         {\cf17 protected}:\par
1994             std::string(*m_translateFunction)( T& );\par
1995         \};\par
1996 \par
1997     {\cf17 public}:\par
1998         {\cf17 template}<{\cf17 typename} T>\par
1999         ExceptionTranslatorRegistrar( std::string(*translateFunction)( T& ) ) \{\par
2000             getMutableRegistryHub().registerTranslator\par
2001                 ( {\cf17 new} ExceptionTranslator<T>( translateFunction ) );\par
2002         \}\par
2003     \};\par
2004 \}\par
2005 \par
2007 {\cf21 #define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName, signature ) \\}\par
2008 {\cf21     static std::string translatorName( signature ); \\}\par
2009 {\cf21     CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
2010 {\cf21     namespace\{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &translatorName ); \} \\}\par
2011 {\cf21     CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\}\par
2012 {\cf21     static std::string translatorName( signature )}\par
2013 \par
2014 {\cf21 #define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION2( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )}\par
2015 \par
2016 {\cf20 // end catch_interfaces_exception.h}\par
2017 {\cf20 // start catch_approx.h}\par
2018 \par
2019 {\cf21 #include <type_traits>}\par
2020 {\cf21 #include <stdexcept>}\par
2021 \par
2022 {\cf17 namespace }Catch \{\par
2023 {\cf17 namespace }Detail \{\par
2024 \par
2025     {\cf17 class }Approx \{\par
2026     {\cf17 private}:\par
2027         {\cf18 bool} equalityComparisonImpl({\cf18 double} other) {\cf17 const};\par
2028 \par
2029     {\cf17 public}:\par
2030         {\cf17 explicit} Approx ( {\cf18 double} value );\par
2031 \par
2032         {\cf17 static} Approx custom();\par
2033 \par
2034         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\par
2035         Approx operator()( T {\cf17 const}& value ) \{\par
2036             Approx approx( {\cf17 static_cast<}{\cf18 double}{\cf17 >}(value) );\par
2037             approx.epsilon( m_epsilon );\par
2038             approx.margin( m_margin );\par
2039             approx.scale( m_scale );\par
2040             {\cf19 return} approx;\par
2041         \}\par
2042 \par
2043         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\par
2044         {\cf17 explicit} Approx( T {\cf17 const}& value ): Approx(static_cast<double>(value))\par
2045         \{\}\par
2046 \par
2047         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\par
2048         {\cf17 friend} {\cf18 bool} operator == ( {\cf17 const} T& lhs, Approx {\cf17 const}& rhs ) \{\par
2049             {\cf17 auto} lhs_v = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(lhs);\par
2050             {\cf19 return} rhs.equalityComparisonImpl(lhs_v);\par
2051         \}\par
2052 \par
2053         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\par
2054         {\cf17 friend} {\cf18 bool} operator == ( Approx {\cf17 const}& lhs, {\cf17 const} T& rhs ) \{\par
2055             {\cf19 return} operator==( rhs, lhs );\par
2056         \}\par
2057 \par
2058         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\par
2059         {\cf17 friend} {\cf18 bool} operator != ( T {\cf17 const}& lhs, Approx {\cf17 const}& rhs ) \{\par
2060             {\cf19 return} !operator==( lhs, rhs );\par
2061         \}\par
2062 \par
2063         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\par
2064         {\cf17 friend} {\cf18 bool} operator != ( Approx {\cf17 const}& lhs, T {\cf17 const}& rhs ) \{\par
2065             {\cf19 return} !operator==( rhs, lhs );\par
2066         \}\par
2067 \par
2068         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\par
2069         {\cf17 friend} {\cf18 bool} operator <= ( T {\cf17 const}& lhs, Approx {\cf17 const}& rhs ) \{\par
2070             {\cf19 return} {\cf17 static_cast<}{\cf18 double}{\cf17 >}(lhs) < rhs.m_value || lhs == rhs;\par
2071         \}\par
2072 \par
2073         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\par
2074         {\cf17 friend} {\cf18 bool} operator <= ( Approx {\cf17 const}& lhs, T {\cf17 const}& rhs ) \{\par
2075             {\cf19 return} lhs.m_value < {\cf17 static_cast<}{\cf18 double}{\cf17 >}(rhs) || lhs == rhs;\par
2076         \}\par
2077 \par
2078         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\par
2079         {\cf17 friend} {\cf18 bool} operator >= ( T {\cf17 const}& lhs, Approx {\cf17 const}& rhs ) \{\par
2080             {\cf19 return} {\cf17 static_cast<}{\cf18 double}{\cf17 >}(lhs) > rhs.m_value || lhs == rhs;\par
2081         \}\par
2082 \par
2083         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\par
2084         {\cf17 friend} {\cf18 bool} operator >= ( Approx {\cf17 const}& lhs, T {\cf17 const}& rhs ) \{\par
2085             {\cf19 return} lhs.m_value > {\cf17 static_cast<}{\cf18 double}{\cf17 >}(rhs) || lhs == rhs;\par
2086         \}\par
2087 \par
2088         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\par
2089         Approx& epsilon( T {\cf17 const}& newEpsilon ) \{\par
2090             {\cf18 double} epsilonAsDouble = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(newEpsilon);\par
2091             {\cf19 if}( epsilonAsDouble < 0 || epsilonAsDouble > 1.0 ) \{\par
2092                 {\cf19 throw} std::domain_error\par
2093                     (   {\cf22 "Invalid Approx::epsilon: "} +\par
2094                         Catch::Detail::stringify( epsilonAsDouble ) +\par
2095                         {\cf22 ", Approx::epsilon has to be between 0 and 1"} );\par
2096             \}\par
2097             m_epsilon = epsilonAsDouble;\par
2098             {\cf19 return} *{\cf17 this};\par
2099         \}\par
2100 \par
2101         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\par
2102         Approx& margin( T {\cf17 const}& newMargin ) \{\par
2103             {\cf18 double} marginAsDouble = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(newMargin);\par
2104             {\cf19 if}( marginAsDouble < 0 ) \{\par
2105                 {\cf19 throw} std::domain_error\par
2106                     (   {\cf22 "Invalid Approx::margin: "} +\par
2107                          Catch::Detail::stringify( marginAsDouble ) +\par
2108                          {\cf22 ", Approx::Margin has to be non-negative."} );\par
2109 \par
2110             \}\par
2111             m_margin = marginAsDouble;\par
2112             {\cf19 return} *{\cf17 this};\par
2113         \}\par
2114 \par
2115         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\par
2116         Approx& scale( T {\cf17 const}& newScale ) \{\par
2117             m_scale = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(newScale);\par
2118             {\cf19 return} *{\cf17 this};\par
2119         \}\par
2120 \par
2121         std::string toString() {\cf17 const};\par
2122 \par
2123     {\cf17 private}:\par
2124         {\cf18 double} m_epsilon;\par
2125         {\cf18 double} m_margin;\par
2126         {\cf18 double} m_scale;\par
2127         {\cf18 double} m_value;\par
2128     \};\par
2129 \}\par
2130 \par
2131 {\cf17 template}<>\par
2132 {\cf17 struct }StringMaker<Catch::Detail::Approx> \{\par
2133     {\cf17 static} std::string convert(Catch::Detail::Approx {\cf17 const}& value);\par
2134 \};\par
2135 \par
2136 \} {\cf20 // end namespace Catch}\par
2137 \par
2138 {\cf20 // end catch_approx.h}\par
2139 {\cf20 // start catch_string_manip.h}\par
2140 \par
2141 {\cf21 #include <string>}\par
2142 {\cf21 #include <iosfwd>}\par
2143 \par
2144 {\cf17 namespace }Catch \{\par
2145 \par
2146     {\cf18 bool} startsWith( std::string {\cf17 const}& s, std::string {\cf17 const}& prefix );\par
2147     {\cf18 bool} startsWith( std::string {\cf17 const}& s, {\cf18 char} prefix );\par
2148     {\cf18 bool} endsWith( std::string {\cf17 const}& s, std::string {\cf17 const}& suffix );\par
2149     {\cf18 bool} endsWith( std::string {\cf17 const}& s, {\cf18 char} suffix );\par
2150     {\cf18 bool} contains( std::string {\cf17 const}& s, std::string {\cf17 const}& infix );\par
2151     {\cf18 void} toLowerInPlace( std::string& s );\par
2152     std::string toLower( std::string {\cf17 const}& s );\par
2153     std::string trim( std::string {\cf17 const}& str );\par
2154     {\cf18 bool} replaceInPlace( std::string& str, std::string {\cf17 const}& replaceThis, std::string {\cf17 const}& withThis );\par
2155 \par
2156     {\cf17 struct }pluralise \{\par
2157         pluralise( std::size_t count, std::string {\cf17 const}& label );\par
2158 \par
2159         {\cf17 friend} std::ostream& operator << ( std::ostream& os, pluralise {\cf17 const}& pluraliser );\par
2160 \par
2161         std::size_t m_count;\par
2162         std::string m_label;\par
2163     \};\par
2164 \}\par
2165 \par
2166 {\cf20 // end catch_string_manip.h}\par
2167 {\cf21 #ifndef CATCH_CONFIG_DISABLE_MATCHERS}\par
2168 {\cf20 // start catch_capture_matchers.h}\par
2169 \par
2170 {\cf20 // start catch_matchers.h}\par
2171 \par
2172 {\cf21 #include <string>}\par
2173 {\cf21 #include <vector>}\par
2174 \par
2175 {\cf17 namespace }Catch \{\par
2176 {\cf17 namespace }Matchers \{\par
2177     {\cf17 namespace }Impl \{\par
2178 \par
2179         {\cf17 template}<{\cf17 typename} ArgT> {\cf17 struct }MatchAllOf;\par
2180         {\cf17 template}<{\cf17 typename} ArgT> {\cf17 struct }MatchAnyOf;\par
2181         {\cf17 template}<{\cf17 typename} ArgT> {\cf17 struct }MatchNotOf;\par
2182 \par
2183         {\cf17 class }MatcherUntypedBase \{\par
2184         {\cf17 public}:\par
2185             MatcherUntypedBase() = {\cf19 default};\par
2186             MatcherUntypedBase ( MatcherUntypedBase {\cf17 const}& ) = {\cf19 default};\par
2187             MatcherUntypedBase& operator = ( MatcherUntypedBase {\cf17 const}& ) = {\cf17 delete};\par
2188             std::string toString() {\cf17 const};\par
2189 \par
2190         {\cf17 protected}:\par
2191             {\cf17 virtual} ~MatcherUntypedBase();\par
2192             {\cf17 virtual} std::string describe() {\cf17 const} = 0;\par
2193             {\cf17 mutable} std::string m_cachedToString;\par
2194         \};\par
2195 \par
2196         {\cf17 template}<{\cf17 typename} ObjectT>\par
2197         {\cf17 struct }MatcherMethod \{\par
2198             {\cf17 virtual} {\cf18 bool} match( ObjectT {\cf17 const}& arg ) {\cf17 const} = 0;\par
2199         \};\par
2200         {\cf17 template}<{\cf17 typename} PtrT>\par
2201         {\cf17 struct }MatcherMethod<PtrT*> \{\par
2202             {\cf17 virtual} {\cf18 bool} match( PtrT* arg ) {\cf17 const} = 0;\par
2203         \};\par
2204 \par
2205         {\cf17 template}<{\cf17 typename} T>\par
2206         {\cf17 struct }MatcherBase : MatcherUntypedBase, MatcherMethod<T> \{\par
2207 \par
2208             MatchAllOf<T> operator && ( MatcherBase {\cf17 const}& other ) {\cf17 const};\par
2209             MatchAnyOf<T> operator || ( MatcherBase {\cf17 const}& other ) {\cf17 const};\par
2210             MatchNotOf<T> operator ! () {\cf17 const};\par
2211         \};\par
2212 \par
2213         {\cf17 template}<{\cf17 typename} ArgT>\par
2214         {\cf17 struct }MatchAllOf : MatcherBase<ArgT> \{\par
2215             {\cf18 bool} match( ArgT {\cf17 const}& arg ){\cf17  const override }\{\par
2216                 {\cf19 for}( {\cf17 auto} matcher : m_matchers ) \{\par
2217                     {\cf19 if} (!matcher->match(arg))\par
2218                         {\cf19 return} {\cf17 false};\par
2219                 \}\par
2220                 {\cf19 return} {\cf17 true};\par
2221             \}\par
2222             std::string describe(){\cf17  const override }\{\par
2223                 std::string description;\par
2224                 description.reserve( 4 + m_matchers.size()*32 );\par
2225                 description += {\cf22 "( "};\par
2226                 {\cf18 bool} first = {\cf17 true};\par
2227                 {\cf19 for}( {\cf17 auto} matcher : m_matchers ) \{\par
2228                     {\cf19 if}( first )\par
2229                         first = {\cf17 false};\par
2230                     {\cf19 else}\par
2231                         description += {\cf22 " and "};\par
2232                     description += matcher->toString();\par
2233                 \}\par
2234                 description += {\cf22 " )"};\par
2235                 {\cf19 return} description;\par
2236             \}\par
2237 \par
2238             MatchAllOf<ArgT>& operator && ( MatcherBase<ArgT> {\cf17 const}& other ) \{\par
2239                 m_matchers.push_back( &other );\par
2240                 {\cf19 return} *{\cf17 this};\par
2241             \}\par
2242 \par
2243             std::vector<MatcherBase<ArgT> {\cf17 const}*> m_matchers;\par
2244         \};\par
2245         {\cf17 template}<{\cf17 typename} ArgT>\par
2246         {\cf17 struct }MatchAnyOf : MatcherBase<ArgT> \{\par
2247 \par
2248             {\cf18 bool} match( ArgT {\cf17 const}& arg ){\cf17  const override }\{\par
2249                 {\cf19 for}( {\cf17 auto} matcher : m_matchers ) \{\par
2250                     {\cf19 if} (matcher->match(arg))\par
2251                         {\cf19 return} {\cf17 true};\par
2252                 \}\par
2253                 {\cf19 return} {\cf17 false};\par
2254             \}\par
2255             std::string describe(){\cf17  const override }\{\par
2256                 std::string description;\par
2257                 description.reserve( 4 + m_matchers.size()*32 );\par
2258                 description += {\cf22 "( "};\par
2259                 {\cf18 bool} first = {\cf17 true};\par
2260                 {\cf19 for}( {\cf17 auto} matcher : m_matchers ) \{\par
2261                     {\cf19 if}( first )\par
2262                         first = {\cf17 false};\par
2263                     {\cf19 else}\par
2264                         description += {\cf22 " or "};\par
2265                     description += matcher->toString();\par
2266                 \}\par
2267                 description += {\cf22 " )"};\par
2268                 {\cf19 return} description;\par
2269             \}\par
2270 \par
2271             MatchAnyOf<ArgT>& operator || ( MatcherBase<ArgT> {\cf17 const}& other ) \{\par
2272                 m_matchers.push_back( &other );\par
2273                 {\cf19 return} *{\cf17 this};\par
2274             \}\par
2275 \par
2276             std::vector<MatcherBase<ArgT> {\cf17 const}*> m_matchers;\par
2277         \};\par
2278 \par
2279         {\cf17 template}<{\cf17 typename} ArgT>\par
2280         {\cf17 struct }MatchNotOf : MatcherBase<ArgT> \{\par
2281 \par
2282             MatchNotOf( MatcherBase<ArgT> {\cf17 const}& underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) \{\}\par
2283 \par
2284             {\cf18 bool} match( ArgT {\cf17 const}& arg ){\cf17  const override }\{\par
2285                 {\cf19 return} !m_underlyingMatcher.match( arg );\par
2286             \}\par
2287 \par
2288             std::string describe(){\cf17  const override }\{\par
2289                 {\cf19 return} {\cf22 "not "} + m_underlyingMatcher.toString();\par
2290             \}\par
2291             MatcherBase<ArgT> {\cf17 const}& m_underlyingMatcher;\par
2292         \};\par
2293 \par
2294         {\cf17 template}<{\cf17 typename} T>\par
2295         MatchAllOf<T> MatcherBase<T>::operator && ( MatcherBase {\cf17 const}& other ){\cf17  const }\{\par
2296             {\cf19 return} MatchAllOf<T>() && *{\cf17 this} && other;\par
2297         \}\par
2298         {\cf17 template}<{\cf17 typename} T>\par
2299         MatchAnyOf<T> MatcherBase<T>::operator || ( MatcherBase {\cf17 const}& other ){\cf17  const }\{\par
2300             {\cf19 return} MatchAnyOf<T>() || *{\cf17 this} || other;\par
2301         \}\par
2302         {\cf17 template}<{\cf17 typename} T>\par
2303         MatchNotOf<T> MatcherBase<T>::operator ! (){\cf17  const }\{\par
2304             {\cf19 return} MatchNotOf<T>( *{\cf17 this} );\par
2305         \}\par
2306 \par
2307     \} {\cf20 // namespace Impl}\par
2308 \par
2309 \} {\cf20 // namespace Matchers}\par
2310 \par
2311 {\cf17 using namespace }Matchers;\par
2312 {\cf17 using }Matchers::Impl::MatcherBase;\par
2313 \par
2314 \} {\cf20 // namespace Catch}\par
2315 \par
2316 {\cf20 // end catch_matchers.h}\par
2317 {\cf20 // start catch_matchers_floating.h}\par
2318 \par
2319 {\cf21 #include <type_traits>}\par
2320 {\cf21 #include <cmath>}\par
2321 \par
2322 {\cf17 namespace }Catch \{\par
2323 {\cf17 namespace }Matchers \{\par
2324 \par
2325     {\cf17 namespace }Floating \{\par
2326 \par
2327         {\cf17 enum class} FloatingPointKind : uint8_t;\par
2328 \par
2329         {\cf17 struct }WithinAbsMatcher : MatcherBase<double> \{\par
2330             WithinAbsMatcher({\cf18 double} target, {\cf18 double} margin);\par
2331             {\cf18 bool} match({\cf18 double} {\cf17 const}& matchee) {\cf17 const override};\par
2332             std::string describe() {\cf17 const override};\par
2333         {\cf17 private}:\par
2334             {\cf18 double} m_target;\par
2335             {\cf18 double} m_margin;\par
2336         \};\par
2337 \par
2338         {\cf17 struct }WithinUlpsMatcher : MatcherBase<double> \{\par
2339             WithinUlpsMatcher({\cf18 double} target, {\cf18 int} ulps, FloatingPointKind baseType);\par
2340             {\cf18 bool} match({\cf18 double} {\cf17 const}& matchee) {\cf17 const override};\par
2341             std::string describe() {\cf17 const override};\par
2342         {\cf17 private}:\par
2343             {\cf18 double} m_target;\par
2344             {\cf18 int} m_ulps;\par
2345             FloatingPointKind m_type;\par
2346         \};\par
2347 \par
2348     \} {\cf20 // namespace Floating}\par
2349 \par
2350     {\cf20 // The following functions create the actual matcher objects.}\par
2351     {\cf20 // This allows the types to be inferred}\par
2352     Floating::WithinUlpsMatcher WithinULP({\cf18 double} target, {\cf18 int} maxUlpDiff);\par
2353     Floating::WithinUlpsMatcher WithinULP({\cf18 float} target, {\cf18 int} maxUlpDiff);\par
2354     Floating::WithinAbsMatcher WithinAbs({\cf18 double} target, {\cf18 double} margin);\par
2355 \par
2356 \} {\cf20 // namespace Matchers}\par
2357 \} {\cf20 // namespace Catch}\par
2358 \par
2359 {\cf20 // end catch_matchers_floating.h}\par
2360 {\cf20 // start catch_matchers_string.h}\par
2361 \par
2362 {\cf21 #include <string>}\par
2363 \par
2364 {\cf17 namespace }Catch \{\par
2365 {\cf17 namespace }Matchers \{\par
2366 \par
2367     {\cf17 namespace }StdString \{\par
2368 \par
2369         {\cf17 struct }CasedString\par
2370         \{\par
2371             CasedString( std::string {\cf17 const}& str, CaseSensitive::Choice caseSensitivity );\par
2372             std::string adjustString( std::string {\cf17 const}& str ) {\cf17 const};\par
2373             std::string caseSensitivitySuffix() {\cf17 const};\par
2374 \par
2375             CaseSensitive::Choice m_caseSensitivity;\par
2376             std::string m_str;\par
2377         \};\par
2378 \par
2379         {\cf17 struct }StringMatcherBase : MatcherBase<std::string> \{\par
2380             StringMatcherBase( std::string {\cf17 const}& operation, CasedString {\cf17 const}& comparator );\par
2381             std::string describe() {\cf17 const override};\par
2382 \par
2383             CasedString m_comparator;\par
2384             std::string m_operation;\par
2385         \};\par
2386 \par
2387         {\cf17 struct }EqualsMatcher : StringMatcherBase \{\par
2388             EqualsMatcher( CasedString {\cf17 const}& comparator );\par
2389             {\cf18 bool} match( std::string {\cf17 const}& source ) {\cf17 const override};\par
2390         \};\par
2391         {\cf17 struct }ContainsMatcher : StringMatcherBase \{\par
2392             ContainsMatcher( CasedString {\cf17 const}& comparator );\par
2393             {\cf18 bool} match( std::string {\cf17 const}& source ) {\cf17 const override};\par
2394         \};\par
2395         {\cf17 struct }StartsWithMatcher : StringMatcherBase \{\par
2396             StartsWithMatcher( CasedString {\cf17 const}& comparator );\par
2397             {\cf18 bool} match( std::string {\cf17 const}& source ) {\cf17 const override};\par
2398         \};\par
2399         {\cf17 struct }EndsWithMatcher : StringMatcherBase \{\par
2400             EndsWithMatcher( CasedString {\cf17 const}& comparator );\par
2401             {\cf18 bool} match( std::string {\cf17 const}& source ) {\cf17 const override};\par
2402         \};\par
2403 \par
2404         {\cf17 struct }RegexMatcher : MatcherBase<std::string> \{\par
2405             RegexMatcher( std::string regex, CaseSensitive::Choice caseSensitivity );\par
2406             {\cf18 bool} match( std::string {\cf17 const}& matchee ) {\cf17 const override};\par
2407             std::string describe() {\cf17 const override};\par
2408 \par
2409         {\cf17 private}:\par
2410             std::string m_regex;\par
2411             CaseSensitive::Choice m_caseSensitivity;\par
2412         \};\par
2413 \par
2414     \} {\cf20 // namespace StdString}\par
2415 \par
2416     {\cf20 // The following functions create the actual matcher objects.}\par
2417     {\cf20 // This allows the types to be inferred}\par
2418 \par
2419     StdString::EqualsMatcher Equals( std::string {\cf17 const}& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );\par
2420     StdString::ContainsMatcher Contains( std::string {\cf17 const}& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );\par
2421     StdString::EndsWithMatcher EndsWith( std::string {\cf17 const}& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );\par
2422     StdString::StartsWithMatcher StartsWith( std::string {\cf17 const}& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );\par
2423     StdString::RegexMatcher Matches( std::string {\cf17 const}& regex, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );\par
2424 \par
2425 \} {\cf20 // namespace Matchers}\par
2426 \} {\cf20 // namespace Catch}\par
2427 \par
2428 {\cf20 // end catch_matchers_string.h}\par
2429 {\cf20 // start catch_matchers_vector.h}\par
2430 \par
2431 {\cf21 #include <algorithm>}\par
2432 \par
2433 {\cf17 namespace }Catch \{\par
2434 {\cf17 namespace }Matchers \{\par
2435 \par
2436     {\cf17 namespace }Vector \{\par
2437         {\cf17 namespace }Detail \{\par
2438             {\cf17 template} <{\cf17 typename} InputIterator, {\cf17 typename} T>\par
2439             {\cf18 size_t} count(InputIterator first, InputIterator last, T {\cf17 const}& item) \{\par
2440                 {\cf18 size_t} cnt = 0;\par
2441                 {\cf19 for} (; first != last; ++first) \{\par
2442                     {\cf19 if} (*first == item) \{\par
2443                         ++cnt;\par
2444                     \}\par
2445                 \}\par
2446                 {\cf19 return} cnt;\par
2447             \}\par
2448             {\cf17 template} <{\cf17 typename} InputIterator, {\cf17 typename} T>\par
2449             {\cf18 bool} contains(InputIterator first, InputIterator last, T {\cf17 const}& item) \{\par
2450                 {\cf19 for} (; first != last; ++first) \{\par
2451                     {\cf19 if} (*first == item) \{\par
2452                         {\cf19 return} {\cf17 true};\par
2453                     \}\par
2454                 \}\par
2455                 {\cf19 return} {\cf17 false};\par
2456             \}\par
2457         \}\par
2458 \par
2459         {\cf17 template}<{\cf17 typename} T>\par
2460         {\cf17 struct }ContainsElementMatcher : MatcherBase<std::vector<T>> \{\par
2461 \par
2462             ContainsElementMatcher(T {\cf17 const} &comparator) : m_comparator( comparator) \{\}\par
2463 \par
2464             {\cf18 bool} match(std::vector<T> {\cf17 const} &v){\cf17  const override }\{\par
2465                 {\cf19 for} ({\cf17 auto} {\cf17 const}& el : v) \{\par
2466                     {\cf19 if} (el == m_comparator) \{\par
2467                         {\cf19 return} {\cf17 true};\par
2468                     \}\par
2469                 \}\par
2470                 {\cf19 return} {\cf17 false};\par
2471             \}\par
2472 \par
2473             std::string describe(){\cf17  const override }\{\par
2474                 {\cf19 return} {\cf22 "Contains: "} + ::Catch::Detail::stringify( m_comparator );\par
2475             \}\par
2476 \par
2477             T {\cf17 const}& m_comparator;\par
2478         \};\par
2479 \par
2480         {\cf17 template}<{\cf17 typename} T>\par
2481         {\cf17 struct }ContainsMatcher : MatcherBase<std::vector<T>> \{\par
2482 \par
2483             ContainsMatcher(std::vector<T> {\cf17 const} &comparator) : m_comparator( comparator ) \{\}\par
2484 \par
2485             {\cf18 bool} match(std::vector<T> {\cf17 const} &v){\cf17  const override }\{\par
2486                 {\cf20 // !TBD: see note in EqualsMatcher}\par
2487                 {\cf19 if} (m_comparator.size() > v.size())\par
2488                     {\cf19 return} {\cf17 false};\par
2489                 {\cf19 for} ({\cf17 auto} {\cf17 const}& comparator : m_comparator) \{\par
2490                     {\cf17 auto} present = {\cf17 false};\par
2491                     {\cf19 for} ({\cf17 const} {\cf17 auto}& el : v) \{\par
2492                         {\cf19 if} (el == comparator) \{\par
2493                             present = {\cf17 true};\par
2494                             {\cf19 break};\par
2495                         \}\par
2496                     \}\par
2497                     {\cf19 if} (!present) \{\par
2498                         {\cf19 return} {\cf17 false};\par
2499                     \}\par
2500                 \}\par
2501                 {\cf19 return} {\cf17 true};\par
2502             \}\par
2503             std::string describe(){\cf17  const override }\{\par
2504                 {\cf19 return} {\cf22 "Contains: "} + ::Catch::Detail::stringify( m_comparator );\par
2505             \}\par
2506 \par
2507             std::vector<T> {\cf17 const}& m_comparator;\par
2508         \};\par
2509 \par
2510         {\cf17 template}<{\cf17 typename} T>\par
2511         {\cf17 struct }EqualsMatcher : MatcherBase<std::vector<T>> \{\par
2512 \par
2513             EqualsMatcher(std::vector<T> {\cf17 const} &comparator) : m_comparator( comparator ) \{\}\par
2514 \par
2515             {\cf18 bool} match(std::vector<T> {\cf17 const} &v){\cf17  const override }\{\par
2516                 {\cf20 // !TBD: This currently works if all elements can be compared using !=}\par
2517                 {\cf20 // - a more general approach would be via a compare template that defaults}\par
2518                 {\cf20 // to using !=. but could be specialised for, e.g. std::vector<T> etc}\par
2519                 {\cf20 // - then just call that directly}\par
2520                 {\cf19 if} (m_comparator.size() != v.size())\par
2521                     {\cf19 return} {\cf17 false};\par
2522                 {\cf19 for} (std::size_t i = 0; i < v.size(); ++i)\par
2523                     {\cf19 if} (m_comparator[i] != v[i])\par
2524                         {\cf19 return} {\cf17 false};\par
2525                 {\cf19 return} {\cf17 true};\par
2526             \}\par
2527             std::string describe(){\cf17  const override }\{\par
2528                 {\cf19 return} {\cf22 "Equals: "} + ::Catch::Detail::stringify( m_comparator );\par
2529             \}\par
2530             std::vector<T> {\cf17 const}& m_comparator;\par
2531         \};\par
2532 \par
2533         {\cf17 template}<{\cf17 typename} T>\par
2534         {\cf17 struct }UnorderedEqualsMatcher : MatcherBase<std::vector<T>> \{\par
2535             UnorderedEqualsMatcher(std::vector<T> {\cf17 const}& target) : m_target(target) \{\}\par
2536             {\cf18 bool} match(std::vector<T> {\cf17 const}& vec){\cf17  const override }\{\par
2537                 {\cf20 // Note: This is a reimplementation of std::is_permutation,}\par
2538                 {\cf20 //       because I don't want to include <algorithm> inside the common path}\par
2539                 {\cf19 if} (m_target.size() != vec.size()) \{\par
2540                     {\cf19 return} {\cf17 false};\par
2541                 \}\par
2542                 {\cf17 auto} lfirst = m_target.begin(), llast = m_target.end();\par
2543                 {\cf17 auto} rfirst = vec.begin(), rlast = vec.end();\par
2544                 {\cf20 // Cut common prefix to optimize checking of permuted parts}\par
2545                 {\cf19 while} (lfirst != llast && *lfirst != *rfirst) \{\par
2546                     ++lfirst; ++rfirst;\par
2547                 \}\par
2548                 {\cf19 if} (lfirst == llast) \{\par
2549                     {\cf19 return} {\cf17 true};\par
2550                 \}\par
2551 \par
2552                 {\cf19 for} ({\cf17 auto} mid = lfirst; mid != llast; ++mid) \{\par
2553                     {\cf20 // Skip already counted items}\par
2554                     {\cf19 if} (Detail::contains(lfirst, mid, *mid)) \{\par
2555                         {\cf19 continue};\par
2556                     \}\par
2557                     {\cf18 size_t} num_vec = Detail::count(rfirst, rlast, *mid);\par
2558                     {\cf19 if} (num_vec == 0 || Detail::count(lfirst, llast, *mid) != num_vec) \{\par
2559                         {\cf19 return} {\cf17 false};\par
2560                     \}\par
2561                 \}\par
2562 \par
2563                 {\cf19 return} {\cf17 true};\par
2564             \}\par
2565 \par
2566             std::string describe(){\cf17  const override }\{\par
2567                 {\cf19 return} {\cf22 "UnorderedEquals: "} + ::Catch::Detail::stringify(m_target);\par
2568             \}\par
2569         {\cf17 private}:\par
2570             std::vector<T> {\cf17 const}& m_target;\par
2571         \};\par
2572 \par
2573     \} {\cf20 // namespace Vector}\par
2574 \par
2575     {\cf20 // The following functions create the actual matcher objects.}\par
2576     {\cf20 // This allows the types to be inferred}\par
2577 \par
2578     {\cf17 template}<{\cf17 typename} T>\par
2579     Vector::ContainsMatcher<T> Contains( std::vector<T> {\cf17 const}& comparator ) \{\par
2580         {\cf19 return} Vector::ContainsMatcher<T>( comparator );\par
2581     \}\par
2582 \par
2583     {\cf17 template}<{\cf17 typename} T>\par
2584     Vector::ContainsElementMatcher<T> VectorContains( T {\cf17 const}& comparator ) \{\par
2585         {\cf19 return} Vector::ContainsElementMatcher<T>( comparator );\par
2586     \}\par
2587 \par
2588     {\cf17 template}<{\cf17 typename} T>\par
2589     Vector::EqualsMatcher<T> Equals( std::vector<T> {\cf17 const}& comparator ) \{\par
2590         {\cf19 return} Vector::EqualsMatcher<T>( comparator );\par
2591     \}\par
2592 \par
2593     {\cf17 template}<{\cf17 typename} T>\par
2594     Vector::UnorderedEqualsMatcher<T> UnorderedEquals(std::vector<T> {\cf17 const}& target) \{\par
2595         {\cf19 return} Vector::UnorderedEqualsMatcher<T>(target);\par
2596     \}\par
2597 \par
2598 \} {\cf20 // namespace Matchers}\par
2599 \} {\cf20 // namespace Catch}\par
2600 \par
2601 {\cf20 // end catch_matchers_vector.h}\par
2602 {\cf17 namespace }Catch \{\par
2603 \par
2604     {\cf17 template}<{\cf17 typename} ArgT, {\cf17 typename} MatcherT>\par
2605     {\cf17 class }MatchExpr : {\cf17 public} ITransientExpression \{\par
2606         ArgT {\cf17 const}& m_arg;\par
2607         MatcherT m_matcher;\par
2608         StringRef m_matcherString;\par
2609     {\cf17 public}:\par
2610         MatchExpr( ArgT {\cf17 const}& arg, MatcherT {\cf17 const}& matcher, StringRef matcherString )\par
2611         :   ITransientExpression\{ true, matcher.match( arg ) \},\par
2612             m_arg( arg ),\par
2613             m_matcher( matcher ),\par
2614             m_matcherString( matcherString )\par
2615         \{\}\par
2616 \par
2617         {\cf18 void} streamReconstructedExpression( std::ostream &os ){\cf17  const override }\{\par
2618             {\cf17 auto} matcherAsString = m_matcher.toString();\par
2619             os << Catch::Detail::stringify( m_arg ) << {\cf23 ' '};\par
2620             {\cf19 if}( matcherAsString == Detail::unprintableString )\par
2621                 os << m_matcherString;\par
2622             {\cf19 else}\par
2623                 os << matcherAsString;\par
2624         \}\par
2625     \};\par
2626 \par
2627     {\cf17 using }StringMatcher = Matchers::Impl::MatcherBase<std::string>;\par
2628 \par
2629     {\cf18 void} handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher {\cf17 const}& matcher, StringRef matcherString  );\par
2630 \par
2631     {\cf17 template}<{\cf17 typename} ArgT, {\cf17 typename} MatcherT>\par
2632     {\cf17 auto} makeMatchExpr( ArgT {\cf17 const}& arg, MatcherT {\cf17 const}& matcher, StringRef matcherString  ) -> MatchExpr<ArgT, MatcherT> \{\par
2633         {\cf19 return} MatchExpr<ArgT, MatcherT>( arg, matcher, matcherString );\par
2634     \}\par
2635 \par
2636 \} {\cf20 // namespace Catch}\par
2637 \par
2639 {\cf21 #define INTERNAL_CHECK_THAT( macroName, matcher, resultDisposition, arg ) \\}\par
2640 {\cf21     do \{ \\}\par
2641 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(arg) ", "} CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\\par
2642         INTERNAL_CATCH_TRY \{ \\\par
2643             catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher, #matcher ) ); \\\par
2644         \} INTERNAL_CATCH_CATCH( catchAssertionHandler ) \\\par
2645         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\par
2646     \} while( false )\par
2647 \par
2649 {\cf21 #define INTERNAL_CATCH_THROWS_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \\}\par
2650 {\cf21     do \{ \\}\par
2651 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", "} CATCH_INTERNAL_STRINGIFY(exceptionType) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\\par
2652         if( catchAssertionHandler.allowThrows() ) \\\par
2653             try \{ \\\par
2654                 static_cast<void>(__VA_ARGS__ ); \\\par
2655                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\par
2656             \} \\\par
2657             catch( exceptionType const& ex ) \{ \\\par
2658                 catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher, #matcher ) ); \\\par
2659             \} \\\par
2660             catch( ... ) \{ \\\par
2661                 catchAssertionHandler.handleUnexpectedInflightException(); \\\par
2662             \} \\\par
2663         else \\\par
2664             catchAssertionHandler.handleThrowingCallSkipped(); \\\par
2665         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\par
2666     \} while( false )\par
2667 \par
2668 {\cf20 // end catch_capture_matchers.h}\par
2669 {\cf21 #endif}\par
2670 \par
2671 {\cf20 // These files are included here so the single_include script doesn't put them}\par
2672 {\cf20 // in the conditionally compiled sections}\par
2673 {\cf20 // start catch_test_case_info.h}\par
2674 \par
2675 {\cf21 #include <string>}\par
2676 {\cf21 #include <vector>}\par
2677 {\cf21 #include <memory>}\par
2678 \par
2679 {\cf21 #ifdef __clang__}\par
2680 {\cf21 #pragma clang diagnostic push}\par
2681 {\cf21 #pragma clang diagnostic ignored "-Wpadded"}\par
2682 {\cf21 #endif}\par
2683 \par
2684 {\cf17 namespace }Catch \{\par
2685 \par
2686     {\cf17 struct }ITestInvoker;\par
2687 \par
2688     {\cf17 struct }TestCaseInfo \{\par
2689         {\cf17 enum} SpecialProperties\{\par
2690             None = 0,\par
2691             IsHidden = 1 << 1,\par
2692             ShouldFail = 1 << 2,\par
2693             MayFail = 1 << 3,\par
2694             Throws = 1 << 4,\par
2695             NonPortable = 1 << 5,\par
2696             Benchmark = 1 << 6\par
2697         \};\par
2698 \par
2699         TestCaseInfo(   std::string {\cf17 const}& _name,\par
2700                         std::string {\cf17 const}& _className,\par
2701                         std::string {\cf17 const}& _description,\par
2702                         std::vector<std::string> {\cf17 const}& _tags,\par
2703                         SourceLineInfo {\cf17 const}& _lineInfo );\par
2704 \par
2705         {\cf17 friend} {\cf18 void} setTags( TestCaseInfo& testCaseInfo, std::vector<std::string> tags );\par
2706 \par
2707         {\cf18 bool} isHidden() {\cf17 const};\par
2708         {\cf18 bool} {\cf19 throws}() {\cf17 const};\par
2709         {\cf18 bool} okToFail() {\cf17 const};\par
2710         {\cf18 bool} expectedToFail() {\cf17 const};\par
2711 \par
2712         std::string tagsAsString() {\cf17 const};\par
2713 \par
2714         std::string name;\par
2715         std::string className;\par
2716         std::string description;\par
2717         std::vector<std::string> tags;\par
2718         std::vector<std::string> lcaseTags;\par
2719         SourceLineInfo lineInfo;\par
2720         SpecialProperties properties;\par
2721     \};\par
2722 \par
2723     {\cf17 class }TestCase : {\cf17 public} TestCaseInfo \{\par
2724     {\cf17 public}:\par
2725 \par
2726         TestCase( ITestInvoker* testCase, TestCaseInfo&& info );\par
2727 \par
2728         TestCase withName( std::string {\cf17 const}& _newName ) {\cf17 const};\par
2729 \par
2730         {\cf18 void} invoke() {\cf17 const};\par
2731 \par
2732         TestCaseInfo {\cf17 const}& getTestCaseInfo() {\cf17 const};\par
2733 \par
2734         {\cf18 bool} operator == ( TestCase {\cf17 const}& other ) {\cf17 const};\par
2735         {\cf18 bool} operator < ( TestCase {\cf17 const}& other ) {\cf17 const};\par
2736 \par
2737     {\cf17 private}:\par
2738         std::shared_ptr<ITestInvoker> test;\par
2739     \};\par
2740 \par
2741     TestCase makeTestCase(  ITestInvoker* testCase,\par
2742                             std::string {\cf17 const}& className,\par
2743                             NameAndTags {\cf17 const}& nameAndTags,\par
2744                             SourceLineInfo {\cf17 const}& lineInfo );\par
2745 \}\par
2746 \par
2747 {\cf21 #ifdef __clang__}\par
2748 {\cf21 #pragma clang diagnostic pop}\par
2749 {\cf21 #endif}\par
2750 \par
2751 {\cf20 // end catch_test_case_info.h}\par
2752 {\cf20 // start catch_interfaces_runner.h}\par
2753 \par
2754 {\cf17 namespace }Catch \{\par
2755 \par
2756     {\cf17 struct }IRunner \{\par
2757         {\cf17 virtual} ~IRunner();\par
2758         {\cf17 virtual} {\cf18 bool} aborting() {\cf17 const} = 0;\par
2759     \};\par
2760 \}\par
2761 \par
2762 {\cf20 // end catch_interfaces_runner.h}\par
2763 \par
2764 {\cf21 #ifdef __OBJC__}\par
2765 {\cf20 // start catch_objc.hpp}\par
2766 \par
2767 {\cf21 #import <objc/runtime.h>}\par
2768 \par
2769 {\cf21 #include <string>}\par
2770 \par
2771 {\cf20 // NB. Any general catch headers included here must be included}\par
2772 {\cf20 // in catch.hpp first to make sure they are included by the single}\par
2773 {\cf20 // header for non obj-usage}\par
2774 \par
2776 {\cf20 // This protocol is really only here for (self) documenting purposes, since}\par
2777 {\cf20 // all its methods are optional.}\par
2778 {\cf17 @protocol }OcFixture\par
2779 \par
2780 {\cf17 @optional}\par
2781 \par
2782 -(void) setUp;\par
2783 -(void) tearDown;\par
2784 \par
2785 {\cf17 @end}\par
2786 \par
2787 {\cf17 namespace }Catch \{\par
2788 \par
2789     {\cf17 class }OcMethod : {\cf17 public} ITestInvoker \{\par
2790 \par
2791     {\cf17 public}:\par
2792         OcMethod( Class cls, {\cf18 SEL} sel ) : m_cls( cls ), m_sel( sel ) \{\}\par
2793 \par
2794         {\cf17 virtual} {\cf18 void} invoke(){\cf17  const }\{\par
2795             {\cf18 id} obj = [[m_cls alloc] init];\par
2796 \par
2797             performOptionalSelector( obj, {\cf17 @selector}(setUp)  );\par
2798             performOptionalSelector( obj, m_sel );\par
2799             performOptionalSelector( obj, {\cf17 @selector}(tearDown)  );\par
2800 \par
2801             arcSafeRelease( obj );\par
2802         \}\par
2803     {\cf17 private}:\par
2804         {\cf17 virtual} ~OcMethod() \{\}\par
2805 \par
2806         Class m_cls;\par
2807         {\cf18 SEL} m_sel;\par
2808     \};\par
2809 \par
2810     {\cf17 namespace }Detail\{\par
2811 \par
2812         {\cf17 inline} std::string getAnnotation(   Class cls,\par
2813                                             std::string {\cf17 const}& annotationName,\par
2814                                             std::string {\cf17 const}& testCaseName ) \{\par
2815             NSString* selStr = [[NSString alloc] initWithFormat:@"Catch_%s_%s", annotationName.c_str(), testCaseName.c_str()];\par
2816             {\cf18 SEL} sel = NSSelectorFromString( selStr );\par
2817             arcSafeRelease( selStr );\par
2818             {\cf18 id} value = performOptionalSelector( cls, sel );\par
2819             {\cf19 if}( value )\par
2820                 {\cf19 return} [(NSString*)value UTF8String];\par
2821             {\cf19 return} {\cf22 ""};\par
2822         \}\par
2823     \}\par
2824 \par
2825     {\cf17 inline} std::size_t registerTestMethods() \{\par
2826         std::size_t noTestMethods = 0;\par
2827         {\cf18 int} noClasses = objc_getClassList( {\cf17 nullptr}, 0 );\par
2828 \par
2829         Class* classes = (CATCH_UNSAFE_UNRETAINED Class *)malloc( {\cf17 sizeof}(Class) * noClasses);\par
2830         objc_getClassList( classes, noClasses );\par
2831 \par
2832         {\cf19 for}( {\cf18 int} c = 0; c < noClasses; c++ ) \{\par
2833             Class cls = classes[c];\par
2834             \{\par
2835                 u_int count;\par
2836                 Method* methods = class_copyMethodList( cls, &count );\par
2837                 {\cf19 for}( u_int m = 0; m < count ; m++ ) \{\par
2838                     {\cf18 SEL} selector = method_getName(methods[m]);\par
2839                     std::string methodName = sel_getName(selector);\par
2840                     {\cf19 if}( startsWith( methodName, {\cf22 "Catch_TestCase_"} ) ) \{\par
2841                         std::string testCaseName = methodName.substr( 15 );\par
2842                         std::string name = Detail::getAnnotation( cls, {\cf22 "Name"}, testCaseName );\par
2843                         std::string desc = Detail::getAnnotation( cls, {\cf22 "Description"}, testCaseName );\par
2844                         {\cf17 const} {\cf18 char}* className = class_getName( cls );\par
2845 \par
2846                         getMutableRegistryHub().registerTest( makeTestCase( {\cf17 new} OcMethod( cls, selector ), className, name.c_str(), desc.c_str(), SourceLineInfo({\cf22 ""},0) ) );\par
2847                         noTestMethods++;\par
2848                     \}\par
2849                 \}\par
2850                 free(methods);\par
2851             \}\par
2852         \}\par
2853         {\cf19 return} noTestMethods;\par
2854     \}\par
2855 \par
2856 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)}\par
2857 \par
2858     {\cf17 namespace }Matchers \{\par
2859         {\cf17 namespace }Impl \{\par
2860         {\cf17 namespace }NSStringMatchers \{\par
2861 \par
2862             {\cf17 struct }StringHolder : MatcherBase<NSString*>\{\par
2863                 StringHolder( NSString* substr ) : m_substr( [substr copy] )\{\}\par
2864                 StringHolder( StringHolder {\cf17 const}& other ) : m_substr( [other.m_substr copy] )\{\}\par
2865                 StringHolder() \{\par
2866                     arcSafeRelease( m_substr );\par
2867                 \}\par
2868 \par
2869                 {\cf18 bool} match( NSString* arg ){\cf17  const override }\{\par
2870                     {\cf19 return} {\cf17 false};\par
2871                 \}\par
2872 \par
2873                 NSString* CATCH_ARC_STRONG m_substr;\par
2874             \};\par
2875 \par
2876             {\cf17 struct }Equals : StringHolder \{\par
2877                 Equals( NSString* substr ) : StringHolder( substr )\{\}\par
2878 \par
2879                 {\cf18 bool} match( NSString* str ){\cf17  const override }\{\par
2880                     {\cf19 return}  (str != nil || m_substr == nil ) &&\par
2881                             [str isEqualToString:m_substr];\par
2882                 \}\par
2883 \par
2884                 std::string describe(){\cf17  const override }\{\par
2885                     {\cf19 return} {\cf22 "equals string: "} + Catch::Detail::stringify( m_substr );\par
2886                 \}\par
2887             \};\par
2888 \par
2889             {\cf17 struct }Contains : StringHolder \{\par
2890                 Contains( NSString* substr ) : StringHolder( substr )\{\}\par
2891 \par
2892                 {\cf18 bool} match( NSString* str ){\cf17  const }\{\par
2893                     {\cf19 return}  (str != nil || m_substr == nil ) &&\par
2894                             [str rangeOfString:m_substr].location != NSNotFound;\par
2895                 \}\par
2896 \par
2897                 std::string describe(){\cf17  const override }\{\par
2898                     {\cf19 return} {\cf22 "contains string: "} + Catch::Detail::stringify( m_substr );\par
2899                 \}\par
2900             \};\par
2901 \par
2902             {\cf17 struct }StartsWith : StringHolder \{\par
2903                 StartsWith( NSString* substr ) : StringHolder( substr )\{\}\par
2904 \par
2905                 {\cf18 bool} match( NSString* str ){\cf17  const override }\{\par
2906                     {\cf19 return}  (str != nil || m_substr == nil ) &&\par
2907                             [str rangeOfString:m_substr].location == 0;\par
2908                 \}\par
2909 \par
2910                 std::string describe(){\cf17  const override }\{\par
2911                     {\cf19 return} {\cf22 "starts with: "} + Catch::Detail::stringify( m_substr );\par
2912                 \}\par
2913             \};\par
2914             {\cf17 struct }EndsWith : StringHolder \{\par
2915                 EndsWith( NSString* substr ) : StringHolder( substr )\{\}\par
2916 \par
2917                 {\cf18 bool} match( NSString* str ){\cf17  const override }\{\par
2918                     {\cf19 return}  (str != nil || m_substr == nil ) &&\par
2919                             [str rangeOfString:m_substr].location == [str length] - [m_substr length];\par
2920                 \}\par
2921 \par
2922                 std::string describe(){\cf17  const override }\{\par
2923                     {\cf19 return} {\cf22 "ends with: "} + Catch::Detail::stringify( m_substr );\par
2924                 \}\par
2925             \};\par
2926 \par
2927         \} {\cf20 // namespace NSStringMatchers}\par
2928         \} {\cf20 // namespace Impl}\par
2929 \par
2930         {\cf17 inline} Impl::NSStringMatchers::Equals\par
2931             Equals( NSString* substr )\{ {\cf19 return} Impl::NSStringMatchers::Equals( substr ); \}\par
2932 \par
2933         {\cf17 inline} Impl::NSStringMatchers::Contains\par
2934             Contains( NSString* substr )\{ {\cf19 return} Impl::NSStringMatchers::Contains( substr ); \}\par
2935 \par
2936         {\cf17 inline} Impl::NSStringMatchers::StartsWith\par
2937             StartsWith( NSString* substr )\{ {\cf19 return} Impl::NSStringMatchers::StartsWith( substr ); \}\par
2938 \par
2939         {\cf17 inline} Impl::NSStringMatchers::EndsWith\par
2940             EndsWith( NSString* substr )\{ {\cf19 return} Impl::NSStringMatchers::EndsWith( substr ); \}\par
2941 \par
2942     \} {\cf20 // namespace Matchers}\par
2943 \par
2944     {\cf17 using namespace }Matchers;\par
2945 \par
2946 {\cf21 #endif }{\cf20 // CATCH_CONFIG_DISABLE_MATCHERS}\par
2947 \par
2948 \} {\cf20 // namespace Catch}\par
2949 \par
2951 {\cf21 #define OC_MAKE_UNIQUE_NAME( root, uniqueSuffix ) root##uniqueSuffix}\par
2952 {\cf21 #define OC_TEST_CASE2( name, desc, uniqueSuffix ) \\}\par
2953 {\cf21 +(NSString*) OC_MAKE_UNIQUE_NAME( Catch_Name_test_, uniqueSuffix ) \\}\par
2954 {\cf21 \{ \\}\par
2955 {\cf21 return @ name; \\}\par
2956 {\cf21 \} \\}\par
2957 {\cf21 +(NSString*) OC_MAKE_UNIQUE_NAME( Catch_Description_test_, uniqueSuffix ) \\}\par
2958 {\cf21 \{ \\}\par
2959 {\cf21 return @ desc; \\}\par
2960 {\cf21 \} \\}\par
2961 {\cf21 -(void) OC_MAKE_UNIQUE_NAME( Catch_TestCase_test_, uniqueSuffix )}\par
2962 \par
2963 {\cf21 #define OC_TEST_CASE( name, desc ) OC_TEST_CASE2( name, desc, __LINE__ )}\par
2964 \par
2965 {\cf20 // end catch_objc.hpp}\par
2966 {\cf21 #endif}\par
2967 \par
2968 {\cf21 #ifdef CATCH_CONFIG_EXTERNAL_INTERFACES}\par
2969 {\cf20 // start catch_external_interfaces.h}\par
2970 \par
2971 {\cf20 // start catch_reporter_bases.hpp}\par
2972 \par
2973 {\cf20 // start catch_interfaces_reporter.h}\par
2974 \par
2975 {\cf20 // start catch_config.hpp}\par
2976 \par
2977 {\cf20 // start catch_test_spec_parser.h}\par
2978 \par
2979 {\cf21 #ifdef __clang__}\par
2980 {\cf21 #pragma clang diagnostic push}\par
2981 {\cf21 #pragma clang diagnostic ignored "-Wpadded"}\par
2982 {\cf21 #endif}\par
2983 \par
2984 {\cf20 // start catch_test_spec.h}\par
2985 \par
2986 {\cf21 #ifdef __clang__}\par
2987 {\cf21 #pragma clang diagnostic push}\par
2988 {\cf21 #pragma clang diagnostic ignored "-Wpadded"}\par
2989 {\cf21 #endif}\par
2990 \par
2991 {\cf20 // start catch_wildcard_pattern.h}\par
2992 \par
2993 {\cf17 namespace }Catch\par
2994 \{\par
2995     {\cf17 class }WildcardPattern \{\par
2996         {\cf17 enum} WildcardPosition \{\par
2997             NoWildcard = 0,\par
2998             WildcardAtStart = 1,\par
2999             WildcardAtEnd = 2,\par
3000             WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd\par
3001         \};\par
3002 \par
3003     {\cf17 public}:\par
3004 \par
3005         WildcardPattern( std::string {\cf17 const}& pattern, CaseSensitive::Choice caseSensitivity );\par
3006         {\cf17 virtual} ~WildcardPattern() = {\cf19 default};\par
3007         {\cf17 virtual} {\cf18 bool} matches( std::string {\cf17 const}& str ) {\cf17 const};\par
3008 \par
3009     {\cf17 private}:\par
3010         std::string adjustCase( std::string {\cf17 const}& str ) {\cf17 const};\par
3011         CaseSensitive::Choice m_caseSensitivity;\par
3012         WildcardPosition m_wildcard = NoWildcard;\par
3013         std::string m_pattern;\par
3014     \};\par
3015 \}\par
3016 \par
3017 {\cf20 // end catch_wildcard_pattern.h}\par
3018 {\cf21 #include <string>}\par
3019 {\cf21 #include <vector>}\par
3020 {\cf21 #include <memory>}\par
3021 \par
3022 {\cf17 namespace }Catch \{\par
3023 \par
3024     {\cf17 class }TestSpec \{\par
3025         {\cf17 struct }Pattern \{\par
3026             {\cf17 virtual} ~Pattern();\par
3027             {\cf17 virtual} {\cf18 bool} matches( TestCaseInfo {\cf17 const}& testCase ) {\cf17 const} = 0;\par
3028         \};\par
3029         {\cf17 using }PatternPtr = std::shared_ptr<Pattern>;\par
3030 \par
3031         {\cf17 class }NamePattern : {\cf17 public} Pattern \{\par
3032         {\cf17 public}:\par
3033             NamePattern( std::string {\cf17 const}& name );\par
3034             {\cf17 virtual} ~NamePattern();\par
3035             {\cf17 virtual} {\cf18 bool} matches( TestCaseInfo {\cf17 const}& testCase ) {\cf17 const override};\par
3036         {\cf17 private}:\par
3037             WildcardPattern m_wildcardPattern;\par
3038         \};\par
3039 \par
3040         {\cf17 class }TagPattern : {\cf17 public} Pattern \{\par
3041         {\cf17 public}:\par
3042             TagPattern( std::string {\cf17 const}& tag );\par
3043             {\cf17 virtual} ~TagPattern();\par
3044             {\cf17 virtual} {\cf18 bool} matches( TestCaseInfo {\cf17 const}& testCase ) {\cf17 const override};\par
3045         {\cf17 private}:\par
3046             std::string m_tag;\par
3047         \};\par
3048 \par
3049         {\cf17 class }ExcludedPattern : {\cf17 public} Pattern \{\par
3050         {\cf17 public}:\par
3051             ExcludedPattern( PatternPtr {\cf17 const}& underlyingPattern );\par
3052             {\cf17 virtual} ~ExcludedPattern();\par
3053             {\cf17 virtual} {\cf18 bool} matches( TestCaseInfo {\cf17 const}& testCase ) {\cf17 const override};\par
3054         {\cf17 private}:\par
3055             PatternPtr m_underlyingPattern;\par
3056         \};\par
3057 \par
3058         {\cf17 struct }Filter \{\par
3059             std::vector<PatternPtr> m_patterns;\par
3060 \par
3061             {\cf18 bool} matches( TestCaseInfo {\cf17 const}& testCase ) {\cf17 const};\par
3062         \};\par
3063 \par
3064     {\cf17 public}:\par
3065         {\cf18 bool} hasFilters() {\cf17 const};\par
3066         {\cf18 bool} matches( TestCaseInfo {\cf17 const}& testCase ) {\cf17 const};\par
3067 \par
3068     {\cf17 private}:\par
3069         std::vector<Filter> m_filters;\par
3070 \par
3071         {\cf17 friend} {\cf17 class }TestSpecParser;\par
3072     \};\par
3073 \}\par
3074 \par
3075 {\cf21 #ifdef __clang__}\par
3076 {\cf21 #pragma clang diagnostic pop}\par
3077 {\cf21 #endif}\par
3078 \par
3079 {\cf20 // end catch_test_spec.h}\par
3080 {\cf20 // start catch_interfaces_tag_alias_registry.h}\par
3081 \par
3082 {\cf21 #include <string>}\par
3083 \par
3084 {\cf17 namespace }Catch \{\par
3085 \par
3086     {\cf17 struct }TagAlias;\par
3087 \par
3088     {\cf17 struct }ITagAliasRegistry \{\par
3089         {\cf17 virtual} ~ITagAliasRegistry();\par
3090         {\cf20 // Nullptr if not present}\par
3091         {\cf17 virtual} TagAlias {\cf17 const}* find( std::string {\cf17 const}& alias ) {\cf17 const} = 0;\par
3092         {\cf17 virtual} std::string expandAliases( std::string {\cf17 const}& unexpandedTestSpec ) {\cf17 const} = 0;\par
3093 \par
3094         {\cf17 static} ITagAliasRegistry {\cf17 const}& get();\par
3095     \};\par
3096 \par
3097 \} {\cf20 // end namespace Catch}\par
3098 \par
3099 {\cf20 // end catch_interfaces_tag_alias_registry.h}\par
3100 {\cf17 namespace }Catch \{\par
3101 \par
3102     {\cf17 class }TestSpecParser \{\par
3103         {\cf17 enum} Mode\{ None, Name, QuotedName, Tag, EscapedName \};\par
3104         Mode m_mode = None;\par
3105         {\cf18 bool} m_exclusion = {\cf17 false};\par
3106         std::size_t m_start = std::string::npos, m_pos = 0;\par
3107         std::string m_arg;\par
3108         std::vector<std::size_t> m_escapeChars;\par
3109         TestSpec::Filter m_currentFilter;\par
3110         TestSpec m_testSpec;\par
3111         ITagAliasRegistry {\cf17 const}* m_tagAliases = {\cf17 nullptr};\par
3112 \par
3113     {\cf17 public}:\par
3114         TestSpecParser( ITagAliasRegistry {\cf17 const}& tagAliases );\par
3115 \par
3116         TestSpecParser& parse( std::string {\cf17 const}& arg );\par
3117         TestSpec testSpec();\par
3118 \par
3119     {\cf17 private}:\par
3120         {\cf18 void} visitChar( {\cf18 char} c );\par
3121         {\cf18 void} startNewMode( Mode mode, std::size_t start );\par
3122         {\cf18 void} escape();\par
3123         std::string subString() {\cf17 const};\par
3124 \par
3125         {\cf17 template}<{\cf17 typename} T>\par
3126         {\cf18 void} addPattern() \{\par
3127             std::string token = subString();\par
3128             {\cf19 for}( std::size_t i = 0; i < m_escapeChars.size(); ++i )\par
3129                 token = token.substr( 0, m_escapeChars[i]-m_start-i ) + token.substr( m_escapeChars[i]-m_start-i+1 );\par
3130             m_escapeChars.clear();\par
3131             {\cf19 if}( startsWith( token, {\cf22 "exclude:"} ) ) \{\par
3132                 m_exclusion = {\cf17 true};\par
3133                 token = token.substr( 8 );\par
3134             \}\par
3135             {\cf19 if}( !token.empty() ) \{\par
3136                 TestSpec::PatternPtr pattern = std::make_shared<T>( token );\par
3137                 if( m_exclusion )\par
3138                     pattern = std::make_shared<TestSpec::ExcludedPattern>( pattern );\par
3139                 m_currentFilter.m_patterns.push_back( pattern );\par
3140             \}\par
3141             m_exclusion = {\cf17 false};\par
3142             m_mode = None;\par
3143         \}\par
3144 \par
3145         {\cf18 void} addFilter();\par
3146     \};\par
3147     TestSpec parseTestSpec( std::string {\cf17 const}& arg );\par
3148 \par
3149 \} {\cf20 // namespace Catch}\par
3150 \par
3151 {\cf21 #ifdef __clang__}\par
3152 {\cf21 #pragma clang diagnostic pop}\par
3153 {\cf21 #endif}\par
3154 \par
3155 {\cf20 // end catch_test_spec_parser.h}\par
3156 {\cf20 // start catch_interfaces_config.h}\par
3157 \par
3158 {\cf21 #include <iosfwd>}\par
3159 {\cf21 #include <string>}\par
3160 {\cf21 #include <vector>}\par
3161 {\cf21 #include <memory>}\par
3162 \par
3163 {\cf17 namespace }Catch \{\par
3164 \par
3165     {\cf17 enum class} Verbosity \{\par
3166         Quiet = 0,\par
3167         Normal,\par
3168         High\par
3169     \};\par
3170 \par
3171     {\cf17 struct }WarnAbout \{ {\cf17 enum} What \{\par
3172         Nothing = 0x00,\par
3173         NoAssertions = 0x01,\par
3174         NoTests = 0x02\par
3175     \}; \};\par
3176 \par
3177     {\cf17 struct }ShowDurations \{ {\cf17 enum} OrNot \{\par
3178         DefaultForReporter,\par
3179         Always,\par
3180         Never\par
3181     \}; \};\par
3182     {\cf17 struct }RunTests \{ {\cf17 enum} InWhatOrder \{\par
3183         InDeclarationOrder,\par
3184         InLexicographicalOrder,\par
3185         InRandomOrder\par
3186     \}; \};\par
3187     {\cf17 struct }UseColour \{ {\cf17 enum} YesOrNo \{\par
3188         Auto,\par
3189         Yes,\par
3190         No\par
3191     \}; \};\par
3192     {\cf17 struct }WaitForKeypress \{ {\cf17 enum} When \{\par
3193         Never,\par
3194         BeforeStart = 1,\par
3195         BeforeExit = 2,\par
3196         BeforeStartAndExit = BeforeStart | BeforeExit\par
3197     \}; \};\par
3198 \par
3199     {\cf17 class }TestSpec;\par
3200 \par
3201     {\cf17 struct }IConfig : NonCopyable \{\par
3202 \par
3203         {\cf17 virtual} ~IConfig();\par
3204 \par
3205         {\cf17 virtual} {\cf18 bool} allowThrows() {\cf17 const} = 0;\par
3206         {\cf17 virtual} std::ostream& stream() {\cf17 const} = 0;\par
3207         {\cf17 virtual} std::string name() {\cf17 const} = 0;\par
3208         {\cf17 virtual} {\cf18 bool} includeSuccessfulResults() {\cf17 const} = 0;\par
3209         {\cf17 virtual} {\cf18 bool} shouldDebugBreak() {\cf17 const} = 0;\par
3210         {\cf17 virtual} {\cf18 bool} warnAboutMissingAssertions() {\cf17 const} = 0;\par
3211         {\cf17 virtual} {\cf18 bool} warnAboutNoTests() {\cf17 const} = 0;\par
3212         {\cf17 virtual} {\cf18 int} abortAfter() {\cf17 const} = 0;\par
3213         {\cf17 virtual} {\cf18 bool} showInvisibles() {\cf17 const} = 0;\par
3214         {\cf17 virtual} ShowDurations::OrNot showDurations() {\cf17 const} = 0;\par
3215         {\cf17 virtual} TestSpec {\cf17 const}& testSpec() {\cf17 const} = 0;\par
3216         {\cf17 virtual} {\cf18 bool} hasTestFilters() {\cf17 const} = 0;\par
3217         {\cf17 virtual} RunTests::InWhatOrder runOrder() {\cf17 const} = 0;\par
3218         {\cf17 virtual} {\cf18 unsigned} {\cf18 int} rngSeed() {\cf17 const} = 0;\par
3219         {\cf17 virtual} {\cf18 int} benchmarkResolutionMultiple() {\cf17 const} = 0;\par
3220         {\cf17 virtual} UseColour::YesOrNo useColour() {\cf17 const} = 0;\par
3221         {\cf17 virtual} std::vector<std::string> {\cf17 const}& getSectionsToRun() {\cf17 const} = 0;\par
3222         {\cf17 virtual} Verbosity verbosity() {\cf17 const} = 0;\par
3223     \};\par
3224 \par
3225     {\cf17 using }IConfigPtr = std::shared_ptr<IConfig const>;\par
3226 \}\par
3227 \par
3228 {\cf20 // end catch_interfaces_config.h}\par
3229 {\cf20 // Libstdc++ doesn't like incomplete classes for unique_ptr}\par
3230 \par
3231 {\cf21 #include <memory>}\par
3232 {\cf21 #include <vector>}\par
3233 {\cf21 #include <string>}\par
3234 \par
3235 {\cf21 #ifndef CATCH_CONFIG_CONSOLE_WIDTH}\par
3236 {\cf21 #define CATCH_CONFIG_CONSOLE_WIDTH 80}\par
3237 {\cf21 #endif}\par
3238 \par
3239 {\cf17 namespace }Catch \{\par
3240 \par
3241     {\cf17 struct }IStream;\par
3242 \par
3243     {\cf17 struct }ConfigData \{\par
3244         {\cf18 bool} listTests = {\cf17 false};\par
3245         {\cf18 bool} listTags = {\cf17 false};\par
3246         {\cf18 bool} listReporters = {\cf17 false};\par
3247         {\cf18 bool} listTestNamesOnly = {\cf17 false};\par
3248 \par
3249         {\cf18 bool} showSuccessfulTests = {\cf17 false};\par
3250         {\cf18 bool} shouldDebugBreak = {\cf17 false};\par
3251         {\cf18 bool} noThrow = {\cf17 false};\par
3252         {\cf18 bool} showHelp = {\cf17 false};\par
3253         {\cf18 bool} showInvisibles = {\cf17 false};\par
3254         {\cf18 bool} filenamesAsTags = {\cf17 false};\par
3255         {\cf18 bool} libIdentify = {\cf17 false};\par
3256 \par
3257         {\cf18 int} abortAfter = -1;\par
3258         {\cf18 unsigned} {\cf18 int} rngSeed = 0;\par
3259         {\cf18 int} benchmarkResolutionMultiple = 100;\par
3260 \par
3261         Verbosity verbosity = Verbosity::Normal;\par
3262         WarnAbout::What warnings = WarnAbout::Nothing;\par
3263         ShowDurations::OrNot showDurations = ShowDurations::DefaultForReporter;\par
3264         RunTests::InWhatOrder runOrder = RunTests::InDeclarationOrder;\par
3265         UseColour::YesOrNo useColour = UseColour::Auto;\par
3266         WaitForKeypress::When waitForKeypress = WaitForKeypress::Never;\par
3267 \par
3268         std::string outputFilename;\par
3269         std::string name;\par
3270         std::string processName;\par
3271 \par
3272         std::vector<std::string> reporterNames;\par
3273         std::vector<std::string> testsOrTags;\par
3274         std::vector<std::string> sectionsToRun;\par
3275     \};\par
3276 \par
3277     {\cf17 class }Config : {\cf17 public} IConfig \{\par
3278     {\cf17 public}:\par
3279 \par
3280         Config() = {\cf19 default};\par
3281         Config( ConfigData {\cf17 const}& data );\par
3282         {\cf17 virtual} ~Config() = {\cf19 default};\par
3283 \par
3284         std::string {\cf17 const}& getFilename() {\cf17 const};\par
3285 \par
3286         {\cf18 bool} listTests() {\cf17 const};\par
3287         {\cf18 bool} listTestNamesOnly() {\cf17 const};\par
3288         {\cf18 bool} listTags() {\cf17 const};\par
3289         {\cf18 bool} listReporters() {\cf17 const};\par
3290 \par
3291         std::string getProcessName() {\cf17 const};\par
3292 \par
3293         std::vector<std::string> {\cf17 const}& getReporterNames() {\cf17 const};\par
3294         std::vector<std::string> {\cf17 const}& getTestsOrTags() {\cf17 const};\par
3295         std::vector<std::string> {\cf17 const}& getSectionsToRun() {\cf17 const override};\par
3296 \par
3297         {\cf17 virtual} TestSpec {\cf17 const}& testSpec() {\cf17 const override};\par
3298         {\cf18 bool} hasTestFilters() {\cf17 const override};\par
3299 \par
3300         {\cf18 bool} showHelp() {\cf17 const};\par
3301 \par
3302         {\cf20 // IConfig interface}\par
3303         {\cf18 bool} allowThrows() {\cf17 const override};\par
3304         std::ostream& stream() {\cf17 const override};\par
3305         std::string name() {\cf17 const override};\par
3306         {\cf18 bool} includeSuccessfulResults() {\cf17 const override};\par
3307         {\cf18 bool} warnAboutMissingAssertions() {\cf17 const override};\par
3308         {\cf18 bool} warnAboutNoTests() {\cf17 const override};\par
3309         ShowDurations::OrNot showDurations() {\cf17 const override};\par
3310         RunTests::InWhatOrder runOrder() {\cf17 const override};\par
3311         {\cf18 unsigned} {\cf18 int} rngSeed() {\cf17 const override};\par
3312         {\cf18 int} benchmarkResolutionMultiple() {\cf17 const override};\par
3313         UseColour::YesOrNo useColour() {\cf17 const override};\par
3314         {\cf18 bool} shouldDebugBreak() {\cf17 const override};\par
3315         {\cf18 int} abortAfter() {\cf17 const override};\par
3316         {\cf18 bool} showInvisibles() {\cf17 const override};\par
3317         Verbosity verbosity() {\cf17 const override};\par
3318 \par
3319     {\cf17 private}:\par
3320 \par
3321         IStream {\cf17 const}* openStream();\par
3322         ConfigData m_data;\par
3323 \par
3324         std::unique_ptr<IStream const> m_stream;\par
3325         TestSpec m_testSpec;\par
3326         {\cf18 bool} m_hasTestFilters = {\cf17 false};\par
3327     \};\par
3328 \par
3329 \} {\cf20 // end namespace Catch}\par
3330 \par
3331 {\cf20 // end catch_config.hpp}\par
3332 {\cf20 // start catch_assertionresult.h}\par
3333 \par
3334 {\cf21 #include <string>}\par
3335 \par
3336 {\cf17 namespace }Catch \{\par
3337 \par
3338     {\cf17 struct }AssertionResultData\par
3339     \{\par
3340         AssertionResultData() = {\cf17 delete};\par
3341 \par
3342         AssertionResultData( ResultWas::OfType _resultType, LazyExpression {\cf17 const}& _lazyExpression );\par
3343 \par
3344         std::string message;\par
3345         {\cf17 mutable} std::string reconstructedExpression;\par
3346         LazyExpression lazyExpression;\par
3347         ResultWas::OfType resultType;\par
3348 \par
3349         std::string reconstructExpression() {\cf17 const};\par
3350     \};\par
3351 \par
3352     {\cf17 class }AssertionResult \{\par
3353     {\cf17 public}:\par
3354         AssertionResult() = {\cf17 delete};\par
3355         AssertionResult( AssertionInfo {\cf17 const}& info, AssertionResultData {\cf17 const}& data );\par
3356 \par
3357         {\cf18 bool} isOk() {\cf17 const};\par
3358         {\cf18 bool} succeeded() {\cf17 const};\par
3359         ResultWas::OfType getResultType() {\cf17 const};\par
3360         {\cf18 bool} hasExpression() {\cf17 const};\par
3361         {\cf18 bool} hasMessage() {\cf17 const};\par
3362         std::string getExpression() {\cf17 const};\par
3363         std::string getExpressionInMacro() {\cf17 const};\par
3364         {\cf18 bool} hasExpandedExpression() {\cf17 const};\par
3365         std::string getExpandedExpression() {\cf17 const};\par
3366         std::string getMessage() {\cf17 const};\par
3367         SourceLineInfo getSourceInfo() {\cf17 const};\par
3368         StringRef getTestMacroName() {\cf17 const};\par
3369 \par
3370     {\cf20 //protected:}\par
3371         AssertionInfo m_info;\par
3372         AssertionResultData m_resultData;\par
3373     \};\par
3374 \par
3375 \} {\cf20 // end namespace Catch}\par
3376 \par
3377 {\cf20 // end catch_assertionresult.h}\par
3378 {\cf20 // start catch_option.hpp}\par
3379 \par
3380 {\cf17 namespace }Catch \{\par
3381 \par
3382     {\cf20 // An optional type}\par
3383     {\cf17 template}<{\cf17 typename} T>\par
3384     {\cf17 class }Option \{\par
3385     {\cf17 public}:\par
3386         Option() : nullableValue( nullptr ) \{\}\par
3387         Option( T {\cf17 const}& _value )\par
3388         : nullableValue( new( storage ) T( _value ) )\par
3389         \{\}\par
3390         Option( Option {\cf17 const}& _other )\par
3391         : nullableValue( _other ? new( storage ) T( *_other ) : nullptr )\par
3392         \{\}\par
3393 \par
3394         ~Option() \{\par
3395             reset();\par
3396         \}\par
3397 \par
3398         Option& operator= ( Option {\cf17 const}& _other ) \{\par
3399             {\cf19 if}( &_other != {\cf17 this} ) \{\par
3400                 reset();\par
3401                 {\cf19 if}( _other )\par
3402                     nullableValue = {\cf17 new}( storage ) T( *_other );\par
3403             \}\par
3404             {\cf19 return} *{\cf17 this};\par
3405         \}\par
3406         Option& operator = ( T {\cf17 const}& _value ) \{\par
3407             reset();\par
3408             nullableValue = {\cf17 new}( storage ) T( _value );\par
3409             {\cf19 return} *{\cf17 this};\par
3410         \}\par
3411 \par
3412         {\cf18 void} reset() \{\par
3413             {\cf19 if}( nullableValue )\par
3414                 nullableValue->~T();\par
3415             nullableValue = {\cf17 nullptr};\par
3416         \}\par
3417 \par
3418         T& operator*() \{ {\cf19 return} *nullableValue; \}\par
3419         T {\cf17 const}& operator*(){\cf17  const }\{ {\cf19 return} *nullableValue; \}\par
3420         T* operator->() \{ {\cf19 return} nullableValue; \}\par
3421         {\cf17 const} T* operator->(){\cf17  const }\{ {\cf19 return} nullableValue; \}\par
3422 \par
3423         T valueOr( T {\cf17 const}& defaultValue ){\cf17  const }\{\par
3424             {\cf19 return} nullableValue ? *nullableValue : defaultValue;\par
3425         \}\par
3426 \par
3427         {\cf18 bool} some(){\cf17  const }\{ {\cf19 return} nullableValue != {\cf17 nullptr}; \}\par
3428         {\cf18 bool} none(){\cf17  const }\{ {\cf19 return} nullableValue == {\cf17 nullptr}; \}\par
3429 \par
3430         {\cf18 bool} operator !(){\cf17  const }\{ {\cf19 return} nullableValue == {\cf17 nullptr}; \}\par
3431         {\cf17 explicit} {\cf17 operator} bool(){\cf17  const }\{\par
3432             {\cf19 return} some();\par
3433         \}\par
3434 \par
3435     {\cf17 private}:\par
3436         T *nullableValue;\par
3437         {\cf17 alignas}({\cf17 alignof}(T)) {\cf18 char} storage[sizeof(T)];\par
3438     \};\par
3439 \par
3440 \} {\cf20 // end namespace Catch}\par
3441 \par
3442 {\cf20 // end catch_option.hpp}\par
3443 {\cf21 #include <string>}\par
3444 {\cf21 #include <iosfwd>}\par
3445 {\cf21 #include <map>}\par
3446 {\cf21 #include <set>}\par
3447 {\cf21 #include <memory>}\par
3448 \par
3449 {\cf17 namespace }Catch \{\par
3450 \par
3451     {\cf17 struct }ReporterConfig \{\par
3452         {\cf17 explicit} ReporterConfig( IConfigPtr {\cf17 const}& _fullConfig );\par
3453 \par
3454         ReporterConfig( IConfigPtr {\cf17 const}& _fullConfig, std::ostream& _stream );\par
3455 \par
3456         std::ostream& stream() {\cf17 const};\par
3457         IConfigPtr fullConfig() {\cf17 const};\par
3458 \par
3459     {\cf17 private}:\par
3460         std::ostream* m_stream;\par
3461         IConfigPtr m_fullConfig;\par
3462     \};\par
3463 \par
3464     {\cf17 struct }ReporterPreferences \{\par
3465         {\cf18 bool} shouldRedirectStdOut = {\cf17 false};\par
3466     \};\par
3467 \par
3468     {\cf17 template}<{\cf17 typename} T>\par
3469     {\cf17 struct }LazyStat : Option<T> \{\par
3470         LazyStat& operator=( T {\cf17 const}& _value ) \{\par
3471             Option<T>::operator=( _value );\par
3472             used = {\cf17 false};\par
3473             {\cf19 return} *{\cf17 this};\par
3474         \}\par
3475         {\cf18 void} reset() \{\par
3476             Option<T>::reset();\par
3477             used = {\cf17 false};\par
3478         \}\par
3479         {\cf18 bool} used = {\cf17 false};\par
3480     \};\par
3481 \par
3482     {\cf17 struct }TestRunInfo \{\par
3483         TestRunInfo( std::string {\cf17 const}& _name );\par
3484         std::string name;\par
3485     \};\par
3486     {\cf17 struct }GroupInfo \{\par
3487         GroupInfo(  std::string {\cf17 const}& _name,\par
3488                     std::size_t _groupIndex,\par
3489                     std::size_t _groupsCount );\par
3490 \par
3491         std::string name;\par
3492         std::size_t groupIndex;\par
3493         std::size_t groupsCounts;\par
3494     \};\par
3495 \par
3496     {\cf17 struct }AssertionStats \{\par
3497         AssertionStats( AssertionResult {\cf17 const}& _assertionResult,\par
3498                         std::vector<MessageInfo> {\cf17 const}& _infoMessages,\par
3499                         Totals {\cf17 const}& _totals );\par
3500 \par
3501         AssertionStats( AssertionStats {\cf17 const}& )              = {\cf19 default};\par
3502         AssertionStats( AssertionStats && )                  = {\cf19 default};\par
3503         AssertionStats& operator = ( AssertionStats {\cf17 const}& ) = {\cf19 default};\par
3504         AssertionStats& operator = ( AssertionStats && )     = {\cf19 default};\par
3505         {\cf17 virtual} ~AssertionStats();\par
3506 \par
3507         AssertionResult assertionResult;\par
3508         std::vector<MessageInfo> infoMessages;\par
3509         Totals totals;\par
3510     \};\par
3511 \par
3512     {\cf17 struct }SectionStats \{\par
3513         SectionStats(   SectionInfo {\cf17 const}& _sectionInfo,\par
3514                         Counts {\cf17 const}& _assertions,\par
3515                         {\cf18 double} _durationInSeconds,\par
3516                         {\cf18 bool} _missingAssertions );\par
3517         SectionStats( SectionStats {\cf17 const}& )              = {\cf19 default};\par
3518         SectionStats( SectionStats && )                  = {\cf19 default};\par
3519         SectionStats& operator = ( SectionStats {\cf17 const}& ) = {\cf19 default};\par
3520         SectionStats& operator = ( SectionStats && )     = {\cf19 default};\par
3521         {\cf17 virtual} ~SectionStats();\par
3522 \par
3523         SectionInfo sectionInfo;\par
3524         Counts assertions;\par
3525         {\cf18 double} durationInSeconds;\par
3526         {\cf18 bool} missingAssertions;\par
3527     \};\par
3528 \par
3529     {\cf17 struct }TestCaseStats \{\par
3530         TestCaseStats(  TestCaseInfo {\cf17 const}& _testInfo,\par
3531                         Totals {\cf17 const}& _totals,\par
3532                         std::string {\cf17 const}& _stdOut,\par
3533                         std::string {\cf17 const}& _stdErr,\par
3534                         {\cf18 bool} _aborting );\par
3535 \par
3536         TestCaseStats( TestCaseStats {\cf17 const}& )              = {\cf19 default};\par
3537         TestCaseStats( TestCaseStats && )                  = {\cf19 default};\par
3538         TestCaseStats& operator = ( TestCaseStats {\cf17 const}& ) = {\cf19 default};\par
3539         TestCaseStats& operator = ( TestCaseStats && )     = {\cf19 default};\par
3540         {\cf17 virtual} ~TestCaseStats();\par
3541 \par
3542         TestCaseInfo testInfo;\par
3543         Totals totals;\par
3544         std::string stdOut;\par
3545         std::string stdErr;\par
3546         {\cf18 bool} aborting;\par
3547     \};\par
3548 \par
3549     {\cf17 struct }TestGroupStats \{\par
3550         TestGroupStats( GroupInfo {\cf17 const}& _groupInfo,\par
3551                         Totals {\cf17 const}& _totals,\par
3552                         {\cf18 bool} _aborting );\par
3553         TestGroupStats( GroupInfo {\cf17 const}& _groupInfo );\par
3554 \par
3555         TestGroupStats( TestGroupStats {\cf17 const}& )              = {\cf19 default};\par
3556         TestGroupStats( TestGroupStats && )                  = {\cf19 default};\par
3557         TestGroupStats& operator = ( TestGroupStats {\cf17 const}& ) = {\cf19 default};\par
3558         TestGroupStats& operator = ( TestGroupStats && )     = {\cf19 default};\par
3559         {\cf17 virtual} ~TestGroupStats();\par
3560 \par
3561         GroupInfo groupInfo;\par
3562         Totals totals;\par
3563         {\cf18 bool} aborting;\par
3564     \};\par
3565 \par
3566     {\cf17 struct }TestRunStats \{\par
3567         TestRunStats(   TestRunInfo {\cf17 const}& _runInfo,\par
3568                         Totals {\cf17 const}& _totals,\par
3569                         {\cf18 bool} _aborting );\par
3570 \par
3571         TestRunStats( TestRunStats {\cf17 const}& )              = {\cf19 default};\par
3572         TestRunStats( TestRunStats && )                  = {\cf19 default};\par
3573         TestRunStats& operator = ( TestRunStats {\cf17 const}& ) = {\cf19 default};\par
3574         TestRunStats& operator = ( TestRunStats && )     = {\cf19 default};\par
3575         {\cf17 virtual} ~TestRunStats();\par
3576 \par
3577         TestRunInfo runInfo;\par
3578         Totals totals;\par
3579         {\cf18 bool} aborting;\par
3580     \};\par
3581 \par
3582     {\cf17 struct }BenchmarkInfo \{\par
3583         std::string name;\par
3584     \};\par
3585     {\cf17 struct }BenchmarkStats \{\par
3586         BenchmarkInfo info;\par
3587         std::size_t iterations;\par
3588         uint64_t elapsedTimeInNanoseconds;\par
3589     \};\par
3590 \par
3591     {\cf17 struct }IStreamingReporter \{\par
3592         {\cf17 virtual} ~IStreamingReporter() = {\cf19 default};\par
3593 \par
3594         {\cf20 // Implementing class must also provide the following static methods:}\par
3595         {\cf20 // static std::string getDescription();}\par
3596         {\cf20 // static std::set<Verbosity> getSupportedVerbosities()}\par
3597 \par
3598         {\cf17 virtual} ReporterPreferences getPreferences() {\cf17 const} = 0;\par
3599 \par
3600         {\cf17 virtual} {\cf18 void} noMatchingTestCases( std::string {\cf17 const}& spec ) = 0;\par
3601 \par
3602         {\cf17 virtual} {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& testRunInfo ) = 0;\par
3603         {\cf17 virtual} {\cf18 void} testGroupStarting( GroupInfo {\cf17 const}& groupInfo ) = 0;\par
3604 \par
3605         {\cf17 virtual} {\cf18 void} testCaseStarting( TestCaseInfo {\cf17 const}& testInfo ) = 0;\par
3606         {\cf17 virtual} {\cf18 void} sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) = 0;\par
3607 \par
3608         {\cf20 // *** experimental ***}\par
3609         {\cf17 virtual} {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& ) \{\}\par
3610 \par
3611         {\cf17 virtual} {\cf18 void} assertionStarting( AssertionInfo {\cf17 const}& assertionInfo ) = 0;\par
3612 \par
3613         {\cf20 // The return value indicates if the messages buffer should be cleared:}\par
3614         {\cf17 virtual} {\cf18 bool} assertionEnded( AssertionStats {\cf17 const}& assertionStats ) = 0;\par
3615 \par
3616         {\cf20 // *** experimental ***}\par
3617         {\cf17 virtual} {\cf18 void} benchmarkEnded( BenchmarkStats {\cf17 const}& ) \{\}\par
3618 \par
3619         {\cf17 virtual} {\cf18 void} sectionEnded( SectionStats {\cf17 const}& sectionStats ) = 0;\par
3620         {\cf17 virtual} {\cf18 void} testCaseEnded( TestCaseStats {\cf17 const}& testCaseStats ) = 0;\par
3621         {\cf17 virtual} {\cf18 void} testGroupEnded( TestGroupStats {\cf17 const}& testGroupStats ) = 0;\par
3622         {\cf17 virtual} {\cf18 void} testRunEnded( TestRunStats {\cf17 const}& testRunStats ) = 0;\par
3623 \par
3624         {\cf17 virtual} {\cf18 void} skipTest( TestCaseInfo {\cf17 const}& testInfo ) = 0;\par
3625 \par
3626         {\cf20 // Default empty implementation provided}\par
3627         {\cf17 virtual} {\cf18 void} fatalErrorEncountered( StringRef name );\par
3628 \par
3629         {\cf17 virtual} {\cf18 bool} isMulti() {\cf17 const};\par
3630     \};\par
3631     {\cf17 using }IStreamingReporterPtr = std::unique_ptr<IStreamingReporter>;\par
3632 \par
3633     {\cf17 struct }IReporterFactory \{\par
3634         {\cf17 virtual} ~IReporterFactory();\par
3635         {\cf17 virtual} IStreamingReporterPtr create( ReporterConfig {\cf17 const}& config ) {\cf17 const} = 0;\par
3636         {\cf17 virtual} std::string getDescription() {\cf17 const} = 0;\par
3637     \};\par
3638     {\cf17 using }IReporterFactoryPtr = std::shared_ptr<IReporterFactory>;\par
3639 \par
3640     {\cf17 struct }IReporterRegistry \{\par
3641         {\cf17 using }FactoryMap = std::map<std::string, IReporterFactoryPtr>;\par
3642         {\cf17 using }Listeners = std::vector<IReporterFactoryPtr>;\par
3643 \par
3644         {\cf17 virtual} ~IReporterRegistry();\par
3645         {\cf17 virtual} IStreamingReporterPtr create( std::string {\cf17 const}& name, IConfigPtr {\cf17 const}& config ) {\cf17 const} = 0;\par
3646         {\cf17 virtual} FactoryMap {\cf17 const}& getFactories() {\cf17 const} = 0;\par
3647         {\cf17 virtual} Listeners {\cf17 const}& getListeners() {\cf17 const} = 0;\par
3648     \};\par
3649 \par
3650     {\cf18 void} addReporter( IStreamingReporterPtr& existingReporter, IStreamingReporterPtr&& additionalReporter );\par
3651 \par
3652 \} {\cf20 // end namespace Catch}\par
3653 \par
3654 {\cf20 // end catch_interfaces_reporter.h}\par
3655 {\cf21 #include <algorithm>}\par
3656 {\cf21 #include <cstring>}\par
3657 {\cf21 #include <cfloat>}\par
3658 {\cf21 #include <cstdio>}\par
3659 {\cf21 #include <assert.h>}\par
3660 {\cf21 #include <memory>}\par
3661 {\cf21 #include <ostream>}\par
3662 \par
3663 {\cf17 namespace }Catch \{\par
3664     {\cf18 void} prepareExpandedExpression(AssertionResult& result);\par
3665 \par
3666     {\cf20 // Returns double formatted as %.3f (format expected on output)}\par
3667     std::string getFormattedDuration( {\cf18 double} duration );\par
3668 \par
3669     {\cf17 template}<{\cf17 typename} DerivedT>\par
3670     {\cf17 struct }StreamingReporterBase : IStreamingReporter \{\par
3671 \par
3672         StreamingReporterBase( ReporterConfig {\cf17 const}& _config )\par
3673         :   m_config( _config.fullConfig() ),\par
3674             stream( _config.stream() )\par
3675         \{\par
3676             m_reporterPrefs.shouldRedirectStdOut = {\cf17 false};\par
3677             {\cf19 if}( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )\par
3678                 {\cf19 throw} std::domain_error( {\cf22 "Verbosity level not supported by this reporter"} );\par
3679         \}\par
3680 \par
3681         ReporterPreferences getPreferences(){\cf17  const override }\{\par
3682             {\cf19 return} m_reporterPrefs;\par
3683         \}\par
3684 \par
3685         {\cf17 static} std::set<Verbosity> getSupportedVerbosities() \{\par
3686             {\cf19 return} \{ Verbosity::Normal \};\par
3687         \}\par
3688 \par
3689         ~StreamingReporterBase() {\cf17 override} = {\cf19 default};\par
3690 \par
3691         {\cf18 void} noMatchingTestCases(std::string {\cf17 const}&){\cf17  override }\{\}\par
3692 \par
3693         {\cf18 void} testRunStarting(TestRunInfo {\cf17 const}& _testRunInfo){\cf17  override }\{\par
3694             currentTestRunInfo = _testRunInfo;\par
3695         \}\par
3696         {\cf18 void} testGroupStarting(GroupInfo {\cf17 const}& _groupInfo){\cf17  override }\{\par
3697             currentGroupInfo = _groupInfo;\par
3698         \}\par
3699 \par
3700         {\cf18 void} testCaseStarting(TestCaseInfo {\cf17 const}& _testInfo){\cf17  override  }\{\par
3701             currentTestCaseInfo = _testInfo;\par
3702         \}\par
3703         {\cf18 void} sectionStarting(SectionInfo {\cf17 const}& _sectionInfo){\cf17  override }\{\par
3704             m_sectionStack.push_back(_sectionInfo);\par
3705         \}\par
3706 \par
3707         {\cf18 void} sectionEnded(SectionStats {\cf17 const}& {\cf20 /* _sectionStats */}){\cf17  override }\{\par
3708             m_sectionStack.pop_back();\par
3709         \}\par
3710         {\cf18 void} testCaseEnded(TestCaseStats {\cf17 const}& {\cf20 /* _testCaseStats */}){\cf17  override }\{\par
3711             currentTestCaseInfo.reset();\par
3712         \}\par
3713         {\cf18 void} testGroupEnded(TestGroupStats {\cf17 const}& {\cf20 /* _testGroupStats */}){\cf17  override }\{\par
3714             currentGroupInfo.reset();\par
3715         \}\par
3716         {\cf18 void} testRunEnded(TestRunStats {\cf17 const}& {\cf20 /* _testRunStats */}){\cf17  override }\{\par
3717             currentTestCaseInfo.reset();\par
3718             currentGroupInfo.reset();\par
3719             currentTestRunInfo.reset();\par
3720         \}\par
3721 \par
3722         {\cf18 void} skipTest(TestCaseInfo {\cf17 const}&){\cf17  override }\{\par
3723             {\cf20 // Don't do anything with this by default.}\par
3724             {\cf20 // It can optionally be overridden in the derived class.}\par
3725         \}\par
3726 \par
3727         IConfigPtr m_config;\par
3728         std::ostream& stream;\par
3729 \par
3730         LazyStat<TestRunInfo> currentTestRunInfo;\par
3731         LazyStat<GroupInfo> currentGroupInfo;\par
3732         LazyStat<TestCaseInfo> currentTestCaseInfo;\par
3733 \par
3734         std::vector<SectionInfo> m_sectionStack;\par
3735         ReporterPreferences m_reporterPrefs;\par
3736     \};\par
3737 \par
3738     {\cf17 template}<{\cf17 typename} DerivedT>\par
3739     {\cf17 struct }CumulativeReporterBase : IStreamingReporter \{\par
3740         {\cf17 template}<{\cf17 typename} T, {\cf17 typename} ChildNodeT>\par
3741         {\cf17 struct }Node \{\par
3742             {\cf17 explicit} Node( T {\cf17 const}& _value ) : value( _value ) \{\}\par
3743             {\cf17 virtual} ~Node() \{\}\par
3744 \par
3745             {\cf17 using }ChildNodes = std::vector<std::shared_ptr<ChildNodeT>>;\par
3746             T value;\par
3747             ChildNodes children;\par
3748         \};\par
3749         {\cf17 struct }SectionNode \{\par
3750             {\cf17 explicit} SectionNode(SectionStats {\cf17 const}& _stats) : stats(_stats) \{\}\par
3751             {\cf17 virtual} ~SectionNode() = {\cf19 default};\par
3752 \par
3753             {\cf18 bool} operator == (SectionNode {\cf17 const}& other){\cf17  const }\{\par
3754                 {\cf19 return} stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;\par
3755             \}\par
3756             {\cf18 bool} operator == (std::shared_ptr<SectionNode> {\cf17 const}& other){\cf17  const }\{\par
3757                 {\cf19 return} operator==(*other);\par
3758             \}\par
3759 \par
3760             SectionStats stats;\par
3761             {\cf17 using }ChildSections = std::vector<std::shared_ptr<SectionNode>>;\par
3762             {\cf17 using }Assertions = std::vector<AssertionStats>;\par
3763             ChildSections childSections;\par
3764             Assertions assertions;\par
3765             std::string stdOut;\par
3766             std::string stdErr;\par
3767         \};\par
3768 \par
3769         {\cf17 struct }BySectionInfo \{\par
3770             BySectionInfo( SectionInfo {\cf17 const}& other ) : m_other( other ) \{\}\par
3771             BySectionInfo( BySectionInfo {\cf17 const}& other ) : m_other( other.m_other ) \{\}\par
3772             {\cf18 bool} operator() (std::shared_ptr<SectionNode> {\cf17 const}& node){\cf17  const }\{\par
3773                 {\cf19 return} ((node->stats.sectionInfo.name == m_other.name) &&\par
3774                         (node->stats.sectionInfo.lineInfo == m_other.lineInfo));\par
3775             \}\par
3776             {\cf18 void} operator=(BySectionInfo {\cf17 const}&) = {\cf17 delete};\par
3777 \par
3778         {\cf17 private}:\par
3779             SectionInfo {\cf17 const}& m_other;\par
3780         \};\par
3781 \par
3782         {\cf17 using }TestCaseNode = Node<TestCaseStats, SectionNode>;\par
3783         {\cf17 using }TestGroupNode = Node<TestGroupStats, TestCaseNode>;\par
3784         {\cf17 using }TestRunNode = Node<TestRunStats, TestGroupNode>;\par
3785 \par
3786         CumulativeReporterBase( ReporterConfig {\cf17 const}& _config )\par
3787         :   m_config( _config.fullConfig() ),\par
3788             stream( _config.stream() )\par
3789         \{\par
3790             m_reporterPrefs.shouldRedirectStdOut = {\cf17 false};\par
3791             {\cf19 if}( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )\par
3792                 {\cf19 throw} std::domain_error( {\cf22 "Verbosity level not supported by this reporter"} );\par
3793         \}\par
3794         ~CumulativeReporterBase() {\cf17 override} = {\cf19 default};\par
3795 \par
3796         ReporterPreferences getPreferences(){\cf17  const override }\{\par
3797             {\cf19 return} m_reporterPrefs;\par
3798         \}\par
3799 \par
3800         {\cf17 static} std::set<Verbosity> getSupportedVerbosities() \{\par
3801             {\cf19 return} \{ Verbosity::Normal \};\par
3802         \}\par
3803 \par
3804         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& ){\cf17  override }\{\}\par
3805         {\cf18 void} testGroupStarting( GroupInfo {\cf17 const}& ){\cf17  override }\{\}\par
3806 \par
3807         {\cf18 void} testCaseStarting( TestCaseInfo {\cf17 const}& ){\cf17  override }\{\}\par
3808 \par
3809         {\cf18 void} sectionStarting( SectionInfo {\cf17 const}& sectionInfo ){\cf17  override }\{\par
3810             SectionStats incompleteStats( sectionInfo, Counts(), 0, {\cf17 false} );\par
3811             std::shared_ptr<SectionNode> node;\par
3812             {\cf19 if}( m_sectionStack.empty() ) \{\par
3813                 {\cf19 if}( !m_rootSection )\par
3814                     m_rootSection = std::make_shared<SectionNode>( incompleteStats );\par
3815                 node = m_rootSection;\par
3816             \}\par
3817             {\cf19 else} \{\par
3818                 SectionNode& parentNode = *m_sectionStack.back();\par
3819                 {\cf17 auto} it =\par
3820                     std::find_if(   parentNode.childSections.begin(),\par
3821                                     parentNode.childSections.end(),\par
3822                                     BySectionInfo( sectionInfo ) );\par
3823                 {\cf19 if}( it == parentNode.childSections.end() ) \{\par
3824                     node = std::make_shared<SectionNode>( incompleteStats );\par
3825                     parentNode.childSections.push_back( node );\par
3826                 \}\par
3827                 {\cf19 else}\par
3828                     node = *it;\par
3829             \}\par
3830             m_sectionStack.push_back( node );\par
3831             m_deepestSection = std::move(node);\par
3832         \}\par
3833 \par
3834         {\cf18 void} assertionStarting(AssertionInfo {\cf17 const}&){\cf17  override }\{\}\par
3835 \par
3836         {\cf18 bool} assertionEnded(AssertionStats {\cf17 const}& assertionStats){\cf17  override }\{\par
3837             assert(!m_sectionStack.empty());\par
3838             {\cf20 // AssertionResult holds a pointer to a temporary DecomposedExpression,}\par
3839             {\cf20 // which getExpandedExpression() calls to build the expression string.}\par
3840             {\cf20 // Our section stack copy of the assertionResult will likely outlive the}\par
3841             {\cf20 // temporary, so it must be expanded or discarded now to avoid calling}\par
3842             {\cf20 // a destroyed object later.}\par
3843             prepareExpandedExpression({\cf17 const_cast<}AssertionResult&{\cf17 >}( assertionStats.assertionResult ) );\par
3844             SectionNode& sectionNode = *m_sectionStack.back();\par
3845             sectionNode.assertions.push_back(assertionStats);\par
3846             {\cf19 return} {\cf17 true};\par
3847         \}\par
3848         {\cf18 void} sectionEnded(SectionStats {\cf17 const}& sectionStats){\cf17  override }\{\par
3849             assert(!m_sectionStack.empty());\par
3850             SectionNode& node = *m_sectionStack.back();\par
3851             node.stats = sectionStats;\par
3852             m_sectionStack.pop_back();\par
3853         \}\par
3854         {\cf18 void} testCaseEnded(TestCaseStats {\cf17 const}& testCaseStats){\cf17  override }\{\par
3855             {\cf17 auto} node = std::make_shared<TestCaseNode>(testCaseStats);\par
3856             assert(m_sectionStack.size() == 0);\par
3857             node->children.push_back(m_rootSection);\par
3858             m_testCases.push_back(node);\par
3859             m_rootSection.reset();\par
3860 \par
3861             assert(m_deepestSection);\par
3862             m_deepestSection->stdOut = testCaseStats.stdOut;\par
3863             m_deepestSection->stdErr = testCaseStats.stdErr;\par
3864         \}\par
3865         {\cf18 void} testGroupEnded(TestGroupStats {\cf17 const}& testGroupStats){\cf17  override }\{\par
3866             {\cf17 auto} node = std::make_shared<TestGroupNode>(testGroupStats);\par
3867             node->children.swap(m_testCases);\par
3868             m_testGroups.push_back(node);\par
3869         \}\par
3870         {\cf18 void} testRunEnded(TestRunStats {\cf17 const}& testRunStats){\cf17  override }\{\par
3871             {\cf17 auto} node = std::make_shared<TestRunNode>(testRunStats);\par
3872             node->children.swap(m_testGroups);\par
3873             m_testRuns.push_back(node);\par
3874             testRunEndedCumulative();\par
3875         \}\par
3876         {\cf17 virtual} {\cf18 void} testRunEndedCumulative() = 0;\par
3877 \par
3878         {\cf18 void} skipTest(TestCaseInfo {\cf17 const}&){\cf17  override }\{\}\par
3879 \par
3880         IConfigPtr m_config;\par
3881         std::ostream& stream;\par
3882         std::vector<AssertionStats> m_assertions;\par
3883         std::vector<std::vector<std::shared_ptr<SectionNode>>> m_sections;\par
3884         std::vector<std::shared_ptr<TestCaseNode>> m_testCases;\par
3885         std::vector<std::shared_ptr<TestGroupNode>> m_testGroups;\par
3886 \par
3887         std::vector<std::shared_ptr<TestRunNode>> m_testRuns;\par
3888 \par
3889         std::shared_ptr<SectionNode> m_rootSection;\par
3890         std::shared_ptr<SectionNode> m_deepestSection;\par
3891         std::vector<std::shared_ptr<SectionNode>> m_sectionStack;\par
3892         ReporterPreferences m_reporterPrefs;\par
3893     \};\par
3894 \par
3895     {\cf17 template}<{\cf18 char} C>\par
3896     {\cf18 char} {\cf17 const}* getLineOfChars() \{\par
3897         {\cf17 static} {\cf18 char} line[CATCH_CONFIG_CONSOLE_WIDTH] = \{0\};\par
3898         {\cf19 if}( !*line ) \{\par
3899             std::memset( line, C, CATCH_CONFIG_CONSOLE_WIDTH-1 );\par
3900             line[CATCH_CONFIG_CONSOLE_WIDTH-1] = 0;\par
3901         \}\par
3902         {\cf19 return} line;\par
3903     \}\par
3904 \par
3905     {\cf17 struct }TestEventListenerBase : StreamingReporterBase<TestEventListenerBase> \{\par
3906         TestEventListenerBase( ReporterConfig {\cf17 const}& _config );\par
3907 \par
3908         {\cf18 void} assertionStarting(AssertionInfo {\cf17 const}&) {\cf17 override};\par
3909         {\cf18 bool} assertionEnded(AssertionStats {\cf17 const}&) {\cf17 override};\par
3910     \};\par
3911 \par
3912 \} {\cf20 // end namespace Catch}\par
3913 \par
3914 {\cf20 // end catch_reporter_bases.hpp}\par
3915 {\cf20 // start catch_console_colour.h}\par
3916 \par
3917 {\cf17 namespace }Catch \{\par
3918 \par
3919     {\cf17 struct }Colour \{\par
3920         {\cf17 enum} Code \{\par
3921             None = 0,\par
3922 \par
3923             White,\par
3924             Red,\par
3925             Green,\par
3926             Blue,\par
3927             Cyan,\par
3928             Yellow,\par
3929             Grey,\par
3930 \par
3931             Bright = 0x10,\par
3932 \par
3933             BrightRed = Bright | Red,\par
3934             BrightGreen = Bright | Green,\par
3935             LightGrey = Bright | Grey,\par
3936             BrightWhite = Bright | White,\par
3937             BrightYellow = Bright | Yellow,\par
3938 \par
3939             {\cf20 // By intention}\par
3940             FileName = LightGrey,\par
3941             Warning = BrightYellow,\par
3942             ResultError = BrightRed,\par
3943             ResultSuccess = BrightGreen,\par
3944             ResultExpectedFailure = Warning,\par
3945 \par
3946             Error = BrightRed,\par
3947             Success = Green,\par
3948 \par
3949             OriginalExpression = Cyan,\par
3950             ReconstructedExpression = BrightYellow,\par
3951 \par
3952             SecondaryText = LightGrey,\par
3953             Headers = White\par
3954         \};\par
3955 \par
3956         {\cf20 // Use constructed object for RAII guard}\par
3957         Colour( Code _colourCode );\par
3958         Colour( Colour&& other ) {\cf17 noexcept};\par
3959         Colour& operator=( Colour&& other ) {\cf17 noexcept};\par
3960         ~Colour();\par
3961 \par
3962         {\cf20 // Use static method for one-shot changes}\par
3963         {\cf17 static} {\cf18 void} use( Code _colourCode );\par
3964 \par
3965     {\cf17 private}:\par
3966         {\cf18 bool} m_moved = {\cf17 false};\par
3967     \};\par
3968 \par
3969     std::ostream& operator << ( std::ostream& os, Colour {\cf17 const}& );\par
3970 \par
3971 \} {\cf20 // end namespace Catch}\par
3972 \par
3973 {\cf20 // end catch_console_colour.h}\par
3974 {\cf20 // start catch_reporter_registrars.hpp}\par
3975 \par
3976 \par
3977 {\cf17 namespace }Catch \{\par
3978 \par
3979     {\cf17 template}<{\cf17 typename} T>\par
3980     {\cf17 class }ReporterRegistrar \{\par
3981 \par
3982         {\cf17 class }ReporterFactory : {\cf17 public} IReporterFactory \{\par
3983 \par
3984             {\cf17 virtual} IStreamingReporterPtr create( ReporterConfig {\cf17 const}& config ){\cf17  const override }\{\par
3985                 {\cf19 return} std::unique_ptr<T>( {\cf17 new} T( config ) );\par
3986             \}\par
3987 \par
3988             {\cf17 virtual} std::string getDescription(){\cf17  const override }\{\par
3989                 {\cf19 return} T::getDescription();\par
3990             \}\par
3991         \};\par
3992 \par
3993     {\cf17 public}:\par
3994 \par
3995         {\cf17 explicit} ReporterRegistrar( std::string {\cf17 const}& name ) \{\par
3996             getMutableRegistryHub().registerReporter( name, std::make_shared<ReporterFactory>() );\par
3997         \}\par
3998     \};\par
3999 \par
4000     {\cf17 template}<{\cf17 typename} T>\par
4001     {\cf17 class }ListenerRegistrar \{\par
4002 \par
4003         {\cf17 class }ListenerFactory : {\cf17 public} IReporterFactory \{\par
4004 \par
4005             {\cf17 virtual} IStreamingReporterPtr create( ReporterConfig {\cf17 const}& config ){\cf17  const override }\{\par
4006                 {\cf19 return} std::unique_ptr<T>( {\cf17 new} T( config ) );\par
4007             \}\par
4008             {\cf17 virtual} std::string getDescription(){\cf17  const override }\{\par
4009                 {\cf19 return} std::string();\par
4010             \}\par
4011         \};\par
4012 \par
4013     {\cf17 public}:\par
4014 \par
4015         ListenerRegistrar() \{\par
4016             getMutableRegistryHub().registerListener( std::make_shared<ListenerFactory>() );\par
4017         \}\par
4018     \};\par
4019 \}\par
4020 \par
4021 {\cf21 #if !defined(CATCH_CONFIG_DISABLE)}\par
4022 \par
4023 {\cf21 #define CATCH_REGISTER_REPORTER( name, reporterType ) \\}\par
4024 {\cf21     CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS          \\}\par
4025 {\cf21     namespace\{ Catch::ReporterRegistrar<reporterType> catch_internal_RegistrarFor##reporterType( name ); \} \\}\par
4026 {\cf21     CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS}\par
4027 \par
4028 {\cf21 #define CATCH_REGISTER_LISTENER( listenerType ) \\}\par
4029 {\cf21      CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS   \\}\par
4030 {\cf21      namespace\{ Catch::ListenerRegistrar<listenerType> catch_internal_RegistrarFor##listenerType; \} \\}\par
4031 {\cf21      CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS}\par
4032 {\cf21 #else }{\cf20 // CATCH_CONFIG_DISABLE}\par
4033 \par
4034 {\cf21 #define CATCH_REGISTER_REPORTER(name, reporterType)}\par
4035 {\cf21 #define CATCH_REGISTER_LISTENER(listenerType)}\par
4036 \par
4037 {\cf21 #endif }{\cf20 // CATCH_CONFIG_DISABLE}\par
4038 \par
4039 {\cf20 // end catch_reporter_registrars.hpp}\par
4040 {\cf20 // Allow users to base their work off existing reporters}\par
4041 {\cf20 // start catch_reporter_compact.h}\par
4042 \par
4043 {\cf17 namespace }Catch \{\par
4044 \par
4045     {\cf17 struct }CompactReporter : StreamingReporterBase<CompactReporter> \{\par
4046 \par
4047         {\cf17 using }StreamingReporterBase::StreamingReporterBase;\par
4048 \par
4049         ~CompactReporter() {\cf17 override};\par
4050 \par
4051         {\cf17 static} std::string getDescription();\par
4052 \par
4053         ReporterPreferences getPreferences() {\cf17 const override};\par
4054 \par
4055         {\cf18 void} noMatchingTestCases(std::string {\cf17 const}& spec) {\cf17 override};\par
4056 \par
4057         {\cf18 void} assertionStarting(AssertionInfo {\cf17 const}&) {\cf17 override};\par
4058 \par
4059         {\cf18 bool} assertionEnded(AssertionStats {\cf17 const}& _assertionStats) {\cf17 override};\par
4060 \par
4061         {\cf18 void} sectionEnded(SectionStats {\cf17 const}& _sectionStats) {\cf17 override};\par
4062 \par
4063         {\cf18 void} testRunEnded(TestRunStats {\cf17 const}& _testRunStats) {\cf17 override};\par
4064 \par
4065     \};\par
4066 \par
4067 \} {\cf20 // end namespace Catch}\par
4068 \par
4069 {\cf20 // end catch_reporter_compact.h}\par
4070 {\cf20 // start catch_reporter_console.h}\par
4071 \par
4072 {\cf21 #if defined(_MSC_VER)}\par
4073 {\cf21 #pragma warning(push)}\par
4074 {\cf21 #pragma warning(disable:4061) }{\cf20 // Not all labels are EXPLICITLY handled in switch}\par
4075                               {\cf20 // Note that 4062 (not all labels are handled}\par
4076                               {\cf20 // and default is missing) is enabled}\par
4077 {\cf21 #endif}\par
4078 \par
4079 {\cf17 namespace }Catch \{\par
4080     {\cf20 // Fwd decls}\par
4081     {\cf17 struct }SummaryColumn;\par
4082     {\cf17 class }TablePrinter;\par
4083 \par
4084     {\cf17 struct }ConsoleReporter : StreamingReporterBase<ConsoleReporter> \{\par
4085         std::unique_ptr<TablePrinter> m_tablePrinter;\par
4086 \par
4087         ConsoleReporter(ReporterConfig {\cf17 const}& config);\par
4088         ~ConsoleReporter() {\cf17 override};\par
4089         {\cf17 static} std::string getDescription();\par
4090 \par
4091         {\cf18 void} noMatchingTestCases(std::string {\cf17 const}& spec) {\cf17 override};\par
4092 \par
4093         {\cf18 void} assertionStarting(AssertionInfo {\cf17 const}&) {\cf17 override};\par
4094 \par
4095         {\cf18 bool} assertionEnded(AssertionStats {\cf17 const}& _assertionStats) {\cf17 override};\par
4096 \par
4097         {\cf18 void} sectionStarting(SectionInfo {\cf17 const}& _sectionInfo) {\cf17 override};\par
4098         {\cf18 void} sectionEnded(SectionStats {\cf17 const}& _sectionStats) {\cf17 override};\par
4099 \par
4100         {\cf18 void} benchmarkStarting(BenchmarkInfo {\cf17 const}& info) {\cf17 override};\par
4101         {\cf18 void} benchmarkEnded(BenchmarkStats {\cf17 const}& stats) {\cf17 override};\par
4102 \par
4103         {\cf18 void} testCaseEnded(TestCaseStats {\cf17 const}& _testCaseStats) {\cf17 override};\par
4104         {\cf18 void} testGroupEnded(TestGroupStats {\cf17 const}& _testGroupStats) {\cf17 override};\par
4105         {\cf18 void} testRunEnded(TestRunStats {\cf17 const}& _testRunStats) {\cf17 override};\par
4106 \par
4107     {\cf17 private}:\par
4108 \par
4109         {\cf18 void} lazyPrint();\par
4110 \par
4111         {\cf18 void} lazyPrintWithoutClosingBenchmarkTable();\par
4112         {\cf18 void} lazyPrintRunInfo();\par
4113         {\cf18 void} lazyPrintGroupInfo();\par
4114         {\cf18 void} printTestCaseAndSectionHeader();\par
4115 \par
4116         {\cf18 void} printClosedHeader(std::string {\cf17 const}& _name);\par
4117         {\cf18 void} printOpenHeader(std::string {\cf17 const}& _name);\par
4118 \par
4119         {\cf20 // if string has a : in first line will set indent to follow it on}\par
4120         {\cf20 // subsequent lines}\par
4121         {\cf18 void} printHeaderString(std::string {\cf17 const}& _string, std::size_t indent = 0);\par
4122 \par
4123         {\cf18 void} printTotals(Totals {\cf17 const}& totals);\par
4124         {\cf18 void} printSummaryRow(std::string {\cf17 const}& label, std::vector<SummaryColumn> {\cf17 const}& cols, std::size_t row);\par
4125 \par
4126         {\cf18 void} printTotalsDivider(Totals {\cf17 const}& totals);\par
4127         {\cf18 void} printSummaryDivider();\par
4128 \par
4129     {\cf17 private}:\par
4130         {\cf18 bool} m_headerPrinted = {\cf17 false};\par
4131     \};\par
4132 \par
4133 \} {\cf20 // end namespace Catch}\par
4134 \par
4135 {\cf21 #if defined(_MSC_VER)}\par
4136 {\cf21 #pragma warning(pop)}\par
4137 {\cf21 #endif}\par
4138 \par
4139 {\cf20 // end catch_reporter_console.h}\par
4140 {\cf20 // start catch_reporter_junit.h}\par
4141 \par
4142 {\cf20 // start catch_xmlwriter.h}\par
4143 \par
4144 {\cf21 #include <vector>}\par
4145 \par
4146 {\cf17 namespace }Catch \{\par
4147 \par
4148     {\cf17 class }XmlEncode \{\par
4149     {\cf17 public}:\par
4150         {\cf17 enum} ForWhat \{ ForTextNodes, ForAttributes \};\par
4151 \par
4152         XmlEncode( std::string {\cf17 const}& str, ForWhat forWhat = ForTextNodes );\par
4153 \par
4154         {\cf18 void} encodeTo( std::ostream& os ) {\cf17 const};\par
4155 \par
4156         {\cf17 friend} std::ostream& operator << ( std::ostream& os, XmlEncode {\cf17 const}& xmlEncode );\par
4157 \par
4158     {\cf17 private}:\par
4159         std::string m_str;\par
4160         ForWhat m_forWhat;\par
4161     \};\par
4162 \par
4163     {\cf17 class }XmlWriter \{\par
4164     {\cf17 public}:\par
4165 \par
4166         {\cf17 class }ScopedElement \{\par
4167         {\cf17 public}:\par
4168             ScopedElement( XmlWriter* writer );\par
4169 \par
4170             ScopedElement( ScopedElement&& other ) {\cf17 noexcept};\par
4171             ScopedElement& operator=( ScopedElement&& other ) {\cf17 noexcept};\par
4172 \par
4173             ~ScopedElement();\par
4174 \par
4175             ScopedElement& writeText( std::string {\cf17 const}& text, {\cf18 bool} indent = {\cf17 true} );\par
4176 \par
4177             {\cf17 template}<{\cf17 typename} T>\par
4178             ScopedElement& writeAttribute( std::string {\cf17 const}& name, T {\cf17 const}& attribute ) \{\par
4179                 m_writer->writeAttribute( name, attribute );\par
4180                 {\cf19 return} *{\cf17 this};\par
4181             \}\par
4182 \par
4183         {\cf17 private}:\par
4184             {\cf17 mutable} XmlWriter* m_writer = {\cf17 nullptr};\par
4185         \};\par
4186 \par
4187         XmlWriter( std::ostream& os = Catch::cout() );\par
4188         ~XmlWriter();\par
4189 \par
4190         XmlWriter( XmlWriter {\cf17 const}& ) = {\cf17 delete};\par
4191         XmlWriter& operator=( XmlWriter {\cf17 const}& ) = {\cf17 delete};\par
4192 \par
4193         XmlWriter& startElement( std::string {\cf17 const}& name );\par
4194 \par
4195         ScopedElement scopedElement( std::string {\cf17 const}& name );\par
4196 \par
4197         XmlWriter& endElement();\par
4198 \par
4199         XmlWriter& writeAttribute( std::string {\cf17 const}& name, std::string {\cf17 const}& attribute );\par
4200 \par
4201         XmlWriter& writeAttribute( std::string {\cf17 const}& name, {\cf18 bool} attribute );\par
4202 \par
4203         {\cf17 template}<{\cf17 typename} T>\par
4204         XmlWriter& writeAttribute( std::string {\cf17 const}& name, T {\cf17 const}& attribute ) \{\par
4205             ReusableStringStream rss;\par
4206             rss << attribute;\par
4207             {\cf19 return} writeAttribute( name, rss.str() );\par
4208         \}\par
4209 \par
4210         XmlWriter& writeText( std::string {\cf17 const}& text, {\cf18 bool} indent = {\cf17 true} );\par
4211 \par
4212         XmlWriter& writeComment( std::string {\cf17 const}& text );\par
4213 \par
4214         {\cf18 void} writeStylesheetRef( std::string {\cf17 const}& url );\par
4215 \par
4216         XmlWriter& writeBlankLine();\par
4217 \par
4218         {\cf18 void} ensureTagClosed();\par
4219 \par
4220     {\cf17 private}:\par
4221 \par
4222         {\cf18 void} writeDeclaration();\par
4223 \par
4224         {\cf18 void} newlineIfNecessary();\par
4225 \par
4226         {\cf18 bool} m_tagIsOpen = {\cf17 false};\par
4227         {\cf18 bool} m_needsNewline = {\cf17 false};\par
4228         std::vector<std::string> m_tags;\par
4229         std::string m_indent;\par
4230         std::ostream& m_os;\par
4231     \};\par
4232 \par
4233 \}\par
4234 \par
4235 {\cf20 // end catch_xmlwriter.h}\par
4236 {\cf17 namespace }Catch \{\par
4237 \par
4238     {\cf17 class }JunitReporter : {\cf17 public} CumulativeReporterBase<JunitReporter> \{\par
4239     {\cf17 public}:\par
4240         JunitReporter(ReporterConfig {\cf17 const}& _config);\par
4241 \par
4242         ~JunitReporter() {\cf17 override};\par
4243 \par
4244         {\cf17 static} std::string getDescription();\par
4245 \par
4246         {\cf18 void} noMatchingTestCases(std::string {\cf17 const}& {\cf20 /*spec*/}) {\cf17 override};\par
4247 \par
4248         {\cf18 void} testRunStarting(TestRunInfo {\cf17 const}& runInfo) {\cf17 override};\par
4249 \par
4250         {\cf18 void} testGroupStarting(GroupInfo {\cf17 const}& groupInfo) {\cf17 override};\par
4251 \par
4252         {\cf18 void} testCaseStarting(TestCaseInfo {\cf17 const}& testCaseInfo) {\cf17 override};\par
4253         {\cf18 bool} assertionEnded(AssertionStats {\cf17 const}& assertionStats) {\cf17 override};\par
4254 \par
4255         {\cf18 void} testCaseEnded(TestCaseStats {\cf17 const}& testCaseStats) {\cf17 override};\par
4256 \par
4257         {\cf18 void} testGroupEnded(TestGroupStats {\cf17 const}& testGroupStats) {\cf17 override};\par
4258 \par
4259         {\cf18 void} testRunEndedCumulative() {\cf17 override};\par
4260 \par
4261         {\cf18 void} writeGroup(TestGroupNode {\cf17 const}& groupNode, {\cf18 double} suiteTime);\par
4262 \par
4263         {\cf18 void} writeTestCase(TestCaseNode {\cf17 const}& testCaseNode);\par
4264 \par
4265         {\cf18 void} writeSection(std::string {\cf17 const}& className,\par
4266                           std::string {\cf17 const}& rootName,\par
4267                           SectionNode {\cf17 const}& sectionNode);\par
4268 \par
4269         {\cf18 void} writeAssertions(SectionNode {\cf17 const}& sectionNode);\par
4270         {\cf18 void} writeAssertion(AssertionStats {\cf17 const}& stats);\par
4271 \par
4272         XmlWriter xml;\par
4273         Timer suiteTimer;\par
4274         std::string stdOutForSuite;\par
4275         std::string stdErrForSuite;\par
4276         {\cf18 unsigned} {\cf18 int} unexpectedExceptions = 0;\par
4277         {\cf18 bool} m_okToFail = {\cf17 false};\par
4278     \};\par
4279 \par
4280 \} {\cf20 // end namespace Catch}\par
4281 \par
4282 {\cf20 // end catch_reporter_junit.h}\par
4283 {\cf20 // start catch_reporter_xml.h}\par
4284 \par
4285 {\cf17 namespace }Catch \{\par
4286     {\cf17 class }XmlReporter : {\cf17 public} StreamingReporterBase<XmlReporter> \{\par
4287     {\cf17 public}:\par
4288         XmlReporter(ReporterConfig {\cf17 const}& _config);\par
4289 \par
4290         ~XmlReporter() {\cf17 override};\par
4291 \par
4292         {\cf17 static} std::string getDescription();\par
4293 \par
4294         {\cf17 virtual} std::string getStylesheetRef() {\cf17 const};\par
4295 \par
4296         {\cf18 void} writeSourceInfo(SourceLineInfo {\cf17 const}& sourceInfo);\par
4297 \par
4298     {\cf17 public}: {\cf20 // StreamingReporterBase}\par
4299 \par
4300         {\cf18 void} noMatchingTestCases(std::string {\cf17 const}& s) {\cf17 override};\par
4301 \par
4302         {\cf18 void} testRunStarting(TestRunInfo {\cf17 const}& testInfo) {\cf17 override};\par
4303 \par
4304         {\cf18 void} testGroupStarting(GroupInfo {\cf17 const}& groupInfo) {\cf17 override};\par
4305 \par
4306         {\cf18 void} testCaseStarting(TestCaseInfo {\cf17 const}& testInfo) {\cf17 override};\par
4307 \par
4308         {\cf18 void} sectionStarting(SectionInfo {\cf17 const}& sectionInfo) {\cf17 override};\par
4309 \par
4310         {\cf18 void} assertionStarting(AssertionInfo {\cf17 const}&) {\cf17 override};\par
4311 \par
4312         {\cf18 bool} assertionEnded(AssertionStats {\cf17 const}& assertionStats) {\cf17 override};\par
4313 \par
4314         {\cf18 void} sectionEnded(SectionStats {\cf17 const}& sectionStats) {\cf17 override};\par
4315 \par
4316         {\cf18 void} testCaseEnded(TestCaseStats {\cf17 const}& testCaseStats) {\cf17 override};\par
4317 \par
4318         {\cf18 void} testGroupEnded(TestGroupStats {\cf17 const}& testGroupStats) {\cf17 override};\par
4319 \par
4320         {\cf18 void} testRunEnded(TestRunStats {\cf17 const}& testRunStats) {\cf17 override};\par
4321 \par
4322     {\cf17 private}:\par
4323         Timer m_testCaseTimer;\par
4324         XmlWriter m_xml;\par
4325         {\cf18 int} m_sectionDepth = 0;\par
4326     \};\par
4327 \par
4328 \} {\cf20 // end namespace Catch}\par
4329 \par
4330 {\cf20 // end catch_reporter_xml.h}\par
4331 \par
4332 {\cf20 // end catch_external_interfaces.h}\par
4333 {\cf21 #endif}\par
4334 \par
4335 {\cf21 #endif }{\cf20 // ! CATCH_CONFIG_IMPL_ONLY}\par
4336 \par
4337 {\cf21 #ifdef CATCH_IMPL}\par
4338 {\cf20 // start catch_impl.hpp}\par
4339 \par
4340 {\cf21 #ifdef __clang__}\par
4341 {\cf21 #pragma clang diagnostic push}\par
4342 {\cf21 #pragma clang diagnostic ignored "-Wweak-vtables"}\par
4343 {\cf21 #endif}\par
4344 \par
4345 {\cf20 // Keep these here for external reporters}\par
4346 {\cf20 // start catch_test_case_tracker.h}\par
4347 \par
4348 {\cf21 #include <string>}\par
4349 {\cf21 #include <vector>}\par
4350 {\cf21 #include <memory>}\par
4351 \par
4352 {\cf17 namespace }Catch \{\par
4353 {\cf17 namespace }TestCaseTracking \{\par
4354 \par
4355     {\cf17 struct }NameAndLocation \{\par
4356         std::string name;\par
4357         SourceLineInfo location;\par
4358 \par
4359         NameAndLocation( std::string {\cf17 const}& _name, SourceLineInfo {\cf17 const}& _location );\par
4360     \};\par
4361 \par
4362     {\cf17 struct }ITracker;\par
4363 \par
4364     {\cf17 using }ITrackerPtr = std::shared_ptr<ITracker>;\par
4365 \par
4366     {\cf17 struct }ITracker \{\par
4367         {\cf17 virtual} ~ITracker();\par
4368 \par
4369         {\cf20 // static queries}\par
4370         {\cf17 virtual} NameAndLocation {\cf17 const}& nameAndLocation() {\cf17 const} = 0;\par
4371 \par
4372         {\cf20 // dynamic queries}\par
4373         {\cf17 virtual} {\cf18 bool} isComplete() {\cf17 const} = 0; {\cf20 // Successfully completed or failed}\par
4374         {\cf17 virtual} {\cf18 bool} isSuccessfullyCompleted() {\cf17 const} = 0;\par
4375         {\cf17 virtual} {\cf18 bool} isOpen() {\cf17 const} = 0; {\cf20 // Started but not complete}\par
4376         {\cf17 virtual} {\cf18 bool} hasChildren() {\cf17 const} = 0;\par
4377 \par
4378         {\cf17 virtual} ITracker& parent() = 0;\par
4379 \par
4380         {\cf20 // actions}\par
4381         {\cf17 virtual} {\cf18 void} close() = 0; {\cf20 // Successfully complete}\par
4382         {\cf17 virtual} {\cf18 void} fail() = 0;\par
4383         {\cf17 virtual} {\cf18 void} markAsNeedingAnotherRun() = 0;\par
4384 \par
4385         {\cf17 virtual} {\cf18 void} addChild( ITrackerPtr {\cf17 const}& child ) = 0;\par
4386         {\cf17 virtual} ITrackerPtr findChild( NameAndLocation {\cf17 const}& nameAndLocation ) = 0;\par
4387         {\cf17 virtual} {\cf18 void} openChild() = 0;\par
4388 \par
4389         {\cf20 // Debug/ checking}\par
4390         {\cf17 virtual} {\cf18 bool} isSectionTracker() {\cf17 const} = 0;\par
4391         {\cf17 virtual} {\cf18 bool} isIndexTracker() {\cf17 const} = 0;\par
4392     \};\par
4393 \par
4394     {\cf17 class }TrackerContext \{\par
4395 \par
4396         {\cf17 enum} RunState \{\par
4397             NotStarted,\par
4398             Executing,\par
4399             CompletedCycle\par
4400         \};\par
4401 \par
4402         ITrackerPtr m_rootTracker;\par
4403         ITracker* m_currentTracker = {\cf17 nullptr};\par
4404         RunState m_runState = NotStarted;\par
4405 \par
4406     {\cf17 public}:\par
4407 \par
4408         {\cf17 static} TrackerContext& instance();\par
4409 \par
4410         ITracker& startRun();\par
4411         {\cf18 void} endRun();\par
4412 \par
4413         {\cf18 void} startCycle();\par
4414         {\cf18 void} completeCycle();\par
4415 \par
4416         {\cf18 bool} completedCycle() {\cf17 const};\par
4417         ITracker& currentTracker();\par
4418         {\cf18 void} setCurrentTracker( ITracker* tracker );\par
4419     \};\par
4420 \par
4421     {\cf17 class }TrackerBase : {\cf17 public} ITracker \{\par
4422     {\cf17 protected}:\par
4423         {\cf17 enum} CycleState \{\par
4424             NotStarted,\par
4425             Executing,\par
4426             ExecutingChildren,\par
4427             NeedsAnotherRun,\par
4428             CompletedSuccessfully,\par
4429             Failed\par
4430         \};\par
4431 \par
4432         {\cf17 class }TrackerHasName \{\par
4433             NameAndLocation m_nameAndLocation;\par
4434         {\cf17 public}:\par
4435             TrackerHasName( NameAndLocation {\cf17 const}& nameAndLocation );\par
4436             {\cf18 bool} operator ()( ITrackerPtr {\cf17 const}& tracker ) {\cf17 const};\par
4437         \};\par
4438 \par
4439         {\cf17 using }Children = std::vector<ITrackerPtr>;\par
4440         NameAndLocation m_nameAndLocation;\par
4441         TrackerContext& m_ctx;\par
4442         ITracker* m_parent;\par
4443         Children m_children;\par
4444         CycleState m_runState = NotStarted;\par
4445 \par
4446     {\cf17 public}:\par
4447         TrackerBase( NameAndLocation {\cf17 const}& nameAndLocation, TrackerContext& ctx, ITracker* parent );\par
4448 \par
4449         NameAndLocation {\cf17 const}& nameAndLocation() {\cf17 const override};\par
4450         {\cf18 bool} isComplete() {\cf17 const override};\par
4451         {\cf18 bool} isSuccessfullyCompleted() {\cf17 const override};\par
4452         {\cf18 bool} isOpen() {\cf17 const override};\par
4453         {\cf18 bool} hasChildren() {\cf17 const override};\par
4454 \par
4455         {\cf18 void} addChild( ITrackerPtr {\cf17 const}& child ) {\cf17 override};\par
4456 \par
4457         ITrackerPtr findChild( NameAndLocation {\cf17 const}& nameAndLocation ) {\cf17 override};\par
4458         ITracker& parent() {\cf17 override};\par
4459 \par
4460         {\cf18 void} openChild() {\cf17 override};\par
4461 \par
4462         {\cf18 bool} isSectionTracker() {\cf17 const override};\par
4463         {\cf18 bool} isIndexTracker() {\cf17 const override};\par
4464 \par
4465         {\cf18 void} open();\par
4466 \par
4467         {\cf18 void} close() {\cf17 override};\par
4468         {\cf18 void} fail() {\cf17 override};\par
4469         {\cf18 void} markAsNeedingAnotherRun() {\cf17 override};\par
4470 \par
4471     {\cf17 private}:\par
4472         {\cf18 void} moveToParent();\par
4473         {\cf18 void} moveToThis();\par
4474     \};\par
4475 \par
4476     {\cf17 class }SectionTracker : {\cf17 public} TrackerBase \{\par
4477         std::vector<std::string> m_filters;\par
4478     {\cf17 public}:\par
4479         SectionTracker( NameAndLocation {\cf17 const}& nameAndLocation, TrackerContext& ctx, ITracker* parent );\par
4480 \par
4481         {\cf18 bool} isSectionTracker() {\cf17 const override};\par
4482 \par
4483         {\cf17 static} SectionTracker& acquire( TrackerContext& ctx, NameAndLocation {\cf17 const}& nameAndLocation );\par
4484 \par
4485         {\cf18 void} tryOpen();\par
4486 \par
4487         {\cf18 void} addInitialFilters( std::vector<std::string> {\cf17 const}& filters );\par
4488         {\cf18 void} addNextFilters( std::vector<std::string> {\cf17 const}& filters );\par
4489     \};\par
4490 \par
4491     {\cf17 class }IndexTracker : {\cf17 public} TrackerBase \{\par
4492         {\cf18 int} m_size;\par
4493         {\cf18 int} m_index = -1;\par
4494     {\cf17 public}:\par
4495         IndexTracker( NameAndLocation {\cf17 const}& nameAndLocation, TrackerContext& ctx, ITracker* parent, {\cf18 int} size );\par
4496 \par
4497         {\cf18 bool} isIndexTracker() {\cf17 const override};\par
4498         {\cf18 void} close() {\cf17 override};\par
4499 \par
4500         {\cf17 static} IndexTracker& acquire( TrackerContext& ctx, NameAndLocation {\cf17 const}& nameAndLocation, {\cf18 int} size );\par
4501 \par
4502         {\cf18 int} index() {\cf17 const};\par
4503 \par
4504         {\cf18 void} moveNext();\par
4505     \};\par
4506 \par
4507 \} {\cf20 // namespace TestCaseTracking}\par
4508 \par
4509 {\cf17 using }TestCaseTracking::ITracker;\par
4510 {\cf17 using }TestCaseTracking::TrackerContext;\par
4511 {\cf17 using }TestCaseTracking::SectionTracker;\par
4512 {\cf17 using }TestCaseTracking::IndexTracker;\par
4513 \par
4514 \} {\cf20 // namespace Catch}\par
4515 \par
4516 {\cf20 // end catch_test_case_tracker.h}\par
4517 \par
4518 {\cf20 // start catch_leak_detector.h}\par
4519 \par
4520 {\cf17 namespace }Catch \{\par
4521 \par
4522     {\cf17 struct }LeakDetector \{\par
4523         LeakDetector();\par
4524     \};\par
4525 \par
4526 \}\par
4527 {\cf20 // end catch_leak_detector.h}\par
4528 {\cf20 // Cpp files will be included in the single-header file here}\par
4529 {\cf20 // start catch_approx.cpp}\par
4530 \par
4531 {\cf21 #include <cmath>}\par
4532 {\cf21 #include <limits>}\par
4533 \par
4534 {\cf17 namespace }\{\par
4535 \par
4536 {\cf20 // Performs equivalent check of std::fabs(lhs - rhs) <= margin}\par
4537 {\cf20 // But without the subtraction to allow for INFINITY in comparison}\par
4538 {\cf18 bool} marginComparison({\cf18 double} lhs, {\cf18 double} rhs, {\cf18 double} margin) \{\par
4539     {\cf19 return} (lhs + margin >= rhs) && (rhs + margin >= lhs);\par
4540 \}\par
4541 \par
4542 \}\par
4543 \par
4544 {\cf17 namespace }Catch \{\par
4545 {\cf17 namespace }Detail \{\par
4546 \par
4547     Approx::Approx ( {\cf18 double} value )\par
4548     :   m_epsilon( std::numeric_limits<float>::epsilon()*100 ),\par
4549         m_margin( 0.0 ),\par
4550         m_scale( 0.0 ),\par
4551         m_value( value )\par
4552     \{\}\par
4553 \par
4554     Approx Approx::custom() \{\par
4555         {\cf19 return} Approx( 0 );\par
4556     \}\par
4557 \par
4558     std::string Approx::toString(){\cf17  const }\{\par
4559         ReusableStringStream rss;\par
4560         rss << {\cf22 "Approx( "} << ::Catch::Detail::stringify( m_value ) << {\cf22 " )"};\par
4561         {\cf19 return} rss.str();\par
4562     \}\par
4563 \par
4564     {\cf18 bool} Approx::equalityComparisonImpl({\cf17 const} {\cf18 double} other){\cf17  const }\{\par
4565         {\cf20 // First try with fixed margin, then compute margin based on epsilon, scale and Approx's value}\par
4566         {\cf20 // Thanks to Richard Harris for his help refining the scaled margin value}\par
4567         {\cf19 return} marginComparison(m_value, other, m_margin) || marginComparison(m_value, other, m_epsilon * (m_scale + std::fabs(m_value)));\par
4568     \}\par
4569 \par
4570 \} {\cf20 // end namespace Detail}\par
4571 \par
4572 std::string StringMaker<Catch::Detail::Approx>::convert(Catch::Detail::Approx {\cf17 const}& value) \{\par
4573     {\cf19 return} value.toString();\par
4574 \}\par
4575 \par
4576 \} {\cf20 // end namespace Catch}\par
4577 {\cf20 // end catch_approx.cpp}\par
4578 {\cf20 // start catch_assertionhandler.cpp}\par
4579 \par
4580 {\cf20 // start catch_context.h}\par
4581 \par
4582 {\cf21 #include <memory>}\par
4583 \par
4584 {\cf17 namespace }Catch \{\par
4585 \par
4586     {\cf17 struct }IResultCapture;\par
4587     {\cf17 struct }IRunner;\par
4588     {\cf17 struct }IConfig;\par
4589     {\cf17 struct }IMutableContext;\par
4590 \par
4591     {\cf17 using }IConfigPtr = std::shared_ptr<IConfig const>;\par
4592 \par
4593     {\cf17 struct }IContext\par
4594     \{\par
4595         {\cf17 virtual} ~IContext();\par
4596 \par
4597         {\cf17 virtual} IResultCapture* getResultCapture() = 0;\par
4598         {\cf17 virtual} IRunner* getRunner() = 0;\par
4599         {\cf17 virtual} IConfigPtr {\cf17 const}& getConfig() {\cf17 const} = 0;\par
4600     \};\par
4601 \par
4602     {\cf17 struct }IMutableContext : IContext\par
4603     \{\par
4604         {\cf17 virtual} ~IMutableContext();\par
4605         {\cf17 virtual} {\cf18 void} setResultCapture( IResultCapture* resultCapture ) = 0;\par
4606         {\cf17 virtual} {\cf18 void} setRunner( IRunner* runner ) = 0;\par
4607         {\cf17 virtual} {\cf18 void} setConfig( IConfigPtr {\cf17 const}& config ) = 0;\par
4608 \par
4609     {\cf17 private}:\par
4610         {\cf17 static} IMutableContext *currentContext;\par
4611         {\cf17 friend} IMutableContext& getCurrentMutableContext();\par
4612         {\cf17 friend} {\cf18 void} cleanUpContext();\par
4613         {\cf17 static} {\cf18 void} createContext();\par
4614     \};\par
4615 \par
4616     {\cf17 inline} IMutableContext& getCurrentMutableContext()\par
4617     \{\par
4618         {\cf19 if}( !IMutableContext::currentContext )\par
4619             IMutableContext::createContext();\par
4620         {\cf19 return} *IMutableContext::currentContext;\par
4621     \}\par
4622 \par
4623     {\cf17 inline} IContext& getCurrentContext()\par
4624     \{\par
4625         {\cf19 return} getCurrentMutableContext();\par
4626     \}\par
4627 \par
4628     {\cf18 void} cleanUpContext();\par
4629 \}\par
4630 \par
4631 {\cf20 // end catch_context.h}\par
4632 {\cf20 // start catch_debugger.h}\par
4633 \par
4634 {\cf17 namespace }Catch \{\par
4635     {\cf18 bool} isDebuggerActive();\par
4636 \}\par
4637 \par
4638 {\cf21 #ifdef CATCH_PLATFORM_MAC}\par
4639 \par
4640 {\cf21     #define CATCH_TRAP() __asm__("int $3\\n"} : : ) {\cf20 /* NOLINT */}{\cf21 }\par
4641 \par
4642 {\cf21 #elif defined(CATCH_PLATFORM_LINUX)}\par
4643     {\cf20 // If we can use inline assembler, do it because this allows us to break}\par
4644     {\cf20 // directly at the location of the failing check instead of breaking inside}\par
4645     {\cf20 // raise() called from it, i.e. one stack frame below.}\par
4646 {\cf21     #if defined(__GNUC__) && (defined(__i386) || defined(__x86_64))}\par
4647 {\cf21         #define CATCH_TRAP() asm volatile ("int $3"}) {\cf20 /* NOLINT */}{\cf21 }\par
4648 {\cf21     #else }{\cf20 // Fall back to the generic way.}\par
4649 {\cf21         #include <signal.h>}\par
4650 \par
4651 {\cf21         #define CATCH_TRAP() raise(SIGTRAP)}\par
4652 {\cf21     #endif}\par
4653 {\cf21 #elif defined(_MSC_VER)}\par
4654 {\cf21     #define CATCH_TRAP() __debugbreak()}\par
4655 {\cf21 #elif defined(__MINGW32__)}\par
4656     {\cf17 extern} {\cf22 "C"} __declspec(dllimport) {\cf18 void} __stdcall DebugBreak();\par
4657 {\cf21     #define CATCH_TRAP() DebugBreak()}\par
4658 {\cf21 #endif}\par
4659 \par
4660 {\cf21 #ifdef CATCH_TRAP}\par
4661 {\cf21     #define CATCH_BREAK_INTO_DEBUGGER() if( Catch::isDebuggerActive() ) \{ CATCH_TRAP(); \}}\par
4662 {\cf21 #else}\par
4663     {\cf17 namespace }Catch \{\par
4664         {\cf17 inline} {\cf18 void} doNothing() \{\}\par
4665     \}\par
4666 {\cf21     #define CATCH_BREAK_INTO_DEBUGGER() Catch::doNothing()}\par
4667 {\cf21 #endif}\par
4668 \par
4669 {\cf20 // end catch_debugger.h}\par
4670 {\cf20 // start catch_run_context.h}\par
4671 \par
4672 {\cf20 // start catch_fatal_condition.h}\par
4673 \par
4674 {\cf20 // start catch_windows_h_proxy.h}\par
4675 \par
4676 \par
4677 {\cf21 #if defined(CATCH_PLATFORM_WINDOWS)}\par
4678 \par
4679 {\cf21 #if !defined(NOMINMAX) && !defined(CATCH_CONFIG_NO_NOMINMAX)}\par
4680 {\cf21 #  define CATCH_DEFINED_NOMINMAX}\par
4681 {\cf21 #  define NOMINMAX}\par
4682 {\cf21 #endif}\par
4683 {\cf21 #if !defined(WIN32_LEAN_AND_MEAN) && !defined(CATCH_CONFIG_NO_WIN32_LEAN_AND_MEAN)}\par
4684 {\cf21 #  define CATCH_DEFINED_WIN32_LEAN_AND_MEAN}\par
4685 {\cf21 #  define WIN32_LEAN_AND_MEAN}\par
4686 {\cf21 #endif}\par
4687 \par
4688 {\cf21 #ifdef __AFXDLL}\par
4689 {\cf21 #include <AfxWin.h>}\par
4690 {\cf21 #else}\par
4691 {\cf21 #include <windows.h>}\par
4692 {\cf21 #endif}\par
4693 \par
4694 {\cf21 #ifdef CATCH_DEFINED_NOMINMAX}\par
4695 {\cf21 #  undef NOMINMAX}\par
4696 {\cf21 #endif}\par
4697 {\cf21 #ifdef CATCH_DEFINED_WIN32_LEAN_AND_MEAN}\par
4698 {\cf21 #  undef WIN32_LEAN_AND_MEAN}\par
4699 {\cf21 #endif}\par
4700 \par
4701 {\cf21 #endif }{\cf20 // defined(CATCH_PLATFORM_WINDOWS)}\par
4702 \par
4703 {\cf20 // end catch_windows_h_proxy.h}\par
4704 {\cf21 #if defined( CATCH_CONFIG_WINDOWS_SEH )}\par
4705 \par
4706 {\cf17 namespace }Catch \{\par
4707 \par
4708     {\cf17 struct }FatalConditionHandler \{\par
4709 \par
4710         {\cf17 static} LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo);\par
4711         FatalConditionHandler();\par
4712         {\cf17 static} {\cf18 void} reset();\par
4713         ~FatalConditionHandler();\par
4714 \par
4715     {\cf17 private}:\par
4716         {\cf17 static} {\cf18 bool} isSet;\par
4717         {\cf17 static} ULONG guaranteeSize;\par
4718         {\cf17 static} PVOID exceptionHandlerHandle;\par
4719     \};\par
4720 \par
4721 \} {\cf20 // namespace Catch}\par
4722 \par
4723 {\cf21 #elif defined ( CATCH_CONFIG_POSIX_SIGNALS )}\par
4724 \par
4725 {\cf21 #include <signal.h>}\par
4726 \par
4727 {\cf17 namespace }Catch \{\par
4728 \par
4729     {\cf17 struct }FatalConditionHandler \{\par
4730 \par
4731         {\cf17 static} {\cf18 bool} isSet;\par
4732         {\cf17 static} {\cf17 struct }sigaction oldSigActions[];\par
4733         {\cf17 static} stack_t oldSigStack;\par
4734         {\cf17 static} {\cf18 char} altStackMem[];\par
4735 \par
4736         {\cf17 static} {\cf18 void} handleSignal( {\cf18 int} sig );\par
4737 \par
4738         FatalConditionHandler();\par
4739         ~FatalConditionHandler();\par
4740         {\cf17 static} {\cf18 void} reset();\par
4741     \};\par
4742 \par
4743 \} {\cf20 // namespace Catch}\par
4744 \par
4745 {\cf21 #else}\par
4746 \par
4747 {\cf17 namespace }Catch \{\par
4748     {\cf17 struct }FatalConditionHandler \{\par
4749         {\cf18 void} reset();\par
4750     \};\par
4751 \}\par
4752 \par
4753 {\cf21 #endif}\par
4754 \par
4755 {\cf20 // end catch_fatal_condition.h}\par
4756 {\cf21 #include <string>}\par
4757 \par
4758 {\cf17 namespace }Catch \{\par
4759 \par
4760     {\cf17 struct }IMutableContext;\par
4761 \par
4763 \par
4764     {\cf17 class }RunContext : {\cf17 public} IResultCapture, {\cf17 public} IRunner \{\par
4765 \par
4766     {\cf17 public}:\par
4767         RunContext( RunContext {\cf17 const}& ) = {\cf17 delete};\par
4768         RunContext& operator =( RunContext {\cf17 const}& ) = {\cf17 delete};\par
4769 \par
4770         {\cf17 explicit} RunContext( IConfigPtr {\cf17 const}& _config, IStreamingReporterPtr&& reporter );\par
4771 \par
4772         ~RunContext() {\cf17 override};\par
4773 \par
4774         {\cf18 void} testGroupStarting( std::string {\cf17 const}& testSpec, std::size_t groupIndex, std::size_t groupsCount );\par
4775         {\cf18 void} testGroupEnded( std::string {\cf17 const}& testSpec, Totals {\cf17 const}& totals, std::size_t groupIndex, std::size_t groupsCount );\par
4776 \par
4777         Totals runTest(TestCase {\cf17 const}& testCase);\par
4778 \par
4779         IConfigPtr config() {\cf17 const};\par
4780         IStreamingReporter& reporter() {\cf17 const};\par
4781 \par
4782     {\cf17 public}: {\cf20 // IResultCapture}\par
4783 \par
4784         {\cf20 // Assertion handlers}\par
4785         {\cf18 void} handleExpr\par
4786                 (   AssertionInfo {\cf17 const}& info,\par
4787                     ITransientExpression {\cf17 const}& expr,\par
4788                     AssertionReaction& reaction ) {\cf17 override};\par
4789         {\cf18 void} handleMessage\par
4790                 (   AssertionInfo {\cf17 const}& info,\par
4791                     ResultWas::OfType resultType,\par
4792                     StringRef {\cf17 const}& message,\par
4793                     AssertionReaction& reaction ) {\cf17 override};\par
4794         {\cf18 void} handleUnexpectedExceptionNotThrown\par
4795                 (   AssertionInfo {\cf17 const}& info,\par
4796                     AssertionReaction& reaction ) {\cf17 override};\par
4797         {\cf18 void} handleUnexpectedInflightException\par
4798                 (   AssertionInfo {\cf17 const}& info,\par
4799                     std::string {\cf17 const}& message,\par
4800                     AssertionReaction& reaction ) {\cf17 override};\par
4801         {\cf18 void} handleIncomplete\par
4802                 (   AssertionInfo {\cf17 const}& info ) {\cf17 override};\par
4803         {\cf18 void} handleNonExpr\par
4804                 (   AssertionInfo {\cf17 const} &info,\par
4805                     ResultWas::OfType resultType,\par
4806                     AssertionReaction &reaction ) {\cf17 override};\par
4807 \par
4808         {\cf18 bool} sectionStarted( SectionInfo {\cf17 const}& sectionInfo, Counts& assertions ) {\cf17 override};\par
4809 \par
4810         {\cf18 void} sectionEnded( SectionEndInfo {\cf17 const}& endInfo ) {\cf17 override};\par
4811         {\cf18 void} sectionEndedEarly( SectionEndInfo {\cf17 const}& endInfo ) {\cf17 override};\par
4812 \par
4813         {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& info ) {\cf17 override};\par
4814         {\cf18 void} benchmarkEnded( BenchmarkStats {\cf17 const}& stats ) {\cf17 override};\par
4815 \par
4816         {\cf18 void} pushScopedMessage( MessageInfo {\cf17 const}& message ) {\cf17 override};\par
4817         {\cf18 void} popScopedMessage( MessageInfo {\cf17 const}& message ) {\cf17 override};\par
4818 \par
4819         std::string getCurrentTestName() {\cf17 const override};\par
4820 \par
4821         {\cf17 const} AssertionResult* getLastResult() {\cf17 const override};\par
4822 \par
4823         {\cf18 void} exceptionEarlyReported() {\cf17 override};\par
4824 \par
4825         {\cf18 void} handleFatalErrorCondition( StringRef message ) {\cf17 override};\par
4826 \par
4827         {\cf18 bool} lastAssertionPassed() {\cf17 override};\par
4828 \par
4829         {\cf18 void} assertionPassed() {\cf17 override};\par
4830 \par
4831     {\cf17 public}:\par
4832         {\cf20 // !TBD We need to do this another way!}\par
4833         {\cf18 bool} aborting() {\cf17 const override};\par
4834 \par
4835     {\cf17 private}:\par
4836 \par
4837         {\cf18 void} runCurrentTest( std::string& redirectedCout, std::string& redirectedCerr );\par
4838         {\cf18 void} invokeActiveTestCase();\par
4839 \par
4840         {\cf18 void} resetAssertionInfo();\par
4841         {\cf18 bool} testForMissingAssertions( Counts& assertions );\par
4842 \par
4843         {\cf18 void} assertionEnded( AssertionResult {\cf17 const}& result );\par
4844         {\cf18 void} reportExpr\par
4845                 (   AssertionInfo {\cf17 const} &info,\par
4846                     ResultWas::OfType resultType,\par
4847                     ITransientExpression {\cf17 const} *expr,\par
4848                     {\cf18 bool} negated );\par
4849 \par
4850         {\cf18 void} populateReaction( AssertionReaction& reaction );\par
4851 \par
4852     {\cf17 private}:\par
4853 \par
4854         {\cf18 void} handleUnfinishedSections();\par
4855 \par
4856         TestRunInfo m_runInfo;\par
4857         IMutableContext& m_context;\par
4858         TestCase {\cf17 const}* m_activeTestCase = {\cf17 nullptr};\par
4859         ITracker* m_testCaseTracker;\par
4860         Option<AssertionResult> m_lastResult;\par
4861 \par
4862         IConfigPtr m_config;\par
4863         Totals m_totals;\par
4864         IStreamingReporterPtr m_reporter;\par
4865         std::vector<MessageInfo> m_messages;\par
4866         AssertionInfo m_lastAssertionInfo;\par
4867         std::vector<SectionEndInfo> m_unfinishedSections;\par
4868         std::vector<ITracker*> m_activeSections;\par
4869         TrackerContext m_trackerContext;\par
4870         {\cf18 bool} m_lastAssertionPassed = {\cf17 false};\par
4871         {\cf18 bool} m_shouldReportUnexpected = {\cf17 true};\par
4872         {\cf18 bool} m_includeSuccessfulResults;\par
4873     \};\par
4874 \par
4875 \} {\cf20 // end namespace Catch}\par
4876 \par
4877 {\cf20 // end catch_run_context.h}\par
4878 {\cf17 namespace }Catch \{\par
4879 \par
4880     {\cf17 auto} operator <<( std::ostream& os, ITransientExpression {\cf17 const}& expr ) -> std::ostream& \{\par
4881         expr.streamReconstructedExpression( os );\par
4882         {\cf19 return} os;\par
4883     \}\par
4884 \par
4885     LazyExpression::LazyExpression( {\cf18 bool} isNegated )\par
4886     :   m_isNegated( isNegated )\par
4887     \{\}\par
4888 \par
4889     LazyExpression::LazyExpression( LazyExpression {\cf17 const}& other ) : m_isNegated( other.m_isNegated ) \{\}\par
4890 \par
4891     LazyExpression::operator bool(){\cf17  const }\{\par
4892         {\cf19 return} m_transientExpression != {\cf17 nullptr};\par
4893     \}\par
4894 \par
4895     {\cf17 auto} operator << ( std::ostream& os, LazyExpression {\cf17 const}& lazyExpr ) -> std::ostream& \{\par
4896         {\cf19 if}( lazyExpr.m_isNegated )\par
4897             os << {\cf22 "!"};\par
4898 \par
4899         {\cf19 if}( lazyExpr ) \{\par
4900             {\cf19 if}( lazyExpr.m_isNegated && lazyExpr.m_transientExpression->isBinaryExpression() )\par
4901                 os << {\cf22 "("} << *lazyExpr.m_transientExpression << {\cf22 ")"};\par
4902             {\cf19 else}\par
4903                 os << *lazyExpr.m_transientExpression;\par
4904         \}\par
4905         {\cf19 else} \{\par
4906             os << {\cf22 "\{** error - unchecked empty expression requested **\}"};\par
4907         \}\par
4908         {\cf19 return} os;\par
4909     \}\par
4910 \par
4911     AssertionHandler::AssertionHandler\par
4912         (   StringRef macroName,\par
4913             SourceLineInfo {\cf17 const}& lineInfo,\par
4914             StringRef capturedExpression,\par
4915             ResultDisposition::Flags resultDisposition )\par
4916     :   m_assertionInfo\{ macroName, lineInfo, capturedExpression, resultDisposition \},\par
4917         m_resultCapture( getResultCapture() )\par
4918     \{\}\par
4919 \par
4920     {\cf18 void} AssertionHandler::handleExpr( ITransientExpression {\cf17 const}& expr ) \{\par
4921         m_resultCapture.handleExpr( m_assertionInfo, expr, m_reaction );\par
4922     \}\par
4923     {\cf18 void} AssertionHandler::handleMessage(ResultWas::OfType resultType, StringRef {\cf17 const}& message) \{\par
4924         m_resultCapture.handleMessage( m_assertionInfo, resultType, message, m_reaction );\par
4925     \}\par
4926 \par
4927     {\cf17 auto} AssertionHandler::allowThrows() const -> {\cf18 bool} \{\par
4928         {\cf19 return} getCurrentContext().getConfig()->allowThrows();\par
4929     \}\par
4930 \par
4931     {\cf18 void} AssertionHandler::complete() \{\par
4932         setCompleted();\par
4933         {\cf19 if}( m_reaction.shouldDebugBreak ) \{\par
4934 \par
4935             {\cf20 // If you find your debugger stopping you here then go one level up on the}\par
4936             {\cf20 // call-stack for the code that caused it (typically a failed assertion)}\par
4937 \par
4938             {\cf20 // (To go back to the test and change execution, jump over the throw, next)}\par
4939             CATCH_BREAK_INTO_DEBUGGER();\par
4940         \}\par
4941         {\cf19 if}( m_reaction.shouldThrow )\par
4942             {\cf19 throw} Catch::TestFailureException();\par
4943     \}\par
4944     {\cf18 void} AssertionHandler::setCompleted() \{\par
4945         m_completed = {\cf17 true};\par
4946     \}\par
4947 \par
4948     {\cf18 void} AssertionHandler::handleUnexpectedInflightException() \{\par
4949         m_resultCapture.handleUnexpectedInflightException( m_assertionInfo, Catch::translateActiveException(), m_reaction );\par
4950     \}\par
4951 \par
4952     {\cf18 void} AssertionHandler::handleExceptionThrownAsExpected() \{\par
4953         m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);\par
4954     \}\par
4955     {\cf18 void} AssertionHandler::handleExceptionNotThrownAsExpected() \{\par
4956         m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);\par
4957     \}\par
4958 \par
4959     {\cf18 void} AssertionHandler::handleUnexpectedExceptionNotThrown() \{\par
4960         m_resultCapture.handleUnexpectedExceptionNotThrown( m_assertionInfo, m_reaction );\par
4961     \}\par
4962 \par
4963     {\cf18 void} AssertionHandler::handleThrowingCallSkipped() \{\par
4964         m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);\par
4965     \}\par
4966 \par
4967     {\cf20 // This is the overload that takes a string and infers the Equals matcher from it}\par
4968     {\cf20 // The more general overload, that takes any string matcher, is in catch_capture_matchers.cpp}\par
4969     {\cf18 void} handleExceptionMatchExpr( AssertionHandler& handler, std::string {\cf17 const}& str, StringRef matcherString  ) \{\par
4970         handleExceptionMatchExpr( handler, Matchers::Equals( str ), matcherString );\par
4971     \}\par
4972 \par
4973 \} {\cf20 // namespace Catch}\par
4974 {\cf20 // end catch_assertionhandler.cpp}\par
4975 {\cf20 // start catch_assertionresult.cpp}\par
4976 \par
4977 {\cf17 namespace }Catch \{\par
4978     AssertionResultData::AssertionResultData(ResultWas::OfType _resultType, LazyExpression {\cf17 const} & _lazyExpression):\par
4979         lazyExpression(_lazyExpression),\par
4980         resultType(_resultType) \{\}\par
4981 \par
4982     std::string AssertionResultData::reconstructExpression(){\cf17  const }\{\par
4983 \par
4984         {\cf19 if}( reconstructedExpression.empty() ) \{\par
4985             {\cf19 if}( lazyExpression ) \{\par
4986                 ReusableStringStream rss;\par
4987                 rss << lazyExpression;\par
4988                 reconstructedExpression = rss.str();\par
4989             \}\par
4990         \}\par
4991         {\cf19 return} reconstructedExpression;\par
4992     \}\par
4993 \par
4994     AssertionResult::AssertionResult( AssertionInfo {\cf17 const}& info, AssertionResultData {\cf17 const}& data )\par
4995     :   m_info( info ),\par
4996         m_resultData( data )\par
4997     \{\}\par
4998 \par
4999     {\cf20 // Result was a success}\par
5000     {\cf18 bool} AssertionResult::succeeded(){\cf17  const }\{\par
5001         {\cf19 return} Catch::isOk( m_resultData.resultType );\par
5002     \}\par
5003 \par
5004     {\cf20 // Result was a success, or failure is suppressed}\par
5005     {\cf18 bool} AssertionResult::isOk(){\cf17  const }\{\par
5006         {\cf19 return} Catch::isOk( m_resultData.resultType ) || shouldSuppressFailure( m_info.resultDisposition );\par
5007     \}\par
5008 \par
5009     ResultWas::OfType AssertionResult::getResultType(){\cf17  const }\{\par
5010         {\cf19 return} m_resultData.resultType;\par
5011     \}\par
5012 \par
5013     {\cf18 bool} AssertionResult::hasExpression(){\cf17  const }\{\par
5014         {\cf19 return} m_info.capturedExpression[0] != 0;\par
5015     \}\par
5016 \par
5017     {\cf18 bool} AssertionResult::hasMessage(){\cf17  const }\{\par
5018         {\cf19 return} !m_resultData.message.empty();\par
5019     \}\par
5020 \par
5021     std::string AssertionResult::getExpression(){\cf17  const }\{\par
5022         {\cf19 if}( isFalseTest( m_info.resultDisposition ) )\par
5023             {\cf19 return} {\cf22 "!("} + m_info.capturedExpression + ")";\par
5024         {\cf19 else}\par
5025             {\cf19 return} m_info.capturedExpression;\par
5026     \}\par
5027 \par
5028     std::string AssertionResult::getExpressionInMacro(){\cf17  const }\{\par
5029         std::string expr;\par
5030         {\cf19 if}( m_info.macroName[0] == 0 )\par
5031             expr = m_info.capturedExpression;\par
5032         {\cf19 else} \{\par
5033             expr.reserve( m_info.macroName.size() + m_info.capturedExpression.size() + 4 );\par
5034             expr += m_info.macroName;\par
5035             expr += "( ";\par
5036             expr += m_info.capturedExpression;\par
5037             expr += " )";\par
5038         \}\par
5039         {\cf19 return} expr;\par
5040     \}\par
5041 \par
5042     {\cf18 bool} AssertionResult::hasExpandedExpression(){\cf17  const }\{\par
5043         {\cf19 return} hasExpression() && getExpandedExpression() != getExpression();\par
5044     \}\par
5045 \par
5046     std::string AssertionResult::getExpandedExpression(){\cf17  const }\{\par
5047         std::string expr = m_resultData.reconstructExpression();\par
5048         {\cf19 return} expr.empty()\par
5049                 ? getExpression()\par
5050                 : expr;\par
5051     \}\par
5052 \par
5053     std::string AssertionResult::getMessage(){\cf17  const }\{\par
5054         {\cf19 return} m_resultData.message;\par
5055     \}\par
5056     SourceLineInfo AssertionResult::getSourceInfo(){\cf17  const }\{\par
5057         {\cf19 return} m_info.lineInfo;\par
5058     \}\par
5059 \par
5060     StringRef AssertionResult::getTestMacroName(){\cf17  const }\{\par
5061         {\cf19 return} m_info.macroName;\par
5062     \}\par
5063 \par
5064 \} {\cf20 // end namespace Catch}\par
5065 {\cf20 // end catch_assertionresult.cpp}\par
5066 {\cf20 // start catch_benchmark.cpp}\par
5067 \par
5068 {\cf17 namespace }Catch \{\par
5069 \par
5070     {\cf17 auto} BenchmarkLooper::getResolution() -> uint64_t \{\par
5071         {\cf19 return} getEstimatedClockResolution() * getCurrentContext().getConfig()->benchmarkResolutionMultiple();\par
5072     \}\par
5073 \par
5074     {\cf18 void} BenchmarkLooper::reportStart() \{\par
5075         getResultCapture().benchmarkStarting( \{ m_name \} );\par
5076     \}\par
5077     {\cf17 auto} BenchmarkLooper::needsMoreIterations() -> {\cf18 bool} \{\par
5078         {\cf17 auto} elapsed = m_timer.getElapsedNanoseconds();\par
5079 \par
5080         {\cf20 // Exponentially increasing iterations until we're confident in our timer resolution}\par
5081         {\cf19 if}( elapsed < m_resolution ) \{\par
5082             m_iterationsToRun *= 10;\par
5083             {\cf19 return} {\cf17 true};\par
5084         \}\par
5085 \par
5086         getResultCapture().benchmarkEnded( \{ \{ m_name \}, m_count, elapsed \} );\par
5087         {\cf19 return} {\cf17 false};\par
5088     \}\par
5089 \par
5090 \} {\cf20 // end namespace Catch}\par
5091 {\cf20 // end catch_benchmark.cpp}\par
5092 {\cf20 // start catch_capture_matchers.cpp}\par
5093 \par
5094 {\cf17 namespace }Catch \{\par
5095 \par
5096     {\cf17 using }StringMatcher = Matchers::Impl::MatcherBase<std::string>;\par
5097 \par
5098     {\cf20 // This is the general overload that takes a any string matcher}\par
5099     {\cf20 // There is another overload, in catch_assertionhandler.h/.cpp, that only takes a string and infers}\par
5100     {\cf20 // the Equals matcher (so the header does not mention matchers)}\par
5101     {\cf18 void} handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher {\cf17 const}& matcher, StringRef matcherString  ) \{\par
5102         std::string exceptionMessage = Catch::translateActiveException();\par
5103         MatchExpr<std::string, StringMatcher const&> expr( exceptionMessage, matcher, matcherString );\par
5104         handler.handleExpr( expr );\par
5105     \}\par
5106 \par
5107 \} {\cf20 // namespace Catch}\par
5108 {\cf20 // end catch_capture_matchers.cpp}\par
5109 {\cf20 // start catch_commandline.cpp}\par
5110 \par
5111 {\cf20 // start catch_commandline.h}\par
5112 \par
5113 {\cf20 // start catch_clara.h}\par
5114 \par
5115 {\cf20 // Use Catch's value for console width (store Clara's off to the side, if present)}\par
5116 {\cf21 #ifdef CLARA_CONFIG_CONSOLE_WIDTH}\par
5117 {\cf21 #define CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH}\par
5118 {\cf21 #undef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH}\par
5119 {\cf21 #endif}\par
5120 {\cf21 #define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH-1}\par
5121 \par
5122 {\cf21 #ifdef __clang__}\par
5123 {\cf21 #pragma clang diagnostic push}\par
5124 {\cf21 #pragma clang diagnostic ignored "-Wweak-vtables"}\par
5125 {\cf21 #pragma clang diagnostic ignored "-Wexit-time-destructors"}\par
5126 {\cf21 #pragma clang diagnostic ignored "-Wshadow"}\par
5127 {\cf21 #endif}\par
5128 \par
5129 {\cf20 // start clara.hpp}\par
5130 {\cf20 // Copyright 2017 Two Blue Cubes Ltd. All rights reserved.}\par
5131 {\cf20 //}\par
5132 {\cf20 // Distributed under the Boost Software License, Version 1.0. (See accompanying}\par
5133 {\cf20 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)}\par
5134 {\cf20 //}\par
5135 {\cf20 // See https://github.com/philsquared/Clara for more details}\par
5136 \par
5137 {\cf20 // Clara v1.1.4}\par
5138 \par
5139 \par
5140 {\cf21 #ifndef CATCH_CLARA_CONFIG_CONSOLE_WIDTH}\par
5141 {\cf21 #define CATCH_CLARA_CONFIG_CONSOLE_WIDTH 80}\par
5142 {\cf21 #endif}\par
5143 \par
5144 {\cf21 #ifndef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH}\par
5145 {\cf21 #define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_CLARA_CONFIG_CONSOLE_WIDTH}\par
5146 {\cf21 #endif}\par
5147 \par
5148 {\cf21 #ifndef CLARA_CONFIG_OPTIONAL_TYPE}\par
5149 {\cf21 #ifdef __has_include}\par
5150 {\cf21 #if __has_include(<optional>) && __cplusplus >= 201703L}\par
5151 {\cf21 #include <optional>}\par
5152 {\cf21 #define CLARA_CONFIG_OPTIONAL_TYPE std::optional}\par
5153 {\cf21 #endif}\par
5154 {\cf21 #endif}\par
5155 {\cf21 #endif}\par
5156 \par
5157 {\cf20 // ----------- #included from clara_textflow.hpp -----------}\par
5158 \par
5159 {\cf20 // TextFlowCpp}\par
5160 {\cf20 //}\par
5161 {\cf20 // A single-header library for wrapping and laying out basic text, by Phil Nash}\par
5162 {\cf20 //}\par
5163 {\cf20 // This work is licensed under the BSD 2-Clause license.}\par
5164 {\cf20 // See the accompanying LICENSE file, or the one at https://opensource.org/licenses/BSD-2-Clause}\par
5165 {\cf20 //}\par
5166 {\cf20 // This project is hosted at https://github.com/philsquared/textflowcpp}\par
5167 \par
5168 \par
5169 {\cf21 #include <cassert>}\par
5170 {\cf21 #include <ostream>}\par
5171 {\cf21 #include <sstream>}\par
5172 {\cf21 #include <vector>}\par
5173 \par
5174 {\cf21 #ifndef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH}\par
5175 {\cf21 #define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH 80}\par
5176 {\cf21 #endif}\par
5177 \par
5178 {\cf17 namespace }Catch \{ {\cf17 namespace }clara \{ {\cf17 namespace }TextFlow \{\par
5179 \par
5180     {\cf17 inline} {\cf17 auto} isWhitespace( {\cf18 char} c ) -> {\cf18 bool} \{\par
5181         {\cf17 static} std::string chars = {\cf22 " \\t\\n\\r"};\par
5182         {\cf19 return} chars.find( c ) != std::string::npos;\par
5183     \}\par
5184     {\cf17 inline} {\cf17 auto} isBreakableBefore( {\cf18 char} c ) -> {\cf18 bool} \{\par
5185         {\cf17 static} std::string chars = {\cf22 "[(\{<|"};\par
5186         {\cf19 return} chars.find( c ) != std::string::npos;\par
5187     \}\par
5188     {\cf17 inline} {\cf17 auto} isBreakableAfter( {\cf18 char} c ) -> {\cf18 bool} \{\par
5189         {\cf17 static} std::string chars = {\cf22 "])\}>.,:;*+-=&/\\\\"};\par
5190         {\cf19 return} chars.find( c ) != std::string::npos;\par
5191     \}\par
5192 \par
5193     {\cf17 class }Columns;\par
5194 \par
5195     {\cf17 class }Column \{\par
5196         std::vector<std::string> m_strings;\par
5197         {\cf18 size_t} m_width = CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH;\par
5198         {\cf18 size_t} m_indent = 0;\par
5199         {\cf18 size_t} m_initialIndent = std::string::npos;\par
5200 \par
5201     {\cf17 public}:\par
5202         {\cf17 class }iterator \{\par
5203             {\cf17 friend} Column;\par
5204 \par
5205             Column {\cf17 const}& m_column;\par
5206             {\cf18 size_t} m_stringIndex = 0;\par
5207             {\cf18 size_t} m_pos = 0;\par
5208 \par
5209             {\cf18 size_t} m_len = 0;\par
5210             {\cf18 size_t} m_end = 0;\par
5211             {\cf18 bool} m_suffix = {\cf17 false};\par
5212 \par
5213             iterator( Column {\cf17 const}& column, {\cf18 size_t} stringIndex )\par
5214             :   m_column( column ),\par
5215                 m_stringIndex( stringIndex )\par
5216             \{\}\par
5217 \par
5218             {\cf17 auto} line() const -> std::{\cf18 string} const& \{ {\cf19 return} m_column.m_strings[m_stringIndex]; \}\par
5219 \par
5220             {\cf17 auto} isBoundary( {\cf18 size_t} at ) {\cf17 const} -> {\cf18 bool} \{\par
5221                 assert( at > 0 );\par
5222                 assert( at <= line().size() );\par
5223 \par
5224                 {\cf19 return} at == line().size() ||\par
5225                        ( isWhitespace( line()[at] ) && !isWhitespace( line()[at-1] ) ) ||\par
5226                        isBreakableBefore( line()[at] ) ||\par
5227                        isBreakableAfter( line()[at-1] );\par
5228             \}\par
5229 \par
5230             {\cf18 void} calcLength() \{\par
5231                 assert( m_stringIndex < m_column.m_strings.size() );\par
5232 \par
5233                 m_suffix = {\cf17 false};\par
5234                 {\cf17 auto} width = m_column.m_width-indent();\par
5235                 m_end = m_pos;\par
5236                 {\cf19 while}( m_end < line().size() && line()[m_end] != {\cf23 '\\n'} )\par
5237                     ++m_end;\par
5238 \par
5239                 {\cf19 if}( m_end < m_pos + width ) \{\par
5240                     m_len = m_end - m_pos;\par
5241                 \}\par
5242                 {\cf19 else} \{\par
5243                     {\cf18 size_t} len = width;\par
5244                     {\cf19 while} (len > 0 && !isBoundary(m_pos + len))\par
5245                         --len;\par
5246                     {\cf19 while} (len > 0 && isWhitespace( line()[m_pos + len - 1] ))\par
5247                         --len;\par
5248 \par
5249                     {\cf19 if} (len > 0) \{\par
5250                         m_len = len;\par
5251                     \} {\cf19 else} \{\par
5252                         m_suffix = {\cf17 true};\par
5253                         m_len = width - 1;\par
5254                     \}\par
5255                 \}\par
5256             \}\par
5257 \par
5258             {\cf17 auto} indent() const -> {\cf18 size_t} \{\par
5259                 {\cf17 auto} initial = m_pos == 0 && m_stringIndex == 0 ? m_column.m_initialIndent : std::string::npos;\par
5260                 {\cf19 return} initial == std::string::npos ? m_column.m_indent : initial;\par
5261             \}\par
5262 \par
5263             {\cf17 auto} addIndentAndSuffix(std::string {\cf17 const} &plain) {\cf17 const} -> std::string \{\par
5264                 {\cf19 return} std::string( indent(), {\cf23 ' '} ) + (m_suffix ? plain + "-" : plain);\par
5265             \}\par
5266 \par
5267         {\cf17 public}:\par
5268             {\cf17 explicit} iterator( Column {\cf17 const}& column ) : m_column( column ) \{\par
5269                 assert( m_column.m_width > m_column.m_indent );\par
5270                 assert( m_column.m_initialIndent == std::string::npos || m_column.m_width > m_column.m_initialIndent );\par
5271                 calcLength();\par
5272                 {\cf19 if}( m_len == 0 )\par
5273                     m_stringIndex++; {\cf20 // Empty string}\par
5274             \}\par
5275 \par
5276             {\cf17 auto} operator *() const -> std::{\cf18 string} \{\par
5277                 assert( m_stringIndex < m_column.m_strings.size() );\par
5278                 assert( m_pos <= m_end );\par
5279                 {\cf19 if}( m_pos + m_column.m_width < m_end )\par
5280                     {\cf19 return} addIndentAndSuffix(line().substr(m_pos, m_len));\par
5281                 {\cf19 else}\par
5282                     {\cf19 return} addIndentAndSuffix(line().substr(m_pos, m_end - m_pos));\par
5283             \}\par
5284 \par
5285             {\cf17 auto} operator ++() -> iterator& \{\par
5286                 m_pos += m_len;\par
5287                 {\cf19 if}( m_pos < line().size() && line()[m_pos] == {\cf23 '\\n'} )\par
5288                     m_pos += 1;\par
5289                 {\cf19 else}\par
5290                     {\cf19 while}( m_pos < line().size() && isWhitespace( line()[m_pos] ) )\par
5291                         ++m_pos;\par
5292 \par
5293                 {\cf19 if}( m_pos == line().size() ) \{\par
5294                     m_pos = 0;\par
5295                     ++m_stringIndex;\par
5296                 \}\par
5297                 {\cf19 if}( m_stringIndex < m_column.m_strings.size() )\par
5298                     calcLength();\par
5299                 {\cf19 return} *{\cf17 this};\par
5300             \}\par
5301             {\cf17 auto} operator ++({\cf18 int}) -> iterator \{\par
5302                 iterator prev( *{\cf17 this} );\par
5303                 operator++();\par
5304                 {\cf19 return} prev;\par
5305             \}\par
5306 \par
5307             {\cf17 auto} operator ==( iterator {\cf17 const}& other ) {\cf17 const} -> {\cf18 bool} \{\par
5308                 {\cf19 return}\par
5309                     m_pos == other.m_pos &&\par
5310                     m_stringIndex == other.m_stringIndex &&\par
5311                     &m_column == &other.m_column;\par
5312             \}\par
5313             {\cf17 auto} operator !=( iterator {\cf17 const}& other ) {\cf17 const} -> {\cf18 bool} \{\par
5314                 {\cf19 return} !operator==( other );\par
5315             \}\par
5316         \};\par
5317         {\cf17 using }const_iterator = iterator;\par
5318 \par
5319         {\cf17 explicit} Column( std::string {\cf17 const}& text ) \{ m_strings.push_back( text ); \}\par
5320 \par
5321         {\cf17 auto} width( {\cf18 size_t} newWidth ) -> Column& \{\par
5322             assert( newWidth > 0 );\par
5323             m_width = newWidth;\par
5324             {\cf19 return} *{\cf17 this};\par
5325         \}\par
5326         {\cf17 auto} indent( {\cf18 size_t} newIndent ) -> Column& \{\par
5327             m_indent = newIndent;\par
5328             {\cf19 return} *{\cf17 this};\par
5329         \}\par
5330         {\cf17 auto} initialIndent( {\cf18 size_t} newIndent ) -> Column& \{\par
5331             m_initialIndent = newIndent;\par
5332             {\cf19 return} *{\cf17 this};\par
5333         \}\par
5334 \par
5335         {\cf17 auto} width() const -> {\cf18 size_t} \{ {\cf19 return} m_width; \}\par
5336         {\cf17 auto} begin() const -> iterator \{ {\cf19 return} iterator( *{\cf17 this} ); \}\par
5337         {\cf17 auto} end() const -> iterator \{ {\cf19 return} \{ *{\cf17 this}, m_strings.size() \}; \}\par
5338 \par
5339         {\cf17 inline} {\cf17 friend} std::ostream& operator << ( std::ostream& os, Column {\cf17 const}& col ) \{\par
5340             {\cf18 bool} first = {\cf17 true};\par
5341             {\cf19 for}( {\cf17 auto} line : col ) \{\par
5342                 {\cf19 if}( first )\par
5343                     first = {\cf17 false};\par
5344                 {\cf19 else}\par
5345                     os << {\cf22 "\\n"};\par
5346                 os <<  line;\par
5347             \}\par
5348             {\cf19 return} os;\par
5349         \}\par
5350 \par
5351         {\cf17 auto} operator + ( Column {\cf17 const}& other ) -> Columns;\par
5352 \par
5353         {\cf17 auto} toString() const -> std::{\cf18 string} \{\par
5354             std::ostringstream oss;\par
5355             oss << *{\cf17 this};\par
5356             {\cf19 return} oss.str();\par
5357         \}\par
5358     \};\par
5359 \par
5360     {\cf17 class }Spacer : {\cf17 public} Column \{\par
5361 \par
5362     {\cf17 public}:\par
5363         {\cf17 explicit} Spacer( {\cf18 size_t} spaceWidth ) : Column( {\cf22 ""} ) \{\par
5364             width( spaceWidth );\par
5365         \}\par
5366     \};\par
5367 \par
5368     {\cf17 class }Columns \{\par
5369         std::vector<Column> m_columns;\par
5370 \par
5371     {\cf17 public}:\par
5372 \par
5373         {\cf17 class }iterator \{\par
5374             {\cf17 friend} Columns;\par
5375             {\cf17 struct }EndTag \{\};\par
5376 \par
5377             std::vector<Column> {\cf17 const}& m_columns;\par
5378             std::vector<Column::iterator> m_iterators;\par
5379             {\cf18 size_t} m_activeIterators;\par
5380 \par
5381             iterator( Columns {\cf17 const}& columns, EndTag )\par
5382             :   m_columns( columns.m_columns ),\par
5383                 m_activeIterators( 0 )\par
5384             \{\par
5385                 m_iterators.reserve( m_columns.size() );\par
5386 \par
5387                 {\cf19 for}( {\cf17 auto} {\cf17 const}& col : m_columns )\par
5388                     m_iterators.push_back( col.end() );\par
5389             \}\par
5390 \par
5391         {\cf17 public}:\par
5392             {\cf17 explicit} iterator( Columns {\cf17 const}& columns )\par
5393             :   m_columns( columns.m_columns ),\par
5394                 m_activeIterators( m_columns.size() )\par
5395             \{\par
5396                 m_iterators.reserve( m_columns.size() );\par
5397 \par
5398                 {\cf19 for}( {\cf17 auto} {\cf17 const}& col : m_columns )\par
5399                     m_iterators.push_back( col.begin() );\par
5400             \}\par
5401 \par
5402             {\cf17 auto} operator ==( iterator {\cf17 const}& other ) {\cf17 const} -> {\cf18 bool} \{\par
5403                 {\cf19 return} m_iterators == other.m_iterators;\par
5404             \}\par
5405             {\cf17 auto} operator !=( iterator {\cf17 const}& other ) {\cf17 const} -> {\cf18 bool} \{\par
5406                 {\cf19 return} m_iterators != other.m_iterators;\par
5407             \}\par
5408             {\cf17 auto} operator *() const -> std::{\cf18 string} \{\par
5409                 std::string row, padding;\par
5410 \par
5411                 {\cf19 for}( {\cf18 size_t} i = 0; i < m_columns.size(); ++i ) \{\par
5412                     {\cf17 auto} width = m_columns[i].width();\par
5413                     {\cf19 if}( m_iterators[i] != m_columns[i].end() ) \{\par
5414                         std::string col = *m_iterators[i];\par
5415                         row += padding + col;\par
5416                         {\cf19 if}( col.size() < width )\par
5417                             padding = std::string( width - col.size(), {\cf23 ' '} );\par
5418                         {\cf19 else}\par
5419                             padding = {\cf22 ""};\par
5420                     \}\par
5421                     {\cf19 else} \{\par
5422                         padding += std::string( width, ' ' );\par
5423                     \}\par
5424                 \}\par
5425                 {\cf19 return} row;\par
5426             \}\par
5427             {\cf17 auto} operator ++() -> iterator& \{\par
5428                 {\cf19 for}( {\cf18 size_t} i = 0; i < m_columns.size(); ++i ) \{\par
5429                     {\cf19 if} (m_iterators[i] != m_columns[i].end())\par
5430                         ++m_iterators[i];\par
5431                 \}\par
5432                 {\cf19 return} *{\cf17 this};\par
5433             \}\par
5434             {\cf17 auto} operator ++({\cf18 int}) -> iterator \{\par
5435                 iterator prev( *{\cf17 this} );\par
5436                 operator++();\par
5437                 {\cf19 return} prev;\par
5438             \}\par
5439         \};\par
5440         {\cf17 using }const_iterator = iterator;\par
5441 \par
5442         {\cf17 auto} begin() const -> iterator \{ {\cf19 return} iterator( *{\cf17 this} ); \}\par
5443         {\cf17 auto} end() const -> iterator \{ {\cf19 return} \{ *{\cf17 this}, iterator::EndTag() \}; \}\par
5444 \par
5445         {\cf17 auto} operator += ( Column {\cf17 const}& col ) -> Columns& \{\par
5446             m_columns.push_back( col );\par
5447             {\cf19 return} *{\cf17 this};\par
5448         \}\par
5449         {\cf17 auto} operator + ( Column {\cf17 const}& col ) -> Columns \{\par
5450             Columns combined = *{\cf17 this};\par
5451             combined += col;\par
5452             {\cf19 return} combined;\par
5453         \}\par
5454 \par
5455         {\cf17 inline} {\cf17 friend} std::ostream& operator << ( std::ostream& os, Columns {\cf17 const}& cols ) \{\par
5456 \par
5457             {\cf18 bool} first = {\cf17 true};\par
5458             {\cf19 for}( {\cf17 auto} line : cols ) \{\par
5459                 {\cf19 if}( first )\par
5460                     first = {\cf17 false};\par
5461                 {\cf19 else}\par
5462                     os << {\cf22 "\\n"};\par
5463                 os << line;\par
5464             \}\par
5465             {\cf19 return} os;\par
5466         \}\par
5467 \par
5468         {\cf17 auto} toString() const -> std::{\cf18 string} \{\par
5469             std::ostringstream oss;\par
5470             oss << *{\cf17 this};\par
5471             {\cf19 return} oss.str();\par
5472         \}\par
5473     \};\par
5474 \par
5475     {\cf17 inline} {\cf17 auto} Column::operator + ( Column {\cf17 const}& other ) -> Columns \{\par
5476         Columns cols;\par
5477         cols += *this;\par
5478         cols += other;\par
5479         {\cf19 return} cols;\par
5480     \}\par
5481 \}\}\} {\cf20 // namespace Catch::clara::TextFlow}\par
5482 \par
5483 {\cf20 // ----------- end of #include from clara_textflow.hpp -----------}\par
5484 {\cf20 // ........... back in clara.hpp}\par
5485 \par
5486 {\cf21 #include <memory>}\par
5487 {\cf21 #include <set>}\par
5488 {\cf21 #include <algorithm>}\par
5489 \par
5490 {\cf21 #if !defined(CATCH_PLATFORM_WINDOWS) && ( defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) )}\par
5491 {\cf21 #define CATCH_PLATFORM_WINDOWS}\par
5492 {\cf21 #endif}\par
5493 \par
5494 {\cf17 namespace }Catch \{ {\cf17 namespace }clara \{\par
5495 {\cf17 namespace }detail \{\par
5496 \par
5497     {\cf20 // Traits for extracting arg and return type of lambdas (for single argument lambdas)}\par
5498     {\cf17 template}<{\cf17 typename} L>\par
5499     {\cf17 struct }UnaryLambdaTraits : UnaryLambdaTraits<decltype( &L::operator() )> \{\};\par
5500 \par
5501     {\cf17 template}<{\cf17 typename} ClassT, {\cf17 typename} ReturnT, {\cf17 typename}... Args>\par
5502     {\cf17 struct }UnaryLambdaTraits<ReturnT( ClassT::* )( Args... ) const> \{\par
5503         {\cf17 static} {\cf17 const} {\cf18 bool} isValid = {\cf17 false};\par
5504     \};\par
5505 \par
5506     {\cf17 template}<{\cf17 typename} ClassT, {\cf17 typename} ReturnT, {\cf17 typename} ArgT>\par
5507     {\cf17 struct }UnaryLambdaTraits<ReturnT( ClassT::* )( ArgT ) const> \{\par
5508         {\cf17 static} {\cf17 const} {\cf18 bool} isValid = {\cf17 true};\par
5509         {\cf17 using }ArgType = {\cf17 typename} std::remove_const<typename std::remove_reference<ArgT>::type>::type;\par
5510         {\cf17 using }ReturnType = ReturnT;\par
5511     \};\par
5512 \par
5513     {\cf17 class }TokenStream;\par
5514 \par
5515     {\cf20 // Transport for raw args (copied from main args, or supplied via init list for testing)}\par
5516     {\cf17 class }Args \{\par
5517         {\cf17 friend} TokenStream;\par
5518         std::string m_exeName;\par
5519         std::vector<std::string> m_args;\par
5520 \par
5521     {\cf17 public}:\par
5522         Args( {\cf18 int} argc, {\cf18 char} {\cf17 const}* {\cf17 const}* argv )\par
5523             : m_exeName(argv[0]),\par
5524               m_args(argv + 1, argv + argc) \{\}\par
5525 \par
5526         Args( std::initializer_list<std::string> args )\par
5527         :   m_exeName( *args.begin() ),\par
5528             m_args( args.begin()+1, args.end() )\par
5529         \{\}\par
5530 \par
5531         {\cf17 auto} exeName() const -> std::{\cf18 string} \{\par
5532             {\cf19 return} m_exeName;\par
5533         \}\par
5534     \};\par
5535 \par
5536     {\cf20 // Wraps a token coming from a token stream. These may not directly correspond to strings as a single string}\par
5537     {\cf20 // may encode an option + its argument if the : or = form is used}\par
5538     {\cf17 enum class} TokenType \{\par
5539         Option, Argument\par
5540     \};\par
5541     {\cf17 struct }Token \{\par
5542         TokenType type;\par
5543         std::string token;\par
5544     \};\par
5545 \par
5546     {\cf17 inline} {\cf17 auto} isOptPrefix( {\cf18 char} c ) -> {\cf18 bool} \{\par
5547         {\cf19 return} c == {\cf23 '-'}\par
5548 {\cf21 #ifdef CATCH_PLATFORM_WINDOWS}\par
5549             || c == {\cf23 '/'}\par
5550 {\cf21 #endif}\par
5551         ;\par
5552     \}\par
5553 \par
5554     {\cf20 // Abstracts iterators into args as a stream of tokens, with option arguments uniformly handled}\par
5555     {\cf17 class }TokenStream \{\par
5556         {\cf17 using }Iterator = std::vector<std::string>::const_iterator;\par
5557         Iterator it;\par
5558         Iterator itEnd;\par
5559         std::vector<Token> m_tokenBuffer;\par
5560 \par
5561         {\cf18 void} loadBuffer() \{\par
5562             m_tokenBuffer.resize( 0 );\par
5563 \par
5564             {\cf20 // Skip any empty strings}\par
5565             {\cf19 while}( it != itEnd && it->empty() )\par
5566                 ++it;\par
5567 \par
5568             {\cf19 if}( it != itEnd ) \{\par
5569                 {\cf17 auto} {\cf17 const} &next = *it;\par
5570                 {\cf19 if}( isOptPrefix( next[0] ) ) \{\par
5571                     {\cf17 auto} delimiterPos = next.find_first_of( {\cf22 " :="} );\par
5572                     {\cf19 if}( delimiterPos != std::string::npos ) \{\par
5573                         m_tokenBuffer.push_back( \{ TokenType::Option, next.substr( 0, delimiterPos ) \} );\par
5574                         m_tokenBuffer.push_back( \{ TokenType::Argument, next.substr( delimiterPos + 1 ) \} );\par
5575                     \} {\cf19 else} \{\par
5576                         {\cf19 if}( next[1] != {\cf23 '-'} && next.size() > 2 ) \{\par
5577                             std::string opt = {\cf22 "- "};\par
5578                             {\cf19 for}( {\cf18 size_t} i = 1; i < next.size(); ++i ) \{\par
5579                                 opt[1] = next[i];\par
5580                                 m_tokenBuffer.push_back( \{ TokenType::Option, opt \} );\par
5581                             \}\par
5582                         \} {\cf19 else} \{\par
5583                             m_tokenBuffer.push_back( \{ TokenType::Option, next \} );\par
5584                         \}\par
5585                     \}\par
5586                 \} {\cf19 else} \{\par
5587                     m_tokenBuffer.push_back( \{ TokenType::Argument, next \} );\par
5588                 \}\par
5589             \}\par
5590         \}\par
5591 \par
5592     {\cf17 public}:\par
5593         {\cf17 explicit} TokenStream( Args {\cf17 const} &args ) : TokenStream( args.m_args.begin(), args.m_args.end() ) \{\}\par
5594 \par
5595         TokenStream( Iterator it, Iterator itEnd ) : it( it ), itEnd( itEnd ) \{\par
5596             loadBuffer();\par
5597         \}\par
5598 \par
5599         {\cf17 explicit} {\cf17 operator} bool(){\cf17  const }\{\par
5600             {\cf19 return} !m_tokenBuffer.empty() || it != itEnd;\par
5601         \}\par
5602 \par
5603         {\cf17 auto} count() const -> {\cf18 size_t} \{ {\cf19 return} m_tokenBuffer.size() + (itEnd - it); \}\par
5604 \par
5605         {\cf17 auto} operator*() const -> Token \{\par
5606             assert( !m_tokenBuffer.empty() );\par
5607             {\cf19 return} m_tokenBuffer.front();\par
5608         \}\par
5609 \par
5610         {\cf17 auto} operator->() const -> Token const * \{\par
5611             assert( !m_tokenBuffer.empty() );\par
5612             {\cf19 return} &m_tokenBuffer.front();\par
5613         \}\par
5614 \par
5615         {\cf17 auto} operator++() -> TokenStream & \{\par
5616             {\cf19 if}( m_tokenBuffer.size() >= 2 ) \{\par
5617                 m_tokenBuffer.erase( m_tokenBuffer.begin() );\par
5618             \} {\cf19 else} \{\par
5619                 {\cf19 if}( it != itEnd )\par
5620                     ++it;\par
5621                 loadBuffer();\par
5622             \}\par
5623             {\cf19 return} *{\cf17 this};\par
5624         \}\par
5625     \};\par
5626 \par
5627     {\cf17 class }ResultBase \{\par
5628     {\cf17 public}:\par
5629         {\cf17 enum} Type \{\par
5630             Ok, LogicError, RuntimeError\par
5631         \};\par
5632 \par
5633     {\cf17 protected}:\par
5634         ResultBase( Type type ) : m_type( type ) \{\}\par
5635         {\cf17 virtual} ~ResultBase() = {\cf19 default};\par
5636 \par
5637         {\cf17 virtual} {\cf18 void} enforceOk() {\cf17 const} = 0;\par
5638 \par
5639         Type m_type;\par
5640     \};\par
5641 \par
5642     {\cf17 template}<{\cf17 typename} T>\par
5643     {\cf17 class }ResultValueBase : {\cf17 public} ResultBase \{\par
5644     {\cf17 public}:\par
5645         {\cf17 auto} value() const -> T const & \{\par
5646             enforceOk();\par
5647             {\cf19 return} m_value;\par
5648         \}\par
5649 \par
5650     {\cf17 protected}:\par
5651         ResultValueBase( Type type ) : ResultBase( type ) \{\}\par
5652 \par
5653         ResultValueBase( ResultValueBase {\cf17 const} &other ) : ResultBase( other ) \{\par
5654             {\cf19 if}( m_type == ResultBase::Ok )\par
5655                 {\cf17 new}( &m_value ) T( other.m_value );\par
5656         \}\par
5657 \par
5658         ResultValueBase( Type, T {\cf17 const} &value ) : ResultBase( Ok ) \{\par
5659             {\cf17 new}( &m_value ) T( value );\par
5660         \}\par
5661 \par
5662         {\cf17 auto} operator=( ResultValueBase {\cf17 const} &other ) -> ResultValueBase & \{\par
5663             {\cf19 if}( m_type == ResultBase::Ok )\par
5664                 m_value.~T();\par
5665             ResultBase::operator=(other);\par
5666             {\cf19 if}( m_type == ResultBase::Ok )\par
5667                 {\cf17 new}( &m_value ) T( other.m_value );\par
5668             {\cf19 return} *{\cf17 this};\par
5669         \}\par
5670 \par
5671         ~ResultValueBase(){\cf17  override }\{\par
5672             {\cf19 if}( m_type == Ok )\par
5673                 m_value.~T();\par
5674         \}\par
5675 \par
5676         {\cf17 union }\{\par
5677             T m_value;\par
5678         \};\par
5679     \};\par
5680 \par
5681     {\cf17 template}<>\par
5682     {\cf17 class }ResultValueBase<void> : {\cf17 public} ResultBase \{\par
5683     {\cf17 protected}:\par
5684         {\cf17 using }ResultBase::ResultBase;\par
5685     \};\par
5686 \par
5687     {\cf17 template}<{\cf17 typename} T = {\cf18 void}>\par
5688     {\cf17 class }BasicResult : {\cf17 public} ResultValueBase<T> \{\par
5689     {\cf17 public}:\par
5690         {\cf17 template}<{\cf17 typename} U>\par
5691         {\cf17 explicit} BasicResult( BasicResult<U> {\cf17 const} &other )\par
5692         :   ResultValueBase<T>( other.type() ),\par
5693             m_errorMessage( other.errorMessage() )\par
5694         \{\par
5695             assert( type() != ResultBase::Ok );\par
5696         \}\par
5697 \par
5698         {\cf17 template}<{\cf17 typename} U>\par
5699         {\cf17 static} {\cf17 auto} ok( U {\cf17 const} &value ) -> BasicResult \{ {\cf19 return} \{ ResultBase::Ok, value \}; \}\par
5700         {\cf17 static} {\cf17 auto} ok() -> BasicResult \{ {\cf19 return} \{ ResultBase::Ok \}; \}\par
5701         {\cf17 static} {\cf17 auto} logicError( std::string {\cf17 const} &message ) -> BasicResult \{ {\cf19 return} \{ ResultBase::LogicError, message \}; \}\par
5702         {\cf17 static} {\cf17 auto} runtimeError( std::string {\cf17 const} &message ) -> BasicResult \{ {\cf19 return} \{ ResultBase::RuntimeError, message \}; \}\par
5703 \par
5704         {\cf17 explicit} {\cf17 operator} bool(){\cf17  const }\{ {\cf19 return} m_type == ResultBase::Ok; \}\par
5705         {\cf17 auto} type() const -> ResultBase::Type \{ {\cf19 return} m_type; \}\par
5706         {\cf17 auto} errorMessage() const -> std::{\cf18 string} \{ {\cf19 return} m_errorMessage; \}\par
5707 \par
5708     {\cf17 protected}:\par
5709         {\cf18 void} enforceOk(){\cf17  const override }\{\par
5710 \par
5711             {\cf20 // Errors shouldn't reach this point, but if they do}\par
5712             {\cf20 // the actual error message will be in m_errorMessage}\par
5713             assert( m_type != ResultBase::LogicError );\par
5714             assert( m_type != ResultBase::RuntimeError );\par
5715             {\cf19 if}( m_type != ResultBase::Ok )\par
5716                 std::abort();\par
5717         \}\par
5718 \par
5719         std::string m_errorMessage; {\cf20 // Only populated if resultType is an error}\par
5720 \par
5721         BasicResult( ResultBase::Type type, std::string {\cf17 const} &message )\par
5722         :   ResultValueBase<T>(type),\par
5723             m_errorMessage(message)\par
5724         \{\par
5725             assert( m_type != ResultBase::Ok );\par
5726         \}\par
5727 \par
5728         {\cf17 using }ResultValueBase<T>::ResultValueBase;\par
5729         {\cf17 using }ResultBase::m_type;\par
5730     \};\par
5731 \par
5732     {\cf17 enum class} ParseResultType \{\par
5733         Matched, NoMatch, ShortCircuitAll, ShortCircuitSame\par
5734     \};\par
5735 \par
5736     {\cf17 class }ParseState \{\par
5737     {\cf17 public}:\par
5738 \par
5739         ParseState( ParseResultType type, TokenStream {\cf17 const} &remainingTokens )\par
5740         : m_type(type),\par
5741           m_remainingTokens( remainingTokens )\par
5742         \{\}\par
5743 \par
5744         {\cf17 auto} type() const -> ParseResultType \{ {\cf19 return} m_type; \}\par
5745         {\cf17 auto} remainingTokens() const -> TokenStream \{ {\cf19 return} m_remainingTokens; \}\par
5746 \par
5747     {\cf17 private}:\par
5748         ParseResultType m_type;\par
5749         TokenStream m_remainingTokens;\par
5750     \};\par
5751 \par
5752     {\cf17 using }Result = BasicResult<void>;\par
5753     {\cf17 using }ParserResult = BasicResult<ParseResultType>;\par
5754     {\cf17 using }InternalParseResult = BasicResult<ParseState>;\par
5755 \par
5756     {\cf17 struct }HelpColumns \{\par
5757         std::string left;\par
5758         std::string right;\par
5759     \};\par
5760 \par
5761     {\cf17 template}<{\cf17 typename} T>\par
5762     {\cf17 inline} {\cf17 auto} convertInto( std::string {\cf17 const} &source, T& target ) -> ParserResult \{\par
5763         std::stringstream ss;\par
5764         ss << source;\par
5765         ss >> target;\par
5766         {\cf19 if}( ss.fail() )\par
5767             {\cf19 return} ParserResult::runtimeError( {\cf22 "Unable to convert '"} + source + {\cf22 "' to destination type"} );\par
5768         {\cf19 else}\par
5769             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
5770     \}\par
5771     {\cf17 inline} {\cf17 auto} convertInto( std::string {\cf17 const} &source, std::string& target ) -> ParserResult \{\par
5772         target = source;\par
5773         {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
5774     \}\par
5775     {\cf17 inline} {\cf17 auto} convertInto( std::string {\cf17 const} &source, {\cf18 bool} &target ) -> ParserResult \{\par
5776         std::string srcLC = source;\par
5777         std::transform( srcLC.begin(), srcLC.end(), srcLC.begin(), []( {\cf18 char} c ) \{ return static_cast<char>( ::tolower(c) ); \} );\par
5778         {\cf19 if} (srcLC == {\cf22 "y"} || srcLC == {\cf22 "1"} || srcLC == {\cf22 "true"} || srcLC == {\cf22 "yes"} || srcLC == {\cf22 "on"})\par
5779             target = {\cf17 true};\par
5780         {\cf19 else} {\cf19 if} (srcLC == {\cf22 "n"} || srcLC == {\cf22 "0"} || srcLC == {\cf22 "false"} || srcLC == {\cf22 "no"} || srcLC == {\cf22 "off"})\par
5781             target = {\cf17 false};\par
5782         {\cf19 else}\par
5783             {\cf19 return} ParserResult::runtimeError( {\cf22 "Expected a boolean value but did not recognise: '"} + source + {\cf22 "'"} );\par
5784         {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
5785     \}\par
5786 {\cf21 #ifdef CLARA_CONFIG_OPTIONAL_TYPE}\par
5787     {\cf17 template}<{\cf17 typename} T>\par
5788     {\cf17 inline} {\cf17 auto} convertInto( std::string {\cf17 const} &source, CLARA_CONFIG_OPTIONAL_TYPE<T>& target ) -> ParserResult \{\par
5789         T temp;\par
5790         {\cf17 auto} result = convertInto( source, temp );\par
5791         {\cf19 if}( result )\par
5792             target = std::move(temp);\par
5793         {\cf19 return} result;\par
5794     \}\par
5795 {\cf21 #endif }{\cf20 // CLARA_CONFIG_OPTIONAL_TYPE}\par
5796 \par
5797     {\cf17 struct }NonCopyable \{\par
5798         NonCopyable() = {\cf19 default};\par
5799         NonCopyable( NonCopyable {\cf17 const} & ) = {\cf17 delete};\par
5800         NonCopyable( NonCopyable && ) = {\cf17 delete};\par
5801         NonCopyable &operator=( NonCopyable {\cf17 const} & ) = {\cf17 delete};\par
5802         NonCopyable &operator=( NonCopyable && ) = {\cf17 delete};\par
5803     \};\par
5804 \par
5805     {\cf17 struct }BoundRef : NonCopyable \{\par
5806         {\cf17 virtual} ~BoundRef() = {\cf19 default};\par
5807         {\cf17 virtual} {\cf17 auto} isContainer() const -> {\cf18 bool} \{ {\cf19 return} {\cf17 false}; \}\par
5808         {\cf17 virtual} {\cf17 auto} isFlag() const -> {\cf18 bool} \{ {\cf19 return} {\cf17 false}; \}\par
5809     \};\par
5810     {\cf17 struct }BoundValueRefBase : BoundRef \{\par
5811         {\cf17 virtual} {\cf17 auto} setValue( std::string {\cf17 const} &arg ) -> ParserResult = 0;\par
5812     \};\par
5813     {\cf17 struct }BoundFlagRefBase : BoundRef \{\par
5814         {\cf17 virtual} {\cf17 auto} setFlag( {\cf18 bool} flag ) -> ParserResult = 0;\par
5815         {\cf17 virtual} {\cf17 auto} isFlag() const -> {\cf18 bool} \{ {\cf19 return} {\cf17 true}; \}\par
5816     \};\par
5817 \par
5818     {\cf17 template}<{\cf17 typename} T>\par
5819     {\cf17 struct }BoundValueRef : BoundValueRefBase \{\par
5820         T &m_ref;\par
5821 \par
5822         {\cf17 explicit} BoundValueRef( T &ref ) : m_ref( ref ) \{\}\par
5823 \par
5824         {\cf17 auto} setValue( std::string {\cf17 const} &arg ) -> ParserResult {\cf17 override} \{\par
5825             {\cf19 return} convertInto( arg, m_ref );\par
5826         \}\par
5827     \};\par
5828 \par
5829     {\cf17 template}<{\cf17 typename} T>\par
5830     {\cf17 struct }BoundValueRef<std::vector<T>> : BoundValueRefBase \{\par
5831         std::vector<T> &m_ref;\par
5832 \par
5833         {\cf17 explicit} BoundValueRef( std::vector<T> &ref ) : m_ref( ref ) \{\}\par
5834 \par
5835         {\cf17 auto} isContainer() const -> {\cf18 bool}{\cf17  override }\{ {\cf19 return} {\cf17 true}; \}\par
5836 \par
5837         {\cf17 auto} setValue( std::string {\cf17 const} &arg ) -> ParserResult {\cf17 override} \{\par
5838             T temp;\par
5839             {\cf17 auto} result = convertInto( arg, temp );\par
5840             {\cf19 if}( result )\par
5841                 m_ref.push_back( temp );\par
5842             {\cf19 return} result;\par
5843         \}\par
5844     \};\par
5845 \par
5846     {\cf17 struct }BoundFlagRef : BoundFlagRefBase \{\par
5847         {\cf18 bool} &m_ref;\par
5848 \par
5849         {\cf17 explicit} BoundFlagRef( {\cf18 bool} &ref ) : m_ref( ref ) \{\}\par
5850 \par
5851         {\cf17 auto} setFlag( {\cf18 bool} flag ) -> ParserResult {\cf17 override} \{\par
5852             m_ref = flag;\par
5853             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
5854         \}\par
5855     \};\par
5856 \par
5857     {\cf17 template}<{\cf17 typename} ReturnType>\par
5858     {\cf17 struct }LambdaInvoker \{\par
5859         {\cf17 static_assert}( std::is_same<ReturnType, ParserResult>::value, {\cf22 "Lambda must return void or clara::ParserResult"} );\par
5860 \par
5861         {\cf17 template}<{\cf17 typename} L, {\cf17 typename} ArgType>\par
5862         {\cf17 static} {\cf17 auto} invoke( L {\cf17 const} &lambda, ArgType {\cf17 const} &arg ) -> ParserResult \{\par
5863             {\cf19 return} lambda( arg );\par
5864         \}\par
5865     \};\par
5866 \par
5867     {\cf17 template}<>\par
5868     {\cf17 struct }LambdaInvoker<void> \{\par
5869         {\cf17 template}<{\cf17 typename} L, {\cf17 typename} ArgType>\par
5870         {\cf17 static} {\cf17 auto} invoke( L {\cf17 const} &lambda, ArgType {\cf17 const} &arg ) -> ParserResult \{\par
5871             lambda( arg );\par
5872             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
5873         \}\par
5874     \};\par
5875 \par
5876     {\cf17 template}<{\cf17 typename} ArgType, {\cf17 typename} L>\par
5877     {\cf17 inline} {\cf17 auto} invokeLambda( L {\cf17 const} &lambda, std::string {\cf17 const} &arg ) -> ParserResult \{\par
5878         ArgType temp\{\};\par
5879         {\cf17 auto} result = convertInto( arg, temp );\par
5880         {\cf19 return} !result\par
5881            ? result\par
5882            : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );\par
5883     \}\par
5884 \par
5885     {\cf17 template}<{\cf17 typename} L>\par
5886     {\cf17 struct }BoundLambda : BoundValueRefBase \{\par
5887         L m_lambda;\par
5888 \par
5889         {\cf17 static_assert}( UnaryLambdaTraits<L>::isValid, {\cf22 "Supplied lambda must take exactly one argument"} );\par
5890         {\cf17 explicit} BoundLambda( L {\cf17 const} &lambda ) : m_lambda( lambda ) \{\}\par
5891 \par
5892         {\cf17 auto} setValue( std::string {\cf17 const} &arg ) -> ParserResult {\cf17 override} \{\par
5893             {\cf19 return} invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m_lambda, arg );\par
5894         \}\par
5895     \};\par
5896 \par
5897     {\cf17 template}<{\cf17 typename} L>\par
5898     {\cf17 struct }BoundFlagLambda : BoundFlagRefBase \{\par
5899         L m_lambda;\par
5900 \par
5901         {\cf17 static_assert}( UnaryLambdaTraits<L>::isValid, {\cf22 "Supplied lambda must take exactly one argument"} );\par
5902         {\cf17 static_assert}( std::is_same<typename UnaryLambdaTraits<L>::ArgType, {\cf18 bool}>::value, {\cf22 "flags must be boolean"} );\par
5903 \par
5904         {\cf17 explicit} BoundFlagLambda( L {\cf17 const} &lambda ) : m_lambda( lambda ) \{\}\par
5905 \par
5906         {\cf17 auto} setFlag( {\cf18 bool} flag ) -> ParserResult {\cf17 override} \{\par
5907             {\cf19 return} LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( m_lambda, flag );\par
5908         \}\par
5909     \};\par
5910 \par
5911     {\cf17 enum class} Optionality \{ Optional, Required \};\par
5912 \par
5913     {\cf17 struct }Parser;\par
5914 \par
5915     {\cf17 class }ParserBase \{\par
5916     {\cf17 public}:\par
5917         {\cf17 virtual} ~ParserBase() = {\cf19 default};\par
5918         {\cf17 virtual} {\cf17 auto} validate() const -> Result \{ {\cf19 return} Result::ok(); \}\par
5919         {\cf17 virtual} {\cf17 auto} parse( std::string {\cf17 const}& exeName, TokenStream {\cf17 const} &tokens) {\cf17 const} -> InternalParseResult  = 0;\par
5920         {\cf17 virtual} {\cf17 auto} cardinality() const -> {\cf18 size_t} \{ {\cf19 return} 1; \}\par
5921 \par
5922         {\cf17 auto} parse( Args {\cf17 const} &args ) {\cf17 const} -> InternalParseResult \{\par
5923             {\cf19 return} parse( args.exeName(), TokenStream( args ) );\par
5924         \}\par
5925     \};\par
5926 \par
5927     {\cf17 template}<{\cf17 typename} DerivedT>\par
5928     {\cf17 class }ComposableParserImpl : {\cf17 public} ParserBase \{\par
5929     {\cf17 public}:\par
5930         {\cf17 template}<{\cf17 typename} T>\par
5931         {\cf17 auto} operator|( T {\cf17 const} &other ) {\cf17 const} -> Parser;\par
5932 \par
5933         {\cf17 template}<{\cf17 typename} T>\par
5934         {\cf17 auto} operator+( T {\cf17 const} &other ) {\cf17 const} -> Parser;\par
5935     \};\par
5936 \par
5937     {\cf20 // Common code and state for Args and Opts}\par
5938     {\cf17 template}<{\cf17 typename} DerivedT>\par
5939     {\cf17 class }ParserRefImpl : {\cf17 public} ComposableParserImpl<DerivedT> \{\par
5940     {\cf17 protected}:\par
5941         Optionality m_optionality = Optionality::Optional;\par
5942         std::shared_ptr<BoundRef> m_ref;\par
5943         std::string m_hint;\par
5944         std::string m_description;\par
5945 \par
5946         {\cf17 explicit} ParserRefImpl( std::shared_ptr<BoundRef> {\cf17 const} &ref ) : m_ref( ref ) \{\}\par
5947 \par
5948     {\cf17 public}:\par
5949         {\cf17 template}<{\cf17 typename} T>\par
5950         ParserRefImpl( T &ref, std::string {\cf17 const} &hint )\par
5951         :   m_ref( std::make_shared<BoundValueRef<T>>( ref ) ),\par
5952             m_hint( hint )\par
5953         \{\}\par
5954 \par
5955         {\cf17 template}<{\cf17 typename} LambdaT>\par
5956         ParserRefImpl( LambdaT {\cf17 const} &ref, std::string {\cf17 const} &hint )\par
5957         :   m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),\par
5958             m_hint(hint)\par
5959         \{\}\par
5960 \par
5961         {\cf17 auto} operator()( std::string {\cf17 const} &description ) -> DerivedT & \{\par
5962             m_description = description;\par
5963             {\cf19 return} {\cf17 static_cast<}DerivedT &{\cf17 >}( *this );\par
5964         \}\par
5965 \par
5966         {\cf17 auto} optional() -> DerivedT & \{\par
5967             m_optionality = Optionality::Optional;\par
5968             {\cf19 return} {\cf17 static_cast<}DerivedT &{\cf17 >}( *this );\par
5969         \};\par
5970 \par
5971         {\cf17 auto} required() -> DerivedT & \{\par
5972             m_optionality = Optionality::Required;\par
5973             {\cf19 return} {\cf17 static_cast<}DerivedT &{\cf17 >}( *this );\par
5974         \};\par
5975 \par
5976         {\cf17 auto} isOptional() const -> {\cf18 bool} \{\par
5977             {\cf19 return} m_optionality == Optionality::Optional;\par
5978         \}\par
5979 \par
5980         {\cf17 auto} cardinality() const -> {\cf18 size_t}{\cf17  override }\{\par
5981             {\cf19 if}( m_ref->isContainer() )\par
5982                 {\cf19 return} 0;\par
5983             {\cf19 else}\par
5984                 {\cf19 return} 1;\par
5985         \}\par
5986 \par
5987         {\cf17 auto} hint() const -> std::{\cf18 string} \{ {\cf19 return} m_hint; \}\par
5988     \};\par
5989 \par
5990     {\cf17 class }ExeName : {\cf17 public} ComposableParserImpl<ExeName> \{\par
5991         std::shared_ptr<std::string> m_name;\par
5992         std::shared_ptr<BoundValueRefBase> m_ref;\par
5993 \par
5994         {\cf17 template}<{\cf17 typename} LambdaT>\par
5995         {\cf17 static} {\cf17 auto} makeRef(LambdaT {\cf17 const} &lambda) -> std::shared_ptr<BoundValueRefBase> \{\par
5996             {\cf19 return} std::make_shared<BoundLambda<LambdaT>>( lambda) ;\par
5997         \}\par
5998 \par
5999     {\cf17 public}:\par
6000         ExeName() : m_name( std::make_shared<std::string>( {\cf22 "<executable>"} ) ) \{\}\par
6001 \par
6002         {\cf17 explicit} ExeName( std::string &ref ) : ExeName() \{\par
6003             m_ref = std::make_shared<BoundValueRef<std::string>>( ref );\par
6004         \}\par
6005 \par
6006         {\cf17 template}<{\cf17 typename} LambdaT>\par
6007         {\cf17 explicit} ExeName( LambdaT {\cf17 const}& lambda ) : ExeName() \{\par
6008             m_ref = std::make_shared<BoundLambda<LambdaT>>( lambda );\par
6009         \}\par
6010 \par
6011         {\cf20 // The exe name is not parsed out of the normal tokens, but is handled specially}\par
6012         {\cf17 auto} parse( std::string {\cf17 const}&, TokenStream {\cf17 const} &tokens ) {\cf17 const} -> InternalParseResult {\cf17 override} \{\par
6013             {\cf19 return} InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );\par
6014         \}\par
6015 \par
6016         {\cf17 auto} name() const -> std::{\cf18 string} \{ {\cf19 return} *m_name; \}\par
6017         {\cf17 auto} set( std::string {\cf17 const}& newName ) -> ParserResult \{\par
6018 \par
6019             {\cf17 auto} lastSlash = newName.find_last_of( {\cf22 "\\\\/"} );\par
6020             {\cf17 auto} filename = ( lastSlash == std::string::npos )\par
6021                     ? newName\par
6022                     : newName.substr( lastSlash+1 );\par
6023 \par
6024             *m_name = filename;\par
6025             {\cf19 if}( m_ref )\par
6026                 {\cf19 return} m_ref->setValue( filename );\par
6027             {\cf19 else}\par
6028                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
6029         \}\par
6030     \};\par
6031 \par
6032     {\cf17 class }Arg : {\cf17 public} ParserRefImpl<Arg> \{\par
6033     {\cf17 public}:\par
6034         {\cf17 using }ParserRefImpl::ParserRefImpl;\par
6035 \par
6036         {\cf17 auto} parse( std::string {\cf17 const} &, TokenStream {\cf17 const} &tokens ) {\cf17 const} -> InternalParseResult {\cf17 override} \{\par
6037             {\cf17 auto} validationResult = validate();\par
6038             {\cf19 if}( !validationResult )\par
6039                 {\cf19 return} InternalParseResult( validationResult );\par
6040 \par
6041             {\cf17 auto} remainingTokens = tokens;\par
6042             {\cf17 auto} {\cf17 const} &token = *remainingTokens;\par
6043             {\cf19 if}( token.type != TokenType::Argument )\par
6044                 {\cf19 return} InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );\par
6045 \par
6046             assert( !m_ref->isFlag() );\par
6047             {\cf17 auto} valueRef = {\cf17 static_cast<}detail::BoundValueRefBase*{\cf17 >}( m_ref.get() );\par
6048 \par
6049             {\cf17 auto} result = valueRef->setValue( remainingTokens->token );\par
6050             {\cf19 if}( !result )\par
6051                 {\cf19 return} InternalParseResult( result );\par
6052             {\cf19 else}\par
6053                 {\cf19 return} InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );\par
6054         \}\par
6055     \};\par
6056 \par
6057     {\cf17 inline} {\cf17 auto} normaliseOpt( std::string {\cf17 const} &optName ) -> std::string \{\par
6058 {\cf21 #ifdef CATCH_PLATFORM_WINDOWS}\par
6059         {\cf19 if}( optName[0] == {\cf23 '/'} )\par
6060             {\cf19 return} {\cf22 "-"} + optName.substr( 1 );\par
6061         {\cf19 else}\par
6062 {\cf21 #endif}\par
6063             {\cf19 return} optName;\par
6064     \}\par
6065 \par
6066     {\cf17 class }Opt : {\cf17 public} ParserRefImpl<Opt> \{\par
6067     {\cf17 protected}:\par
6068         std::vector<std::string> m_optNames;\par
6069 \par
6070     {\cf17 public}:\par
6071         {\cf17 template}<{\cf17 typename} LambdaT>\par
6072         {\cf17 explicit} Opt( LambdaT {\cf17 const} &ref ) : ParserRefImpl( std::make_shared<BoundFlagLambda<LambdaT>>( ref ) ) \{\}\par
6073 \par
6074         {\cf17 explicit} Opt( {\cf18 bool} &ref ) : ParserRefImpl( std::make_shared<BoundFlagRef>( ref ) ) \{\}\par
6075 \par
6076         {\cf17 template}<{\cf17 typename} LambdaT>\par
6077         Opt( LambdaT {\cf17 const} &ref, std::string {\cf17 const} &hint ) : ParserRefImpl( ref, hint ) \{\}\par
6078 \par
6079         {\cf17 template}<{\cf17 typename} T>\par
6080         Opt( T &ref, std::string {\cf17 const} &hint ) : ParserRefImpl( ref, hint ) \{\}\par
6081 \par
6082         {\cf17 auto} operator[]( std::string {\cf17 const} &optName ) -> Opt & \{\par
6083             m_optNames.push_back( optName );\par
6084             {\cf19 return} *{\cf17 this};\par
6085         \}\par
6086 \par
6087         {\cf17 auto} getHelpColumns() const -> std::vector<HelpColumns> \{\par
6088             std::ostringstream oss;\par
6089             {\cf18 bool} first = {\cf17 true};\par
6090             {\cf19 for}( {\cf17 auto} {\cf17 const} &opt : m_optNames ) \{\par
6091                 {\cf19 if} (first)\par
6092                     first = {\cf17 false};\par
6093                 {\cf19 else}\par
6094                     oss << {\cf22 ", "};\par
6095                 oss << opt;\par
6096             \}\par
6097             {\cf19 if}( !m_hint.empty() )\par
6098                 oss << {\cf22 " <"} << m_hint << {\cf22 ">"};\par
6099             {\cf19 return} \{ \{ oss.str(), m_description \} \};\par
6100         \}\par
6101 \par
6102         {\cf17 auto} isMatch( std::string {\cf17 const} &optToken ) {\cf17 const} -> {\cf18 bool} \{\par
6103             {\cf17 auto} normalisedToken = normaliseOpt( optToken );\par
6104             {\cf19 for}( {\cf17 auto} {\cf17 const} &name : m_optNames ) \{\par
6105                 {\cf19 if}( normaliseOpt( name ) == normalisedToken )\par
6106                     {\cf19 return} {\cf17 true};\par
6107             \}\par
6108             {\cf19 return} {\cf17 false};\par
6109         \}\par
6110 \par
6111         {\cf17 using }ParserBase::parse;\par
6112 \par
6113         {\cf17 auto} parse( std::string {\cf17 const}&, TokenStream {\cf17 const} &tokens ) {\cf17 const} -> InternalParseResult {\cf17 override} \{\par
6114             {\cf17 auto} validationResult = validate();\par
6115             {\cf19 if}( !validationResult )\par
6116                 {\cf19 return} InternalParseResult( validationResult );\par
6117 \par
6118             {\cf17 auto} remainingTokens = tokens;\par
6119             {\cf19 if}( remainingTokens && remainingTokens->type == TokenType::Option ) \{\par
6120                 {\cf17 auto} {\cf17 const} &token = *remainingTokens;\par
6121                 {\cf19 if}( isMatch(token.token ) ) \{\par
6122                     {\cf19 if}( m_ref->isFlag() ) \{\par
6123                         {\cf17 auto} flagRef = {\cf17 static_cast<}detail::BoundFlagRefBase*{\cf17 >}( m_ref.get() );\par
6124                         {\cf17 auto} result = flagRef->setFlag( {\cf17 true} );\par
6125                         {\cf19 if}( !result )\par
6126                             {\cf19 return} InternalParseResult( result );\par
6127                         {\cf19 if}( result.value() == ParseResultType::ShortCircuitAll )\par
6128                             {\cf19 return} InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );\par
6129                     \} {\cf19 else} \{\par
6130                         {\cf17 auto} valueRef = {\cf17 static_cast<}detail::BoundValueRefBase*{\cf17 >}( m_ref.get() );\par
6131                         ++remainingTokens;\par
6132                         {\cf19 if}( !remainingTokens )\par
6133                             {\cf19 return} InternalParseResult::runtimeError( {\cf22 "Expected argument following "} + token.token );\par
6134                         {\cf17 auto} {\cf17 const} &argToken = *remainingTokens;\par
6135                         {\cf19 if}( argToken.type != TokenType::Argument )\par
6136                             {\cf19 return} InternalParseResult::runtimeError( {\cf22 "Expected argument following "} + token.token );\par
6137                         {\cf17 auto} result = valueRef->setValue( argToken.token );\par
6138                         {\cf19 if}( !result )\par
6139                             {\cf19 return} InternalParseResult( result );\par
6140                         {\cf19 if}( result.value() == ParseResultType::ShortCircuitAll )\par
6141                             {\cf19 return} InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );\par
6142                     \}\par
6143                     {\cf19 return} InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );\par
6144                 \}\par
6145             \}\par
6146             {\cf19 return} InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );\par
6147         \}\par
6148 \par
6149         {\cf17 auto} validate() const -> Result{\cf17  override }\{\par
6150             {\cf19 if}( m_optNames.empty() )\par
6151                 {\cf19 return} Result::logicError( {\cf22 "No options supplied to Opt"} );\par
6152             {\cf19 for}( {\cf17 auto} {\cf17 const} &name : m_optNames ) \{\par
6153                 {\cf19 if}( name.empty() )\par
6154                     {\cf19 return} Result::logicError( {\cf22 "Option name cannot be empty"} );\par
6155 {\cf21 #ifdef CATCH_PLATFORM_WINDOWS}\par
6156                 {\cf19 if}( name[0] != {\cf23 '-'} && name[0] != {\cf23 '/'} )\par
6157                     {\cf19 return} Result::logicError( {\cf22 "Option name must begin with '-' or '/'"} );\par
6158 {\cf21 #else}\par
6159                 {\cf19 if}( name[0] != {\cf23 '-'} )\par
6160                     {\cf19 return} Result::logicError( {\cf22 "Option name must begin with '-'"} );\par
6161 {\cf21 #endif}\par
6162             \}\par
6163             {\cf19 return} ParserRefImpl::validate();\par
6164         \}\par
6165     \};\par
6166 \par
6167     {\cf17 struct }Help : Opt \{\par
6168         Help( {\cf18 bool} &showHelpFlag )\par
6169         :   Opt([&]( bool flag ) \{\par
6170                 showHelpFlag = flag;\par
6171                 {\cf19 return} ParserResult::ok( ParseResultType::ShortCircuitAll );\par
6172             \})\par
6173         \{\par
6174             {\cf17 static_cast<}Opt &{\cf17 >}( *this )\par
6175                     ({\cf22 "display usage information"})\par
6176                     [{\cf22 "-?"}][{\cf22 "-h"}][{\cf22 "--help"}]\par
6177                     .optional();\par
6178         \}\par
6179     \};\par
6180 \par
6181     {\cf17 struct }Parser : ParserBase \{\par
6182 \par
6183         {\cf17 mutable} ExeName m_exeName;\par
6184         std::vector<Opt> m_options;\par
6185         std::vector<Arg> m_args;\par
6186 \par
6187         {\cf17 auto} operator|=( ExeName {\cf17 const} &exeName ) -> Parser & \{\par
6188             m_exeName = exeName;\par
6189             {\cf19 return} *{\cf17 this};\par
6190         \}\par
6191 \par
6192         {\cf17 auto} operator|=( Arg {\cf17 const} &arg ) -> Parser & \{\par
6193             m_args.push_back(arg);\par
6194             {\cf19 return} *{\cf17 this};\par
6195         \}\par
6196 \par
6197         {\cf17 auto} operator|=( Opt {\cf17 const} &opt ) -> Parser & \{\par
6198             m_options.push_back(opt);\par
6199             {\cf19 return} *{\cf17 this};\par
6200         \}\par
6201 \par
6202         {\cf17 auto} operator|=( Parser {\cf17 const} &other ) -> Parser & \{\par
6203             m_options.insert(m_options.end(), other.m_options.begin(), other.m_options.end());\par
6204             m_args.insert(m_args.end(), other.m_args.begin(), other.m_args.end());\par
6205             {\cf19 return} *{\cf17 this};\par
6206         \}\par
6207 \par
6208         {\cf17 template}<{\cf17 typename} T>\par
6209         {\cf17 auto} operator|( T {\cf17 const} &other ) {\cf17 const} -> Parser \{\par
6210             {\cf19 return} Parser( *{\cf17 this} ) |= other;\par
6211         \}\par
6212 \par
6213         {\cf20 // Forward deprecated interface with '+' instead of '|'}\par
6214         {\cf17 template}<{\cf17 typename} T>\par
6215         {\cf17 auto} operator+=( T {\cf17 const} &other ) -> Parser & \{ {\cf19 return} operator|=( other ); \}\par
6216         {\cf17 template}<{\cf17 typename} T>\par
6217         {\cf17 auto} operator+( T {\cf17 const} &other ) {\cf17 const} -> Parser \{ {\cf19 return} operator|( other ); \}\par
6218 \par
6219         {\cf17 auto} getHelpColumns() const -> std::vector<HelpColumns> \{\par
6220             std::vector<HelpColumns> cols;\par
6221             {\cf19 for} ({\cf17 auto} {\cf17 const} &o : m_options) \{\par
6222                 {\cf17 auto} childCols = o.getHelpColumns();\par
6223                 cols.insert( cols.end(), childCols.begin(), childCols.end() );\par
6224             \}\par
6225             {\cf19 return} cols;\par
6226         \}\par
6227 \par
6228         {\cf18 void} writeToStream( std::ostream &os ){\cf17  const }\{\par
6229             {\cf19 if} (!m_exeName.name().empty()) \{\par
6230                 os << {\cf22 "usage:\\n"} << {\cf22 "  "} << m_exeName.name() << {\cf22 " "};\par
6231                 {\cf18 bool} required = {\cf17 true}, first = {\cf17 true};\par
6232                 {\cf19 for}( {\cf17 auto} {\cf17 const} &arg : m_args ) \{\par
6233                     {\cf19 if} (first)\par
6234                         first = {\cf17 false};\par
6235                     {\cf19 else}\par
6236                         os << {\cf22 " "};\par
6237                     {\cf19 if}( arg.isOptional() && required ) \{\par
6238                         os << {\cf22 "["};\par
6239                         required = {\cf17 false};\par
6240                     \}\par
6241                     os << {\cf22 "<"} << arg.hint() << {\cf22 ">"};\par
6242                     {\cf19 if}( arg.cardinality() == 0 )\par
6243                         os << {\cf22 " ... "};\par
6244                 \}\par
6245                 {\cf19 if}( !required )\par
6246                     os << {\cf22 "]"};\par
6247                 {\cf19 if}( !m_options.empty() )\par
6248                     os << {\cf22 " options"};\par
6249                 os << {\cf22 "\\n\\nwhere options are:"} << std::endl;\par
6250             \}\par
6251 \par
6252             {\cf17 auto} rows = getHelpColumns();\par
6253             {\cf18 size_t} consoleWidth = CATCH_CLARA_CONFIG_CONSOLE_WIDTH;\par
6254             {\cf18 size_t} optWidth = 0;\par
6255             {\cf19 for}( {\cf17 auto} {\cf17 const} &cols : rows )\par
6256                 optWidth = (std::max)(optWidth, cols.left.size() + 2);\par
6257 \par
6258             optWidth = (std::min)(optWidth, consoleWidth/2);\par
6259 \par
6260             {\cf19 for}( {\cf17 auto} {\cf17 const} &cols : rows ) \{\par
6261                 {\cf17 auto} row =\par
6262                         TextFlow::Column( cols.left ).width( optWidth ).indent( 2 ) +\par
6263                         TextFlow::Spacer(4) +\par
6264                         TextFlow::Column( cols.right ).width( consoleWidth - 7 - optWidth );\par
6265                 os << row << std::endl;\par
6266             \}\par
6267         \}\par
6268 \par
6269         {\cf17 friend} {\cf17 auto} operator<<( std::ostream &os, Parser {\cf17 const} &parser ) -> std::ostream& \{\par
6270             parser.writeToStream( os );\par
6271             {\cf19 return} os;\par
6272         \}\par
6273 \par
6274         {\cf17 auto} validate() const -> Result{\cf17  override }\{\par
6275             {\cf19 for}( {\cf17 auto} {\cf17 const} &opt : m_options ) \{\par
6276                 {\cf17 auto} result = opt.validate();\par
6277                 {\cf19 if}( !result )\par
6278                     {\cf19 return} result;\par
6279             \}\par
6280             {\cf19 for}( {\cf17 auto} {\cf17 const} &arg : m_args ) \{\par
6281                 {\cf17 auto} result = arg.validate();\par
6282                 {\cf19 if}( !result )\par
6283                     {\cf19 return} result;\par
6284             \}\par
6285             {\cf19 return} Result::ok();\par
6286         \}\par
6287 \par
6288         {\cf17 using }ParserBase::parse;\par
6289 \par
6290         {\cf17 auto} parse( std::string {\cf17 const}& exeName, TokenStream {\cf17 const} &tokens ) {\cf17 const} -> InternalParseResult {\cf17 override} \{\par
6291 \par
6292             {\cf17 struct }ParserInfo \{\par
6293                 ParserBase {\cf17 const}* parser = {\cf17 nullptr};\par
6294                 {\cf18 size_t} count = 0;\par
6295             \};\par
6296             {\cf17 const} {\cf18 size_t} totalParsers = m_options.size() + m_args.size();\par
6297             assert( totalParsers < 512 );\par
6298             {\cf20 // ParserInfo parseInfos[totalParsers]; // <-- this is what we really want to do}\par
6299             ParserInfo parseInfos[512];\par
6300 \par
6301             \{\par
6302                 {\cf18 size_t} i = 0;\par
6303                 {\cf19 for} ({\cf17 auto} {\cf17 const} &opt : m_options) parseInfos[i++].parser = &opt;\par
6304                 {\cf19 for} ({\cf17 auto} {\cf17 const} &arg : m_args) parseInfos[i++].parser = &arg;\par
6305             \}\par
6306 \par
6307             m_exeName.set( exeName );\par
6308 \par
6309             {\cf17 auto} result = InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );\par
6310             {\cf19 while}( result.value().remainingTokens() ) \{\par
6311                 {\cf18 bool} tokenParsed = {\cf17 false};\par
6312 \par
6313                 {\cf19 for}( {\cf18 size_t} i = 0; i < totalParsers; ++i ) \{\par
6314                     {\cf17 auto}&  parseInfo = parseInfos[i];\par
6315                     {\cf19 if}( parseInfo.parser->cardinality() == 0 || parseInfo.count < parseInfo.parser->cardinality() ) \{\par
6316                         result = parseInfo.parser->parse(exeName, result.value().remainingTokens());\par
6317                         if (!result)\par
6318                             return result;\par
6319                         if (result.value().type() != ParseResultType::NoMatch) \{\par
6320                             tokenParsed = true;\par
6321                             ++parseInfo.count;\par
6322                             break;\par
6323                         \}\par
6324                     \}\par
6325                 \}\par
6326 \par
6327                 {\cf19 if}( result.value().type() == ParseResultType::ShortCircuitAll )\par
6328                     {\cf19 return} result;\par
6329                 {\cf19 if}( !tokenParsed )\par
6330                     {\cf19 return} InternalParseResult::runtimeError( {\cf22 "Unrecognised token: "} + result.value().remainingTokens()->token );\par
6331             \}\par
6332             {\cf20 // !TBD Check missing required options}\par
6333             {\cf19 return} result;\par
6334         \}\par
6335     \};\par
6336 \par
6337     {\cf17 template}<{\cf17 typename} DerivedT>\par
6338     {\cf17 template}<{\cf17 typename} T>\par
6339     {\cf17 auto} ComposableParserImpl<DerivedT>::operator|( T {\cf17 const} &other ) {\cf17 const} -> Parser \{\par
6340         {\cf19 return} Parser() | {\cf17 static_cast<}DerivedT {\cf17 const }&{\cf17 >}( *this ) | other;\par
6341     \}\par
6342 \} {\cf20 // namespace detail}\par
6343 \par
6344 {\cf20 // A Combined parser}\par
6345 {\cf17 using }detail::Parser;\par
6346 \par
6347 {\cf20 // A parser for options}\par
6348 {\cf17 using }detail::Opt;\par
6349 \par
6350 {\cf20 // A parser for arguments}\par
6351 {\cf17 using }detail::Arg;\par
6352 \par
6353 {\cf20 // Wrapper for argc, argv from main()}\par
6354 {\cf17 using }detail::Args;\par
6355 \par
6356 {\cf20 // Specifies the name of the executable}\par
6357 {\cf17 using }detail::ExeName;\par
6358 \par
6359 {\cf20 // Convenience wrapper for option parser that specifies the help option}\par
6360 {\cf17 using }detail::Help;\par
6361 \par
6362 {\cf20 // enum of result types from a parse}\par
6363 {\cf17 using }detail::ParseResultType;\par
6364 \par
6365 {\cf20 // Result type for parser operation}\par
6366 {\cf17 using }detail::ParserResult;\par
6367 \par
6368 \}\} {\cf20 // namespace Catch::clara}\par
6369 \par
6370 {\cf20 // end clara.hpp}\par
6371 {\cf21 #ifdef __clang__}\par
6372 {\cf21 #pragma clang diagnostic pop}\par
6373 {\cf21 #endif}\par
6374 \par
6375 {\cf20 // Restore Clara's value for console width, if present}\par
6376 {\cf21 #ifdef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH}\par
6377 {\cf21 #define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH}\par
6378 {\cf21 #undef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH}\par
6379 {\cf21 #endif}\par
6380 \par
6381 {\cf20 // end catch_clara.h}\par
6382 {\cf17 namespace }Catch \{\par
6383 \par
6384     clara::Parser makeCommandLineParser( ConfigData& config );\par
6385 \par
6386 \} {\cf20 // end namespace Catch}\par
6387 \par
6388 {\cf20 // end catch_commandline.h}\par
6389 {\cf21 #include <fstream>}\par
6390 {\cf21 #include <ctime>}\par
6391 \par
6392 {\cf17 namespace }Catch \{\par
6393 \par
6394     clara::Parser makeCommandLineParser( ConfigData& config ) \{\par
6395 \par
6396         {\cf17 using namespace }clara;\par
6397 \par
6398         {\cf17 auto} {\cf17 const} setWarning = [&]( std::string {\cf17 const}& warning ) \{\par
6399                 {\cf17 auto} warningSet = [&]() \{\par
6400                     {\cf19 if}( warning == {\cf22 "NoAssertions"} )\par
6401                         {\cf19 return} WarnAbout::NoAssertions;\par
6402 \par
6403                     {\cf19 if} ( warning == {\cf22 "NoTests"} )\par
6404                         {\cf19 return} WarnAbout::NoTests;\par
6405 \par
6406                     {\cf19 return} WarnAbout::Nothing;\par
6407                 \}();\par
6408 \par
6409                 {\cf19 if} (warningSet == WarnAbout::Nothing)\par
6410                     {\cf19 return} ParserResult::runtimeError( {\cf22 "Unrecognised warning: '"} + warning + {\cf22 "'"} );\par
6411                 config.warnings = {\cf17 static_cast<}WarnAbout::What{\cf17 >}( config.warnings | warningSet );\par
6412                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
6413             \};\par
6414         {\cf17 auto} {\cf17 const} loadTestNamesFromFile = [&]( std::string {\cf17 const}& filename ) \{\par
6415                 std::ifstream f( filename.c_str() );\par
6416                 {\cf19 if}( !f.is_open() )\par
6417                     {\cf19 return} ParserResult::runtimeError( {\cf22 "Unable to load input file: '"} + filename + {\cf22 "'"} );\par
6418 \par
6419                 std::string line;\par
6420                 {\cf19 while}( std::getline( f, line ) ) \{\par
6421                     line = trim(line);\par
6422                     {\cf19 if}( !line.empty() && !startsWith( line, {\cf23 '#'} ) ) \{\par
6423                         {\cf19 if}( !startsWith( line, {\cf23 '"'} ) )\par
6424                             line = {\cf23 '"'} + line + '"';\par
6425                         config.testsOrTags.push_back( line + {\cf23 ','} );\par
6426                     \}\par
6427                 \}\par
6428                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
6429             \};\par
6430         {\cf17 auto} {\cf17 const} setTestOrder = [&]( std::string {\cf17 const}& order ) \{\par
6431                 {\cf19 if}( startsWith( {\cf22 "declared"}, order ) )\par
6432                     config.runOrder = RunTests::InDeclarationOrder;\par
6433                 {\cf19 else} {\cf19 if}( startsWith( {\cf22 "lexical"}, order ) )\par
6434                     config.runOrder = RunTests::InLexicographicalOrder;\par
6435                 {\cf19 else} {\cf19 if}( startsWith( {\cf22 "random"}, order ) )\par
6436                     config.runOrder = RunTests::InRandomOrder;\par
6437                 {\cf19 else}\par
6438                     {\cf19 return} clara::ParserResult::runtimeError( {\cf22 "Unrecognised ordering: '"} + order + {\cf22 "'"} );\par
6439                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
6440             \};\par
6441         {\cf17 auto} {\cf17 const} setRngSeed = [&]( std::string {\cf17 const}& seed ) \{\par
6442                 {\cf19 if}( seed != {\cf22 "time"} )\par
6443                     {\cf19 return} clara::detail::convertInto( seed, config.rngSeed );\par
6444                 config.rngSeed = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}( std::time({\cf17 nullptr}) );\par
6445                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
6446             \};\par
6447         {\cf17 auto} {\cf17 const} setColourUsage = [&]( std::string {\cf17 const}& useColour ) \{\par
6448                     {\cf17 auto} mode = toLower( useColour );\par
6449 \par
6450                     {\cf19 if}( mode == {\cf22 "yes"} )\par
6451                         config.useColour = UseColour::Yes;\par
6452                     {\cf19 else} {\cf19 if}( mode == {\cf22 "no"} )\par
6453                         config.useColour = UseColour::No;\par
6454                     {\cf19 else} {\cf19 if}( mode == {\cf22 "auto"} )\par
6455                         config.useColour = UseColour::Auto;\par
6456                     {\cf19 else}\par
6457                         {\cf19 return} ParserResult::runtimeError( {\cf22 "colour mode must be one of: auto, yes or no. '"} + useColour + {\cf22 "' not recognised"} );\par
6458                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
6459             \};\par
6460         {\cf17 auto} {\cf17 const} setWaitForKeypress = [&]( std::string {\cf17 const}& keypress ) \{\par
6461                 {\cf17 auto} keypressLc = toLower( keypress );\par
6462                 {\cf19 if}( keypressLc == {\cf22 "start"} )\par
6463                     config.waitForKeypress = WaitForKeypress::BeforeStart;\par
6464                 {\cf19 else} {\cf19 if}( keypressLc == {\cf22 "exit"} )\par
6465                     config.waitForKeypress = WaitForKeypress::BeforeExit;\par
6466                 {\cf19 else} {\cf19 if}( keypressLc == {\cf22 "both"} )\par
6467                     config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;\par
6468                 {\cf19 else}\par
6469                     {\cf19 return} ParserResult::runtimeError( {\cf22 "keypress argument must be one of: start, exit or both. '"} + keypress + {\cf22 "' not recognised"} );\par
6470             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
6471             \};\par
6472         {\cf17 auto} {\cf17 const} setVerbosity = [&]( std::string {\cf17 const}& verbosity ) \{\par
6473             {\cf17 auto} lcVerbosity = toLower( verbosity );\par
6474             {\cf19 if}( lcVerbosity == {\cf22 "quiet"} )\par
6475                 config.verbosity = Verbosity::Quiet;\par
6476             {\cf19 else} {\cf19 if}( lcVerbosity == {\cf22 "normal"} )\par
6477                 config.verbosity = Verbosity::Normal;\par
6478             {\cf19 else} {\cf19 if}( lcVerbosity == {\cf22 "high"} )\par
6479                 config.verbosity = Verbosity::High;\par
6480             {\cf19 else}\par
6481                 {\cf19 return} ParserResult::runtimeError( {\cf22 "Unrecognised verbosity, '"} + verbosity + {\cf22 "'"} );\par
6482             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
6483         \};\par
6484 \par
6485         {\cf17 auto} cli\par
6486             = ExeName( config.processName )\par
6487             | Help( config.showHelp )\par
6488             | Opt( config.listTests )\par
6489                 ["-l"]["--list-tests"]\par
6490                 ( {\cf22 "list all/matching test cases"} )\par
6491             | Opt( config.listTags )\par
6492                 ["-t"]["--list-tags"]\par
6493                 ( {\cf22 "list all/matching tags"} )\par
6494             | Opt( config.showSuccessfulTests )\par
6495                 ["-s"]["--success"]\par
6496                 ( {\cf22 "include successful tests in output"} )\par
6497             | Opt( config.shouldDebugBreak )\par
6498                 ["-b"]["--break"]\par
6499                 ( {\cf22 "break into debugger on failure"} )\par
6500             | Opt( config.noThrow )\par
6501                 ["-e"]["--nothrow"]\par
6502                 ( {\cf22 "skip exception tests"} )\par
6503             | Opt( config.showInvisibles )\par
6504                 ["-i"]["--invisibles"]\par
6505                 ( {\cf22 "show invisibles (tabs, newlines)"} )\par
6506             | Opt( config.outputFilename, {\cf22 "filename"} )\par
6507                 ["-o"]["--out"]\par
6508                 ( {\cf22 "output filename"} )\par
6509             | Opt( config.reporterNames, {\cf22 "name"} )\par
6510                 ["-r"]["--reporter"]\par
6511                 ( {\cf22 "reporter to use (defaults to console)"} )\par
6512             | Opt( config.name, {\cf22 "name"} )\par
6513                 ["-n"]["--name"]\par
6514                 ( {\cf22 "suite name"} )\par
6515             | Opt( [&]( {\cf18 bool} )\{ config.abortAfter = 1; \} )\par
6516                 [{\cf22 "-a"}][{\cf22 "--abort"}]\par
6517                 ( {\cf22 "abort at first failure"} )\par
6518             | Opt( [&]( {\cf18 int} x )\{ config.abortAfter = x; \}, {\cf22 "no. failures"} )\par
6519                 [{\cf22 "-x"}][{\cf22 "--abortx"}]\par
6520                 ( {\cf22 "abort after x failures"} )\par
6521             | Opt( setWarning, {\cf22 "warning name"} )\par
6522                 ["-w"]["--warn"]\par
6523                 ( {\cf22 "enable warnings"} )\par
6524             | Opt( [&]( {\cf18 bool} flag ) \{ config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; \}, {\cf22 "yes|no"} )\par
6525                 [{\cf22 "-d"}][{\cf22 "--durations"}]\par
6526                 ( {\cf22 "show test durations"} )\par
6527             | Opt( loadTestNamesFromFile, {\cf22 "filename"} )\par
6528                 ["-f"]["--input-file"]\par
6529                 ( {\cf22 "load test names to run from a file"} )\par
6530             | Opt( config.filenamesAsTags )\par
6531                 ["-#"]["--filenames-as-tags"]\par
6532                 ( {\cf22 "adds a tag for the filename"} )\par
6533             | Opt( config.sectionsToRun, {\cf22 "section name"} )\par
6534                 ["-c"]["--section"]\par
6535                 ( {\cf22 "specify section to run"} )\par
6536             | Opt( setVerbosity, {\cf22 "quiet|normal|high"} )\par
6537                 ["-v"]["--verbosity"]\par
6538                 ( {\cf22 "set output verbosity"} )\par
6539             | Opt( config.listTestNamesOnly )\par
6540                 ["--list-test-names-only"]\par
6541                 ( {\cf22 "list all/matching test cases names only"} )\par
6542             | Opt( config.listReporters )\par
6543                 ["--list-reporters"]\par
6544                 ( {\cf22 "list all reporters"} )\par
6545             | Opt( setTestOrder, {\cf22 "decl|lex|rand"} )\par
6546                 ["--order"]\par
6547                 ( {\cf22 "test case order (defaults to decl)"} )\par
6548             | Opt( setRngSeed, {\cf22 "'time'|number"} )\par
6549                 ["--rng-seed"]\par
6550                 ( {\cf22 "set a specific seed for random numbers"} )\par
6551             | Opt( setColourUsage, {\cf22 "yes|no"} )\par
6552                 ["--use-colour"]\par
6553                 ( {\cf22 "should output be colourised"} )\par
6554             | Opt( config.libIdentify )\par
6555                 ["--libidentify"]\par
6556                 ( {\cf22 "report name and version according to libidentify standard"} )\par
6557             | Opt( setWaitForKeypress, {\cf22 "start|exit|both"} )\par
6558                 ["--wait-for-keypress"]\par
6559                 ( {\cf22 "waits for a keypress before exiting"} )\par
6560             | Opt( config.benchmarkResolutionMultiple, {\cf22 "multiplier"} )\par
6561                 ["--benchmark-resolution-multiple"]\par
6562                 ( {\cf22 "multiple of clock resolution to run benchmarks"} )\par
6563 \par
6564             | Arg( config.testsOrTags, {\cf22 "test name|pattern|tags"} )\par
6565                 ( {\cf22 "which test or tests to use"} );\par
6566 \par
6567         {\cf19 return} cli;\par
6568     \}\par
6569 \par
6570 \} {\cf20 // end namespace Catch}\par
6571 {\cf20 // end catch_commandline.cpp}\par
6572 {\cf20 // start catch_common.cpp}\par
6573 \par
6574 {\cf21 #include <cstring>}\par
6575 {\cf21 #include <ostream>}\par
6576 \par
6577 {\cf17 namespace }Catch \{\par
6578 \par
6579     {\cf18 bool} SourceLineInfo::empty() const noexcept \{\par
6580         {\cf19 return} file[0] == {\cf23 '\\0'};\par
6581     \}\par
6582     {\cf18 bool} SourceLineInfo::operator == ( SourceLineInfo {\cf17 const}& other ) {\cf17 const} {\cf17 noexcept} \{\par
6583         {\cf19 return} line == other.line && (file == other.file || std::strcmp(file, other.file) == 0);\par
6584     \}\par
6585     {\cf18 bool} SourceLineInfo::operator < ( SourceLineInfo {\cf17 const}& other ) {\cf17 const} {\cf17 noexcept} \{\par
6586         {\cf19 return} line < other.line || ( line == other.line && (std::strcmp(file, other.file) < 0));\par
6587     \}\par
6588 \par
6589     std::ostream& operator << ( std::ostream& os, SourceLineInfo {\cf17 const}& info ) \{\par
6590 {\cf21 #ifndef __GNUG__}\par
6591         os << info.file << {\cf23 '('} << info.line << {\cf23 ')'};\par
6592 {\cf21 #else}\par
6593         os << info.file << {\cf23 ':'} << info.line;\par
6594 {\cf21 #endif}\par
6595         {\cf19 return} os;\par
6596     \}\par
6597 \par
6598     std::string StreamEndStop::operator+(){\cf17  const }\{\par
6599         {\cf19 return} std::string();\par
6600     \}\par
6601 \par
6602     NonCopyable::NonCopyable() = {\cf19 default};\par
6603     NonCopyable::~NonCopyable() = {\cf19 default};\par
6604 \par
6605 \}\par
6606 {\cf20 // end catch_common.cpp}\par
6607 {\cf20 // start catch_config.cpp}\par
6608 \par
6609 {\cf20 // start catch_enforce.h}\par
6610 \par
6611 {\cf21 #include <stdexcept>}\par
6612 \par
6613 {\cf21 #define CATCH_PREPARE_EXCEPTION( type, msg ) \\}\par
6614 {\cf21     type( ( Catch::ReusableStringStream() << msg ).str() )}\par
6615 {\cf21 #define CATCH_INTERNAL_ERROR( msg ) \\}\par
6616 {\cf21     throw CATCH_PREPARE_EXCEPTION( std::logic_error, CATCH_INTERNAL_LINEINFO << ": Internal Catch error: "} << msg);\par
6617 {\cf21 #define CATCH_ERROR( msg ) \\}\par
6618 {\cf21     throw CATCH_PREPARE_EXCEPTION( std::domain_error, msg )}\par
6619 {\cf21 #define CATCH_ENFORCE( condition, msg ) \\}\par
6620 {\cf21     do\{ if( !(condition) ) CATCH_ERROR( msg ); \} while(false)}\par
6621 \par
6622 {\cf20 // end catch_enforce.h}\par
6623 {\cf17 namespace }Catch \{\par
6624 \par
6625     Config::Config( ConfigData {\cf17 const}& data )\par
6626     :   m_data( data ),\par
6627         m_stream( openStream() )\par
6628     \{\par
6629         TestSpecParser parser(ITagAliasRegistry::get());\par
6630         {\cf19 if} (data.testsOrTags.empty()) \{\par
6631             parser.parse({\cf22 "~[.]"}); {\cf20 // All not hidden tests}\par
6632         \}\par
6633         {\cf19 else} \{\par
6634             m_hasTestFilters = {\cf17 true};\par
6635             {\cf19 for}( {\cf17 auto} {\cf17 const}& testOrTags : data.testsOrTags )\par
6636                 parser.parse( testOrTags );\par
6637         \}\par
6638         m_testSpec = parser.testSpec();\par
6639     \}\par
6640 \par
6641     std::string {\cf17 const}& Config::getFilename(){\cf17  const }\{\par
6642         {\cf19 return} m_data.outputFilename ;\par
6643     \}\par
6644 \par
6645     {\cf18 bool} Config::listTests(){\cf17  const          }\{ {\cf19 return} m_data.listTests; \}\par
6646     {\cf18 bool} Config::listTestNamesOnly(){\cf17  const  }\{ {\cf19 return} m_data.listTestNamesOnly; \}\par
6647     {\cf18 bool} Config::listTags(){\cf17  const           }\{ {\cf19 return} m_data.listTags; \}\par
6648     {\cf18 bool} Config::listReporters(){\cf17  const      }\{ {\cf19 return} m_data.listReporters; \}\par
6649 \par
6650     std::string Config::getProcessName(){\cf17  const }\{ {\cf19 return} m_data.processName; \}\par
6651 \par
6652     std::vector<std::string> {\cf17 const}& Config::getReporterNames(){\cf17  const }\{ {\cf19 return} m_data.reporterNames; \}\par
6653     std::vector<std::string> {\cf17 const}& Config::getTestsOrTags(){\cf17  const }\{ {\cf19 return} m_data.testsOrTags; \}\par
6654     std::vector<std::string> {\cf17 const}& Config::getSectionsToRun(){\cf17  const }\{ {\cf19 return} m_data.sectionsToRun; \}\par
6655 \par
6656     TestSpec {\cf17 const}& Config::testSpec(){\cf17  const }\{ {\cf19 return} m_testSpec; \}\par
6657     {\cf18 bool} Config::hasTestFilters(){\cf17  const }\{ {\cf19 return} m_hasTestFilters; \}\par
6658 \par
6659     {\cf18 bool} Config::showHelp(){\cf17  const }\{ {\cf19 return} m_data.showHelp; \}\par
6660 \par
6661     {\cf20 // IConfig interface}\par
6662     {\cf18 bool} Config::allowThrows(){\cf17  const                   }\{ {\cf19 return} !m_data.noThrow; \}\par
6663     std::ostream& Config::stream(){\cf17  const               }\{ {\cf19 return} m_stream->stream(); \}\par
6664     std::string Config::name(){\cf17  const                   }\{ {\cf19 return} m_data.name.empty() ? m_data.processName : m_data.name; \}\par
6665     {\cf18 bool} Config::includeSuccessfulResults(){\cf17  const      }\{ {\cf19 return} m_data.showSuccessfulTests; \}\par
6666     {\cf18 bool} Config::warnAboutMissingAssertions(){\cf17  const    }\{ {\cf19 return} !!(m_data.warnings & WarnAbout::NoAssertions); \}\par
6667     {\cf18 bool} Config::warnAboutNoTests(){\cf17  const              }\{ {\cf19 return} !!(m_data.warnings & WarnAbout::NoTests); \}\par
6668     ShowDurations::OrNot Config::showDurations(){\cf17  const }\{ {\cf19 return} m_data.showDurations; \}\par
6669     RunTests::InWhatOrder Config::runOrder(){\cf17  const     }\{ {\cf19 return} m_data.runOrder; \}\par
6670     {\cf18 unsigned} {\cf18 int} Config::rngSeed(){\cf17  const               }\{ {\cf19 return} m_data.rngSeed; \}\par
6671     {\cf18 int} Config::benchmarkResolutionMultiple(){\cf17  const    }\{ {\cf19 return} m_data.benchmarkResolutionMultiple; \}\par
6672     UseColour::YesOrNo Config::useColour(){\cf17  const       }\{ {\cf19 return} m_data.useColour; \}\par
6673     {\cf18 bool} Config::shouldDebugBreak(){\cf17  const              }\{ {\cf19 return} m_data.shouldDebugBreak; \}\par
6674     {\cf18 int} Config::abortAfter(){\cf17  const                     }\{ {\cf19 return} m_data.abortAfter; \}\par
6675     {\cf18 bool} Config::showInvisibles(){\cf17  const                }\{ {\cf19 return} m_data.showInvisibles; \}\par
6676     Verbosity Config::verbosity(){\cf17  const                }\{ {\cf19 return} m_data.verbosity; \}\par
6677 \par
6678     IStream {\cf17 const}* Config::openStream() \{\par
6679         {\cf19 return} Catch::makeStream(m_data.outputFilename);\par
6680     \}\par
6681 \par
6682 \} {\cf20 // end namespace Catch}\par
6683 {\cf20 // end catch_config.cpp}\par
6684 {\cf20 // start catch_console_colour.cpp}\par
6685 \par
6686 {\cf21 #if defined(__clang__)}\par
6687 {\cf21 #    pragma clang diagnostic push}\par
6688 {\cf21 #    pragma clang diagnostic ignored "-Wexit-time-destructors"}\par
6689 {\cf21 #endif}\par
6690 \par
6691 {\cf20 // start catch_errno_guard.h}\par
6692 \par
6693 {\cf17 namespace }Catch \{\par
6694 \par
6695     {\cf17 class }ErrnoGuard \{\par
6696     {\cf17 public}:\par
6697         ErrnoGuard();\par
6698         ~ErrnoGuard();\par
6699     {\cf17 private}:\par
6700         {\cf18 int} m_oldErrno;\par
6701     \};\par
6702 \par
6703 \}\par
6704 \par
6705 {\cf20 // end catch_errno_guard.h}\par
6706 {\cf21 #include <sstream>}\par
6707 \par
6708 {\cf17 namespace }Catch \{\par
6709     {\cf17 namespace }\{\par
6710 \par
6711         {\cf17 struct }IColourImpl \{\par
6712             {\cf17 virtual} ~IColourImpl() = {\cf19 default};\par
6713             {\cf17 virtual} {\cf18 void} use( Colour::Code _colourCode ) = 0;\par
6714         \};\par
6715 \par
6716         {\cf17 struct }NoColourImpl : IColourImpl \{\par
6717             {\cf18 void} use( Colour::Code ) \{\}\par
6718 \par
6719             {\cf17 static} IColourImpl* instance() \{\par
6720                 {\cf17 static} NoColourImpl s_instance;\par
6721                 {\cf19 return} &s_instance;\par
6722             \}\par
6723         \};\par
6724 \par
6725     \} {\cf20 // anon namespace}\par
6726 \} {\cf20 // namespace Catch}\par
6727 \par
6728 {\cf21 #if !defined( CATCH_CONFIG_COLOUR_NONE ) && !defined( CATCH_CONFIG_COLOUR_WINDOWS ) && !defined( CATCH_CONFIG_COLOUR_ANSI )}\par
6729 {\cf21 #   ifdef CATCH_PLATFORM_WINDOWS}\par
6730 {\cf21 #       define CATCH_CONFIG_COLOUR_WINDOWS}\par
6731 {\cf21 #   else}\par
6732 {\cf21 #       define CATCH_CONFIG_COLOUR_ANSI}\par
6733 {\cf21 #   endif}\par
6734 {\cf21 #endif}\par
6735 \par
6736 {\cf21 #if defined ( CATCH_CONFIG_COLOUR_WINDOWS ) }\par
6737 \par
6738 {\cf17 namespace }Catch \{\par
6739 {\cf17 namespace }\{\par
6740 \par
6741     {\cf17 class }Win32ColourImpl : {\cf17 public} IColourImpl \{\par
6742     {\cf17 public}:\par
6743         Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )\par
6744         \{\par
6745             CONSOLE_SCREEN_BUFFER_INFO csbiInfo;\par
6746             GetConsoleScreenBufferInfo( stdoutHandle, &csbiInfo );\par
6747             originalForegroundAttributes = csbiInfo.wAttributes & ~( BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY );\par
6748             originalBackgroundAttributes = csbiInfo.wAttributes & ~( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY );\par
6749         \}\par
6750 \par
6751         {\cf17 virtual} {\cf18 void} use( Colour::Code _colourCode ){\cf17  override }\{\par
6752             {\cf19 switch}( _colourCode ) \{\par
6753                 {\cf19 case} Colour::None:      {\cf19 return} setTextAttribute( originalForegroundAttributes );\par
6754                 {\cf19 case} Colour::White:     {\cf19 return} setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );\par
6755                 {\cf19 case} Colour::Red:       {\cf19 return} setTextAttribute( FOREGROUND_RED );\par
6756                 {\cf19 case} Colour::Green:     {\cf19 return} setTextAttribute( FOREGROUND_GREEN );\par
6757                 {\cf19 case} Colour::Blue:      {\cf19 return} setTextAttribute( FOREGROUND_BLUE );\par
6758                 {\cf19 case} Colour::Cyan:      {\cf19 return} setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );\par
6759                 {\cf19 case} Colour::Yellow:    {\cf19 return} setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );\par
6760                 {\cf19 case} Colour::Grey:      {\cf19 return} setTextAttribute( 0 );\par
6761 \par
6762                 {\cf19 case} Colour::LightGrey:     {\cf19 return} setTextAttribute( FOREGROUND_INTENSITY );\par
6763                 {\cf19 case} Colour::BrightRed:     {\cf19 return} setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );\par
6764                 {\cf19 case} Colour::BrightGreen:   {\cf19 return} setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );\par
6765                 {\cf19 case} Colour::BrightWhite:   {\cf19 return} setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );\par
6766                 {\cf19 case} Colour::BrightYellow:  {\cf19 return} setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN );\par
6767 \par
6768                 {\cf19 case} Colour::Bright: CATCH_INTERNAL_ERROR( {\cf22 "not a colour"} );\par
6769 \par
6770                 {\cf19 default}:\par
6771                     CATCH_ERROR( {\cf22 "Unknown colour requested"} );\par
6772             \}\par
6773         \}\par
6774 \par
6775     {\cf17 private}:\par
6776         {\cf18 void} setTextAttribute( WORD _textAttribute ) \{\par
6777             SetConsoleTextAttribute( stdoutHandle, _textAttribute | originalBackgroundAttributes );\par
6778         \}\par
6779         HANDLE stdoutHandle;\par
6780         WORD originalForegroundAttributes;\par
6781         WORD originalBackgroundAttributes;\par
6782     \};\par
6783 \par
6784     IColourImpl* platformColourInstance() \{\par
6785         {\cf17 static} Win32ColourImpl s_instance;\par
6786 \par
6787         IConfigPtr config = getCurrentContext().getConfig();\par
6788         UseColour::YesOrNo colourMode = config\par
6789             ? config->useColour()\par
6790             : UseColour::Auto;\par
6791         {\cf19 if}( colourMode == UseColour::Auto )\par
6792             colourMode = UseColour::Yes;\par
6793         {\cf19 return} colourMode == UseColour::Yes\par
6794             ? &s_instance\par
6795             : NoColourImpl::instance();\par
6796     \}\par
6797 \par
6798 \} {\cf20 // end anon namespace}\par
6799 \} {\cf20 // end namespace Catch}\par
6800 \par
6801 {\cf21 #elif defined( CATCH_CONFIG_COLOUR_ANSI ) }\par
6802 \par
6803 {\cf21 #include <unistd.h>}\par
6804 \par
6805 {\cf17 namespace }Catch \{\par
6806 {\cf17 namespace }\{\par
6807 \par
6808     {\cf20 // use POSIX/ ANSI console terminal codes}\par
6809     {\cf20 // Thanks to Adam Strzelecki for original contribution}\par
6810     {\cf20 // (http://github.com/nanoant)}\par
6811     {\cf20 // https://github.com/philsquared/Catch/pull/131}\par
6812     {\cf17 class }PosixColourImpl : {\cf17 public} IColourImpl \{\par
6813     {\cf17 public}:\par
6814         {\cf17 virtual} {\cf18 void} use( Colour::Code _colourCode ){\cf17  override }\{\par
6815             {\cf19 switch}( _colourCode ) \{\par
6816                 {\cf19 case} Colour::None:\par
6817                 {\cf19 case} Colour::White:     {\cf19 return} setColour( {\cf22 "[0m"} );\par
6818                 {\cf19 case} Colour::Red:       {\cf19 return} setColour( {\cf22 "[0;31m"} );\par
6819                 {\cf19 case} Colour::Green:     {\cf19 return} setColour( {\cf22 "[0;32m"} );\par
6820                 {\cf19 case} Colour::Blue:      {\cf19 return} setColour( {\cf22 "[0;34m"} );\par
6821                 {\cf19 case} Colour::Cyan:      {\cf19 return} setColour( {\cf22 "[0;36m"} );\par
6822                 {\cf19 case} Colour::Yellow:    {\cf19 return} setColour( {\cf22 "[0;33m"} );\par
6823                 {\cf19 case} Colour::Grey:      {\cf19 return} setColour( {\cf22 "[1;30m"} );\par
6824 \par
6825                 {\cf19 case} Colour::LightGrey:     {\cf19 return} setColour( {\cf22 "[0;37m"} );\par
6826                 {\cf19 case} Colour::BrightRed:     {\cf19 return} setColour( {\cf22 "[1;31m"} );\par
6827                 {\cf19 case} Colour::BrightGreen:   {\cf19 return} setColour( {\cf22 "[1;32m"} );\par
6828                 {\cf19 case} Colour::BrightWhite:   {\cf19 return} setColour( {\cf22 "[1;37m"} );\par
6829                 {\cf19 case} Colour::BrightYellow:  {\cf19 return} setColour( {\cf22 "[1;33m"} );\par
6830 \par
6831                 {\cf19 case} Colour::Bright: CATCH_INTERNAL_ERROR( {\cf22 "not a colour"} );\par
6832                 {\cf19 default}: CATCH_INTERNAL_ERROR( {\cf22 "Unknown colour requested"} );\par
6833             \}\par
6834         \}\par
6835         {\cf17 static} IColourImpl* instance() \{\par
6836             {\cf17 static} PosixColourImpl s_instance;\par
6837             {\cf19 return} &s_instance;\par
6838         \}\par
6839 \par
6840     {\cf17 private}:\par
6841         {\cf18 void} setColour( {\cf17 const} {\cf18 char}* _escapeCode ) \{\par
6842             Catch::cout() << {\cf23 '\\033'} << _escapeCode;\par
6843         \}\par
6844     \};\par
6845 \par
6846     {\cf18 bool} useColourOnPlatform() \{\par
6847         {\cf19 return}\par
6848 {\cf21 #ifdef CATCH_PLATFORM_MAC}\par
6849             !isDebuggerActive() &&\par
6850 {\cf21 #endif}\par
6851 {\cf21 #if !(defined(__DJGPP__) && defined(__STRICT_ANSI__))}\par
6852             isatty(STDOUT_FILENO)\par
6853 {\cf21 #else}\par
6854             {\cf17 false}\par
6855 {\cf21 #endif}\par
6856             ;\par
6857     \}\par
6858     IColourImpl* platformColourInstance() \{\par
6859         ErrnoGuard guard;\par
6860         IConfigPtr config = getCurrentContext().getConfig();\par
6861         UseColour::YesOrNo colourMode = config\par
6862             ? config->useColour()\par
6863             : UseColour::Auto;\par
6864         {\cf19 if}( colourMode == UseColour::Auto )\par
6865             colourMode = useColourOnPlatform()\par
6866                 ? UseColour::Yes\par
6867                 : UseColour::No;\par
6868         {\cf19 return} colourMode == UseColour::Yes\par
6869             ? PosixColourImpl::instance()\par
6870             : NoColourImpl::instance();\par
6871     \}\par
6872 \par
6873 \} {\cf20 // end anon namespace}\par
6874 \} {\cf20 // end namespace Catch}\par
6875 \par
6876 {\cf21 #else  }{\cf20 // not Windows or ANSI ///////////////////////////////////////////////}\par
6877 \par
6878 {\cf17 namespace }Catch \{\par
6879 \par
6880     {\cf17 static} IColourImpl* platformColourInstance() \{ {\cf19 return} NoColourImpl::instance(); \}\par
6881 \par
6882 \} {\cf20 // end namespace Catch}\par
6883 \par
6884 {\cf21 #endif }{\cf20 // Windows/ ANSI/ None}\par
6885 \par
6886 {\cf17 namespace }Catch \{\par
6887 \par
6888     Colour::Colour( Code _colourCode ) \{ use( _colourCode ); \}\par
6889     Colour::Colour( Colour&& rhs ) {\cf17 noexcept} \{\par
6890         m_moved = rhs.m_moved;\par
6891         rhs.m_moved = {\cf17 true};\par
6892     \}\par
6893     Colour& Colour::operator=( Colour&& rhs ) {\cf17 noexcept} \{\par
6894         m_moved = rhs.m_moved;\par
6895         rhs.m_moved  = {\cf17 true};\par
6896         {\cf19 return} *{\cf17 this};\par
6897     \}\par
6898 \par
6899     Colour::~Colour()\{ {\cf19 if}( !m_moved ) use( None ); \}\par
6900 \par
6901     {\cf18 void} Colour::use( Code _colourCode ) \{\par
6902         {\cf17 static} IColourImpl* impl = platformColourInstance();\par
6903         impl->use( _colourCode );\par
6904     \}\par
6905 \par
6906     std::ostream& operator << ( std::ostream& os, Colour {\cf17 const}& ) \{\par
6907         {\cf19 return} os;\par
6908     \}\par
6909 \par
6910 \} {\cf20 // end namespace Catch}\par
6911 \par
6912 {\cf21 #if defined(__clang__)}\par
6913 {\cf21 #    pragma clang diagnostic pop}\par
6914 {\cf21 #endif}\par
6915 \par
6916 {\cf20 // end catch_console_colour.cpp}\par
6917 {\cf20 // start catch_context.cpp}\par
6918 \par
6919 {\cf17 namespace }Catch \{\par
6920 \par
6921     {\cf17 class }Context : {\cf17 public} IMutableContext, NonCopyable \{\par
6922 \par
6923     {\cf17 public}: {\cf20 // IContext}\par
6924         {\cf17 virtual} IResultCapture* getResultCapture(){\cf17  override }\{\par
6925             {\cf19 return} m_resultCapture;\par
6926         \}\par
6927         {\cf17 virtual} IRunner* getRunner(){\cf17  override }\{\par
6928             {\cf19 return} m_runner;\par
6929         \}\par
6930 \par
6931         {\cf17 virtual} IConfigPtr {\cf17 const}& getConfig(){\cf17  const override }\{\par
6932             {\cf19 return} m_config;\par
6933         \}\par
6934 \par
6935         {\cf17 virtual} ~Context() {\cf17 override};\par
6936 \par
6937     {\cf17 public}: {\cf20 // IMutableContext}\par
6938         {\cf17 virtual} {\cf18 void} setResultCapture( IResultCapture* resultCapture ){\cf17  override }\{\par
6939             m_resultCapture = resultCapture;\par
6940         \}\par
6941         {\cf17 virtual} {\cf18 void} setRunner( IRunner* runner ){\cf17  override }\{\par
6942             m_runner = runner;\par
6943         \}\par
6944         {\cf17 virtual} {\cf18 void} setConfig( IConfigPtr {\cf17 const}& config ){\cf17  override }\{\par
6945             m_config = config;\par
6946         \}\par
6947 \par
6948         {\cf17 friend} IMutableContext& getCurrentMutableContext();\par
6949 \par
6950     {\cf17 private}:\par
6951         IConfigPtr m_config;\par
6952         IRunner* m_runner = {\cf17 nullptr};\par
6953         IResultCapture* m_resultCapture = {\cf17 nullptr};\par
6954     \};\par
6955 \par
6956     IMutableContext *IMutableContext::currentContext = {\cf17 nullptr};\par
6957 \par
6958     {\cf18 void} IMutableContext::createContext()\par
6959     \{\par
6960         currentContext = {\cf17 new} Context();\par
6961     \}\par
6962 \par
6963     {\cf18 void} cleanUpContext() \{\par
6964         {\cf17 delete} IMutableContext::currentContext;\par
6965         IMutableContext::currentContext = {\cf17 nullptr};\par
6966     \}\par
6967     IContext::~IContext() = {\cf19 default};\par
6968     IMutableContext::~IMutableContext() = {\cf19 default};\par
6969     Context::~Context() = {\cf19 default};\par
6970 \}\par
6971 {\cf20 // end catch_context.cpp}\par
6972 {\cf20 // start catch_debug_console.cpp}\par
6973 \par
6974 {\cf20 // start catch_debug_console.h}\par
6975 \par
6976 {\cf21 #include <string>}\par
6977 \par
6978 {\cf17 namespace }Catch \{\par
6979     {\cf18 void} writeToDebugConsole( std::string {\cf17 const}& text );\par
6980 \}\par
6981 \par
6982 {\cf20 // end catch_debug_console.h}\par
6983 {\cf21 #ifdef CATCH_PLATFORM_WINDOWS}\par
6984 \par
6985     {\cf17 namespace }Catch \{\par
6986         {\cf18 void} writeToDebugConsole( std::string {\cf17 const}& text ) \{\par
6987             ::OutputDebugStringA( text.c_str() );\par
6988         \}\par
6989     \}\par
6990 \par
6991 {\cf21 #else}\par
6992 \par
6993     {\cf17 namespace }Catch \{\par
6994         {\cf18 void} writeToDebugConsole( std::string {\cf17 const}& text ) \{\par
6995             {\cf20 // !TBD: Need a version for Mac/ XCode and other IDEs}\par
6996             Catch::cout() << text;\par
6997         \}\par
6998     \}\par
6999 \par
7000 {\cf21 #endif }{\cf20 // Platform}\par
7001 {\cf20 // end catch_debug_console.cpp}\par
7002 {\cf20 // start catch_debugger.cpp}\par
7003 \par
7004 {\cf21 #ifdef CATCH_PLATFORM_MAC}\par
7005 \par
7006 {\cf21 #  include <assert.h>}\par
7007 {\cf21 #  include <stdbool.h>}\par
7008 {\cf21 #  include <sys/types.h>}\par
7009 {\cf21 #  include <unistd.h>}\par
7010 {\cf21 #  include <sys/sysctl.h>}\par
7011 {\cf21 #  include <cstddef>}\par
7012 {\cf21 #  include <ostream>}\par
7013 \par
7014 {\cf17 namespace }Catch \{\par
7015 \par
7016         {\cf20 // The following function is taken directly from the following technical note:}\par
7017         {\cf20 // http://developer.apple.com/library/mac/#qa/qa2004/qa1361.html}\par
7018 \par
7019         {\cf20 // Returns true if the current process is being debugged (either}\par
7020         {\cf20 // running under the debugger or has a debugger attached post facto).}\par
7021         {\cf18 bool} isDebuggerActive()\{\par
7022 \par
7023             {\cf18 int}                 mib[4];\par
7024             {\cf17 struct }kinfo_proc   info;\par
7025             std::size_t         size;\par
7026 \par
7027             {\cf20 // Initialize the flags so that, if sysctl fails for some bizarre}\par
7028             {\cf20 // reason, we get a predictable result.}\par
7029 \par
7030             info.kp_proc.p_flag = 0;\par
7031 \par
7032             {\cf20 // Initialize mib, which tells sysctl the info we want, in this case}\par
7033             {\cf20 // we're looking for information about a specific process ID.}\par
7034 \par
7035             mib[0] = CTL_KERN;\par
7036             mib[1] = KERN_PROC;\par
7037             mib[2] = KERN_PROC_PID;\par
7038             mib[3] = getpid();\par
7039 \par
7040             {\cf20 // Call sysctl.}\par
7041 \par
7042             size = {\cf17 sizeof}(info);\par
7043             {\cf19 if}( sysctl(mib, {\cf17 sizeof}(mib) / {\cf17 sizeof}(*mib), &info, &size, {\cf17 nullptr}, 0) != 0 ) \{\par
7044                 Catch::cerr() << {\cf22 "\\n** Call to sysctl failed - unable to determine if debugger is active **\\n"} << std::endl;\par
7045                 {\cf19 return} {\cf17 false};\par
7046             \}\par
7047 \par
7048             {\cf20 // We're being debugged if the P_TRACED flag is set.}\par
7049 \par
7050             {\cf19 return} ( (info.kp_proc.p_flag & P_TRACED) != 0 );\par
7051         \}\par
7052     \} {\cf20 // namespace Catch}\par
7053 \par
7054 {\cf21 #elif defined(CATCH_PLATFORM_LINUX)}\par
7055 {\cf21     #include <fstream>}\par
7056 {\cf21     #include <string>}\par
7057 \par
7058     {\cf17 namespace }Catch\{\par
7059         {\cf20 // The standard POSIX way of detecting a debugger is to attempt to}\par
7060         {\cf20 // ptrace() the process, but this needs to be done from a child and not}\par
7061         {\cf20 // this process itself to still allow attaching to this process later}\par
7062         {\cf20 // if wanted, so is rather heavy. Under Linux we have the PID of the}\par
7063         {\cf20 // "debugger" (which doesn't need to be gdb, of course, it could also}\par
7064         {\cf20 // be strace, for example) in /proc/$PID/status, so just get it from}\par
7065         {\cf20 // there instead.}\par
7066         {\cf18 bool} isDebuggerActive()\{\par
7067             {\cf20 // Libstdc++ has a bug, where std::ifstream sets errno to 0}\par
7068             {\cf20 // This way our users can properly assert over errno values}\par
7069             ErrnoGuard guard;\par
7070             std::ifstream in({\cf22 "/proc/self/status"});\par
7071             {\cf19 for}( std::string line; std::getline(in, line); ) \{\par
7072                 {\cf17 static} {\cf17 const} {\cf18 int} PREFIX_LEN = 11;\par
7073                 {\cf19 if}( line.compare(0, PREFIX_LEN, {\cf22 "TracerPid:\\t"}) == 0 ) \{\par
7074                     {\cf20 // We're traced if the PID is not 0 and no other PID starts}\par
7075                     {\cf20 // with 0 digit, so it's enough to check for just a single}\par
7076                     {\cf20 // character.}\par
7077                     {\cf19 return} line.length() > PREFIX_LEN && line[PREFIX_LEN] != {\cf23 '0'};\par
7078                 \}\par
7079             \}\par
7080 \par
7081             {\cf19 return} {\cf17 false};\par
7082         \}\par
7083     \} {\cf20 // namespace Catch}\par
7084 {\cf21 #elif defined(_MSC_VER)}\par
7085     {\cf17 extern} {\cf22 "C"} __declspec(dllimport) {\cf18 int} __stdcall IsDebuggerPresent();\par
7086     {\cf17 namespace }Catch \{\par
7087         {\cf18 bool} isDebuggerActive() \{\par
7088             {\cf19 return} IsDebuggerPresent() != 0;\par
7089         \}\par
7090     \}\par
7091 {\cf21 #elif defined(__MINGW32__)}\par
7092     {\cf17 extern} {\cf22 "C"} __declspec(dllimport) {\cf18 int} __stdcall IsDebuggerPresent();\par
7093     {\cf17 namespace }Catch \{\par
7094         {\cf18 bool} isDebuggerActive() \{\par
7095             {\cf19 return} IsDebuggerPresent() != 0;\par
7096         \}\par
7097     \}\par
7098 {\cf21 #else}\par
7099     {\cf17 namespace }Catch \{\par
7100        {\cf18 bool} isDebuggerActive() \{ {\cf19 return} {\cf17 false}; \}\par
7101     \}\par
7102 {\cf21 #endif }{\cf20 // Platform}\par
7103 {\cf20 // end catch_debugger.cpp}\par
7104 {\cf20 // start catch_decomposer.cpp}\par
7105 \par
7106 {\cf17 namespace }Catch \{\par
7107 \par
7108     ITransientExpression::~ITransientExpression() = {\cf19 default};\par
7109 \par
7110     {\cf18 void} formatReconstructedExpression( std::ostream &os, std::string {\cf17 const}& lhs, StringRef op, std::string {\cf17 const}& rhs ) \{\par
7111         {\cf19 if}( lhs.size() + rhs.size() < 40 &&\par
7112                 lhs.find({\cf23 '\\n'}) == std::string::npos &&\par
7113                 rhs.find({\cf23 '\\n'}) == std::string::npos )\par
7114             os << lhs << {\cf22 " "} << op << {\cf22 " "} << rhs;\par
7115         {\cf19 else}\par
7116             os << lhs << {\cf22 "\\n"} << op << {\cf22 "\\n"} << rhs;\par
7117     \}\par
7118 \}\par
7119 {\cf20 // end catch_decomposer.cpp}\par
7120 {\cf20 // start catch_errno_guard.cpp}\par
7121 \par
7122 {\cf21 #include <cerrno>}\par
7123 \par
7124 {\cf17 namespace }Catch \{\par
7125         ErrnoGuard::ErrnoGuard():m_oldErrno(errno)\{\}\par
7126         ErrnoGuard::~ErrnoGuard() \{ errno = m_oldErrno; \}\par
7127 \}\par
7128 {\cf20 // end catch_errno_guard.cpp}\par
7129 {\cf20 // start catch_exception_translator_registry.cpp}\par
7130 \par
7131 {\cf20 // start catch_exception_translator_registry.h}\par
7132 \par
7133 {\cf21 #include <vector>}\par
7134 {\cf21 #include <string>}\par
7135 {\cf21 #include <memory>}\par
7136 \par
7137 {\cf17 namespace }Catch \{\par
7138 \par
7139     {\cf17 class }ExceptionTranslatorRegistry : {\cf17 public} IExceptionTranslatorRegistry \{\par
7140     {\cf17 public}:\par
7141         ~ExceptionTranslatorRegistry();\par
7142         {\cf17 virtual} {\cf18 void} registerTranslator( {\cf17 const} IExceptionTranslator* translator );\par
7143         {\cf17 virtual} std::string translateActiveException() {\cf17 const override};\par
7144         std::string tryTranslators() {\cf17 const};\par
7145 \par
7146     {\cf17 private}:\par
7147         std::vector<std::unique_ptr<IExceptionTranslator const>> m_translators;\par
7148     \};\par
7149 \}\par
7150 \par
7151 {\cf20 // end catch_exception_translator_registry.h}\par
7152 {\cf21 #ifdef __OBJC__}\par
7153 {\cf21 #import "Foundation/Foundation.h"}\par
7154 {\cf21 #endif}\par
7155 \par
7156 {\cf17 namespace }Catch \{\par
7157 \par
7158     ExceptionTranslatorRegistry::~ExceptionTranslatorRegistry() \{\par
7159     \}\par
7160 \par
7161     {\cf18 void} ExceptionTranslatorRegistry::registerTranslator( {\cf17 const} IExceptionTranslator* translator ) \{\par
7162         m_translators.push_back( std::unique_ptr<const IExceptionTranslator>( translator ) );\par
7163     \}\par
7164 \par
7165     std::string ExceptionTranslatorRegistry::translateActiveException(){\cf17  const }\{\par
7166         {\cf19 try} \{\par
7167 {\cf21 #ifdef __OBJC__}\par
7168             {\cf20 // In Objective-C try objective-c exceptions first}\par
7169             {\cf19 @try} \{\par
7170                 {\cf19 return} tryTranslators();\par
7171             \}\par
7172             {\cf19 @catch} (NSException *exception) \{\par
7173                 {\cf19 return} Catch::Detail::stringify( [exception description] );\par
7174             \}\par
7175 {\cf21 #else}\par
7176             {\cf20 // Compiling a mixed mode project with MSVC means that CLR}\par
7177             {\cf20 // exceptions will be caught in (...) as well. However, these}\par
7178             {\cf20 // do not fill-in std::current_exception and thus lead to crash}\par
7179             {\cf20 // when attempting rethrow.}\par
7180             {\cf20 // /EHa switch also causes structured exceptions to be caught}\par
7181             {\cf20 // here, but they fill-in current_exception properly, so}\par
7182             {\cf20 // at worst the output should be a little weird, instead of}\par
7183             {\cf20 // causing a crash.}\par
7184             {\cf19 if} (std::current_exception() == {\cf17 nullptr}) \{\par
7185                 {\cf19 return} {\cf22 "Non C++ exception. Possibly a CLR exception."};\par
7186             \}\par
7187             {\cf19 return} tryTranslators();\par
7188 {\cf21 #endif}\par
7189         \}\par
7190         {\cf19 catch}( TestFailureException& ) \{\par
7191             std::rethrow_exception(std::current_exception());\par
7192         \}\par
7193         {\cf19 catch}( std::exception& ex ) \{\par
7194             {\cf19 return} ex.what();\par
7195         \}\par
7196         {\cf19 catch}( std::string& msg ) \{\par
7197             {\cf19 return} msg;\par
7198         \}\par
7199         {\cf19 catch}( {\cf17 const} {\cf18 char}* msg ) \{\par
7200             {\cf19 return} msg;\par
7201         \}\par
7202         {\cf19 catch}(...) \{\par
7203             {\cf19 return} {\cf22 "Unknown exception"};\par
7204         \}\par
7205     \}\par
7206 \par
7207     std::string ExceptionTranslatorRegistry::tryTranslators(){\cf17  const }\{\par
7208         {\cf19 if}( m_translators.empty() )\par
7209             std::rethrow_exception(std::current_exception());\par
7210         {\cf19 else}\par
7211             {\cf19 return} m_translators[0]->translate( m_translators.begin()+1, m_translators.end() );\par
7212     \}\par
7213 \}\par
7214 {\cf20 // end catch_exception_translator_registry.cpp}\par
7215 {\cf20 // start catch_fatal_condition.cpp}\par
7216 \par
7217 {\cf21 #if defined(__GNUC__)}\par
7218 {\cf21 #    pragma GCC diagnostic push}\par
7219 {\cf21 #    pragma GCC diagnostic ignored "-Wmissing-field-initializers"}\par
7220 {\cf21 #endif}\par
7221 \par
7222 {\cf21 #if defined( CATCH_CONFIG_WINDOWS_SEH ) || defined( CATCH_CONFIG_POSIX_SIGNALS )}\par
7223 \par
7224 {\cf17 namespace }\{\par
7225     {\cf20 // Report the error condition}\par
7226     {\cf18 void} reportFatal( {\cf18 char} {\cf17 const} * {\cf17 const} message ) \{\par
7227         Catch::getCurrentContext().getResultCapture()->handleFatalErrorCondition( message );\par
7228     \}\par
7229 \}\par
7230 \par
7231 {\cf21 #endif }{\cf20 // signals/SEH handling}\par
7232 \par
7233 {\cf21 #if defined( CATCH_CONFIG_WINDOWS_SEH )}\par
7234 \par
7235 {\cf17 namespace }Catch \{\par
7236     {\cf17 struct }SignalDefs \{ DWORD id; {\cf17 const} {\cf18 char}* name; \};\par
7237 \par
7238     {\cf20 // There is no 1-1 mapping between signals and windows exceptions.}\par
7239     {\cf20 // Windows can easily distinguish between SO and SigSegV,}\par
7240     {\cf20 // but SigInt, SigTerm, etc are handled differently.}\par
7241     {\cf17 static} SignalDefs signalDefs[] = \{\par
7242         \{ EXCEPTION_ILLEGAL_INSTRUCTION,  {\cf22 "SIGILL - Illegal instruction signal"} \},\par
7243         \{ EXCEPTION_STACK_OVERFLOW, {\cf22 "SIGSEGV - Stack overflow"} \},\par
7244         \{ EXCEPTION_ACCESS_VIOLATION, {\cf22 "SIGSEGV - Segmentation violation signal"} \},\par
7245         \{ EXCEPTION_INT_DIVIDE_BY_ZERO, {\cf22 "Divide by zero error"} \},\par
7246     \};\par
7247 \par
7248     LONG CALLBACK FatalConditionHandler::handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) \{\par
7249         {\cf19 for} ({\cf17 auto} {\cf17 const}& def : signalDefs) \{\par
7250             {\cf19 if} (ExceptionInfo->ExceptionRecord->ExceptionCode == def.id) \{\par
7251                 reportFatal(def.name);\par
7252             \}\par
7253         \}\par
7254         {\cf20 // If its not an exception we care about, pass it along.}\par
7255         {\cf20 // This stops us from eating debugger breaks etc.}\par
7256         {\cf19 return} EXCEPTION_CONTINUE_SEARCH;\par
7257     \}\par
7258 \par
7259     FatalConditionHandler::FatalConditionHandler() \{\par
7260         isSet = {\cf17 true};\par
7261         {\cf20 // 32k seems enough for Catch to handle stack overflow,}\par
7262         {\cf20 // but the value was found experimentally, so there is no strong guarantee}\par
7263         guaranteeSize = 32 * 1024;\par
7264         exceptionHandlerHandle = {\cf17 nullptr};\par
7265         {\cf20 // Register as first handler in current chain}\par
7266         exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);\par
7267         {\cf20 // Pass in guarantee size to be filled}\par
7268         SetThreadStackGuarantee(&guaranteeSize);\par
7269     \}\par
7270 \par
7271     {\cf18 void} FatalConditionHandler::reset() \{\par
7272         {\cf19 if} (isSet) \{\par
7273             RemoveVectoredExceptionHandler(exceptionHandlerHandle);\par
7274             SetThreadStackGuarantee(&guaranteeSize);\par
7275             exceptionHandlerHandle = {\cf17 nullptr};\par
7276             isSet = {\cf17 false};\par
7277         \}\par
7278     \}\par
7279 \par
7280     FatalConditionHandler::~FatalConditionHandler() \{\par
7281         reset();\par
7282     \}\par
7283 \par
7284 {\cf18 bool} FatalConditionHandler::isSet = {\cf17 false};\par
7285 ULONG FatalConditionHandler::guaranteeSize = 0;\par
7286 PVOID FatalConditionHandler::exceptionHandlerHandle = {\cf17 nullptr};\par
7287 \par
7288 \} {\cf20 // namespace Catch}\par
7289 \par
7290 {\cf21 #elif defined( CATCH_CONFIG_POSIX_SIGNALS )}\par
7291 \par
7292 {\cf17 namespace }Catch \{\par
7293 \par
7294     {\cf17 struct }SignalDefs \{\par
7295         {\cf18 int} id;\par
7296         {\cf17 const} {\cf18 char}* name;\par
7297     \};\par
7298     {\cf17 static} SignalDefs signalDefs[] = \{\par
7299         \{ SIGINT,  {\cf22 "SIGINT - Terminal interrupt signal"} \},\par
7300         \{ SIGILL,  {\cf22 "SIGILL - Illegal instruction signal"} \},\par
7301         \{ SIGFPE,  {\cf22 "SIGFPE - Floating point error signal"} \},\par
7302         \{ SIGSEGV, {\cf22 "SIGSEGV - Segmentation violation signal"} \},\par
7303         \{ SIGTERM, {\cf22 "SIGTERM - Termination request signal"} \},\par
7304         \{ SIGABRT, {\cf22 "SIGABRT - Abort (abnormal termination) signal"} \}\par
7305     \};\par
7306 \par
7307     {\cf18 void} FatalConditionHandler::handleSignal( {\cf18 int} sig ) \{\par
7308         {\cf18 char} {\cf17 const} * name = {\cf22 "<unknown signal>"};\par
7309         {\cf19 for} ({\cf17 auto} {\cf17 const}& def : signalDefs) \{\par
7310             {\cf19 if} (sig == def.id) \{\par
7311                 name = def.name;\par
7312                 {\cf19 break};\par
7313             \}\par
7314         \}\par
7315         reset();\par
7316         reportFatal(name);\par
7317         raise( sig );\par
7318     \}\par
7319 \par
7320     FatalConditionHandler::FatalConditionHandler() \{\par
7321         isSet = {\cf17 true};\par
7322         stack_t sigStack;\par
7323         sigStack.ss_sp = altStackMem;\par
7324         sigStack.ss_size = SIGSTKSZ;\par
7325         sigStack.ss_flags = 0;\par
7326         sigaltstack(&sigStack, &oldSigStack);\par
7327         {\cf17 struct }sigaction sa = \{ \};\par
7328 \par
7329         sa.sa_handler = handleSignal;\par
7330         sa.sa_flags = SA_ONSTACK;\par
7331         {\cf19 for} (std::size_t i = 0; i < {\cf17 sizeof}(signalDefs)/{\cf17 sizeof}(SignalDefs); ++i) \{\par
7332             sigaction(signalDefs[i].{\cf18 id}, &sa, &oldSigActions[i]);\par
7333         \}\par
7334     \}\par
7335 \par
7336     FatalConditionHandler::~FatalConditionHandler() \{\par
7337         reset();\par
7338     \}\par
7339 \par
7340     {\cf18 void} FatalConditionHandler::reset() \{\par
7341         {\cf19 if}( isSet ) \{\par
7342             {\cf20 // Set signals back to previous values -- hopefully nobody overwrote them in the meantime}\par
7343             {\cf19 for}( std::size_t i = 0; i < {\cf17 sizeof}(signalDefs)/{\cf17 sizeof}(SignalDefs); ++i ) \{\par
7344                 sigaction(signalDefs[i].{\cf18 id}, &oldSigActions[i], {\cf17 nullptr});\par
7345             \}\par
7346             {\cf20 // Return the old stack}\par
7347             sigaltstack(&oldSigStack, {\cf17 nullptr});\par
7348             isSet = {\cf17 false};\par
7349         \}\par
7350     \}\par
7351 \par
7352     {\cf18 bool} FatalConditionHandler::isSet = {\cf17 false};\par
7353     {\cf17 struct }sigaction FatalConditionHandler::oldSigActions[sizeof(signalDefs)/sizeof(SignalDefs)] = \{\};\par
7354     stack_t FatalConditionHandler::oldSigStack = \{\};\par
7355     {\cf18 char} FatalConditionHandler::altStackMem[SIGSTKSZ] = \{\};\par
7356 \par
7357 \} {\cf20 // namespace Catch}\par
7358 \par
7359 {\cf21 #else}\par
7360 \par
7361 {\cf17 namespace }Catch \{\par
7362     {\cf18 void} FatalConditionHandler::reset() \{\}\par
7363 \}\par
7364 \par
7365 {\cf21 #endif }{\cf20 // signals/SEH handling}\par
7366 \par
7367 {\cf21 #if defined(__GNUC__)}\par
7368 {\cf21 #    pragma GCC diagnostic pop}\par
7369 {\cf21 #endif}\par
7370 {\cf20 // end catch_fatal_condition.cpp}\par
7371 {\cf20 // start catch_interfaces_capture.cpp}\par
7372 \par
7373 {\cf17 namespace }Catch \{\par
7374     IResultCapture::~IResultCapture() = {\cf19 default};\par
7375 \}\par
7376 {\cf20 // end catch_interfaces_capture.cpp}\par
7377 {\cf20 // start catch_interfaces_config.cpp}\par
7378 \par
7379 {\cf17 namespace }Catch \{\par
7380     IConfig::~IConfig() = {\cf19 default};\par
7381 \}\par
7382 {\cf20 // end catch_interfaces_config.cpp}\par
7383 {\cf20 // start catch_interfaces_exception.cpp}\par
7384 \par
7385 {\cf17 namespace }Catch \{\par
7386     IExceptionTranslator::~IExceptionTranslator() = {\cf19 default};\par
7387     IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() = {\cf19 default};\par
7388 \}\par
7389 {\cf20 // end catch_interfaces_exception.cpp}\par
7390 {\cf20 // start catch_interfaces_registry_hub.cpp}\par
7391 \par
7392 {\cf17 namespace }Catch \{\par
7393     IRegistryHub::~IRegistryHub() = {\cf19 default};\par
7394     IMutableRegistryHub::~IMutableRegistryHub() = {\cf19 default};\par
7395 \}\par
7396 {\cf20 // end catch_interfaces_registry_hub.cpp}\par
7397 {\cf20 // start catch_interfaces_reporter.cpp}\par
7398 \par
7399 {\cf20 // start catch_reporter_multi.h}\par
7400 \par
7401 {\cf17 namespace }Catch \{\par
7402 \par
7403     {\cf17 class }MultipleReporters : {\cf17 public} IStreamingReporter \{\par
7404         {\cf17 using }Reporters = std::vector<IStreamingReporterPtr>;\par
7405         Reporters m_reporters;\par
7406 \par
7407     {\cf17 public}:\par
7408         {\cf18 void} add( IStreamingReporterPtr&& reporter );\par
7409 \par
7410     {\cf17 public}: {\cf20 // IStreamingReporter}\par
7411 \par
7412         ReporterPreferences getPreferences() {\cf17 const override};\par
7413 \par
7414         {\cf18 void} noMatchingTestCases( std::string {\cf17 const}& spec ) {\cf17 override};\par
7415 \par
7416         {\cf17 static} std::set<Verbosity> getSupportedVerbosities();\par
7417 \par
7418         {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& benchmarkInfo ) {\cf17 override};\par
7419         {\cf18 void} benchmarkEnded( BenchmarkStats {\cf17 const}& benchmarkStats ) {\cf17 override};\par
7420 \par
7421         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& testRunInfo ) {\cf17 override};\par
7422         {\cf18 void} testGroupStarting( GroupInfo {\cf17 const}& groupInfo ) {\cf17 override};\par
7423         {\cf18 void} testCaseStarting( TestCaseInfo {\cf17 const}& testInfo ) {\cf17 override};\par
7424         {\cf18 void} sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) {\cf17 override};\par
7425         {\cf18 void} assertionStarting( AssertionInfo {\cf17 const}& assertionInfo ) {\cf17 override};\par
7426 \par
7427         {\cf20 // The return value indicates if the messages buffer should be cleared:}\par
7428         {\cf18 bool} assertionEnded( AssertionStats {\cf17 const}& assertionStats ) {\cf17 override};\par
7429         {\cf18 void} sectionEnded( SectionStats {\cf17 const}& sectionStats ) {\cf17 override};\par
7430         {\cf18 void} testCaseEnded( TestCaseStats {\cf17 const}& testCaseStats ) {\cf17 override};\par
7431         {\cf18 void} testGroupEnded( TestGroupStats {\cf17 const}& testGroupStats ) {\cf17 override};\par
7432         {\cf18 void} testRunEnded( TestRunStats {\cf17 const}& testRunStats ) {\cf17 override};\par
7433 \par
7434         {\cf18 void} skipTest( TestCaseInfo {\cf17 const}& testInfo ) {\cf17 override};\par
7435         {\cf18 bool} isMulti() {\cf17 const override};\par
7436 \par
7437     \};\par
7438 \par
7439 \} {\cf20 // end namespace Catch}\par
7440 \par
7441 {\cf20 // end catch_reporter_multi.h}\par
7442 {\cf17 namespace }Catch \{\par
7443 \par
7444     ReporterConfig::ReporterConfig( IConfigPtr {\cf17 const}& _fullConfig )\par
7445     :   m_stream( &_fullConfig->stream() ), m_fullConfig( _fullConfig ) \{\}\par
7446 \par
7447     ReporterConfig::ReporterConfig( IConfigPtr {\cf17 const}& _fullConfig, std::ostream& _stream )\par
7448     :   m_stream( &_stream ), m_fullConfig( _fullConfig ) \{\}\par
7449 \par
7450     std::ostream& ReporterConfig::stream(){\cf17  const }\{ {\cf19 return} *m_stream; \}\par
7451     IConfigPtr ReporterConfig::fullConfig(){\cf17  const }\{ {\cf19 return} m_fullConfig; \}\par
7452 \par
7453     TestRunInfo::TestRunInfo( std::string {\cf17 const}& _name ) : name( _name ) \{\}\par
7454 \par
7455     GroupInfo::GroupInfo(  std::string {\cf17 const}& _name,\par
7456                            std::size_t _groupIndex,\par
7457                            std::size_t _groupsCount )\par
7458     :   name( _name ),\par
7459         groupIndex( _groupIndex ),\par
7460         groupsCounts( _groupsCount )\par
7461     \{\}\par
7462 \par
7463      AssertionStats::AssertionStats( AssertionResult {\cf17 const}& _assertionResult,\par
7464                                      std::vector<MessageInfo> {\cf17 const}& _infoMessages,\par
7465                                      Totals {\cf17 const}& _totals )\par
7466     :   assertionResult( _assertionResult ),\par
7467         infoMessages( _infoMessages ),\par
7468         totals( _totals )\par
7469     \{\par
7470         assertionResult.m_resultData.lazyExpression.m_transientExpression = _assertionResult.m_resultData.lazyExpression.m_transientExpression;\par
7471 \par
7472         {\cf19 if}( assertionResult.hasMessage() ) \{\par
7473             {\cf20 // Copy message into messages list.}\par
7474             {\cf20 // !TBD This should have been done earlier, somewhere}\par
7475             MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );\par
7476             builder << assertionResult.getMessage();\par
7477             builder.m_info.message = builder.m_stream.str();\par
7478 \par
7479             infoMessages.push_back( builder.m_info );\par
7480         \}\par
7481     \}\par
7482 \par
7483      AssertionStats::~AssertionStats() = {\cf19 default};\par
7484 \par
7485     SectionStats::SectionStats(  SectionInfo {\cf17 const}& _sectionInfo,\par
7486                                  Counts {\cf17 const}& _assertions,\par
7487                                  {\cf18 double} _durationInSeconds,\par
7488                                  {\cf18 bool} _missingAssertions )\par
7489     :   sectionInfo( _sectionInfo ),\par
7490         assertions( _assertions ),\par
7491         durationInSeconds( _durationInSeconds ),\par
7492         missingAssertions( _missingAssertions )\par
7493     \{\}\par
7494 \par
7495     SectionStats::~SectionStats() = {\cf19 default};\par
7496 \par
7497     TestCaseStats::TestCaseStats(  TestCaseInfo {\cf17 const}& _testInfo,\par
7498                                    Totals {\cf17 const}& _totals,\par
7499                                    std::string {\cf17 const}& _stdOut,\par
7500                                    std::string {\cf17 const}& _stdErr,\par
7501                                    {\cf18 bool} _aborting )\par
7502     : testInfo( _testInfo ),\par
7503         totals( _totals ),\par
7504         stdOut( _stdOut ),\par
7505         stdErr( _stdErr ),\par
7506         aborting( _aborting )\par
7507     \{\}\par
7508 \par
7509     TestCaseStats::~TestCaseStats() = {\cf19 default};\par
7510 \par
7511     TestGroupStats::TestGroupStats( GroupInfo {\cf17 const}& _groupInfo,\par
7512                                     Totals {\cf17 const}& _totals,\par
7513                                     {\cf18 bool} _aborting )\par
7514     :   groupInfo( _groupInfo ),\par
7515         totals( _totals ),\par
7516         aborting( _aborting )\par
7517     \{\}\par
7518 \par
7519     TestGroupStats::TestGroupStats( GroupInfo {\cf17 const}& _groupInfo )\par
7520     :   groupInfo( _groupInfo ),\par
7521         aborting( false )\par
7522     \{\}\par
7523 \par
7524     TestGroupStats::~TestGroupStats() = {\cf19 default};\par
7525 \par
7526     TestRunStats::TestRunStats(   TestRunInfo {\cf17 const}& _runInfo,\par
7527                     Totals {\cf17 const}& _totals,\par
7528                     {\cf18 bool} _aborting )\par
7529     :   runInfo( _runInfo ),\par
7530         totals( _totals ),\par
7531         aborting( _aborting )\par
7532     \{\}\par
7533 \par
7534     TestRunStats::~TestRunStats() = {\cf19 default};\par
7535 \par
7536     {\cf18 void} IStreamingReporter::fatalErrorEncountered( StringRef ) \{\}\par
7537     {\cf18 bool} IStreamingReporter::isMulti(){\cf17  const }\{ {\cf19 return} {\cf17 false}; \}\par
7538 \par
7539     IReporterFactory::~IReporterFactory() = {\cf19 default};\par
7540     IReporterRegistry::~IReporterRegistry() = {\cf19 default};\par
7541 \par
7542     {\cf18 void} addReporter( IStreamingReporterPtr& existingReporter, IStreamingReporterPtr&& additionalReporter ) \{\par
7543 \par
7544         {\cf19 if}( !existingReporter ) \{\par
7545             existingReporter = std::move( additionalReporter );\par
7546             {\cf19 return};\par
7547         \}\par
7548 \par
7549         MultipleReporters* multi = {\cf17 nullptr};\par
7550 \par
7551         {\cf19 if}( existingReporter->isMulti() ) \{\par
7552             multi = {\cf17 static_cast<}MultipleReporters*{\cf17 >}( existingReporter.get() );\par
7553         \}\par
7554         {\cf19 else} \{\par
7555             {\cf17 auto} newMulti = std::unique_ptr<MultipleReporters>( {\cf17 new} MultipleReporters );\par
7556             newMulti->add( std::move( existingReporter ) );\par
7557             multi = newMulti.get();\par
7558             existingReporter = std::move( newMulti );\par
7559         \}\par
7560         multi->add( std::move( additionalReporter ) );\par
7561     \}\par
7562 \par
7563 \} {\cf20 // end namespace Catch}\par
7564 {\cf20 // end catch_interfaces_reporter.cpp}\par
7565 {\cf20 // start catch_interfaces_runner.cpp}\par
7566 \par
7567 {\cf17 namespace }Catch \{\par
7568     IRunner::~IRunner() = {\cf19 default};\par
7569 \}\par
7570 {\cf20 // end catch_interfaces_runner.cpp}\par
7571 {\cf20 // start catch_interfaces_testcase.cpp}\par
7572 \par
7573 {\cf17 namespace }Catch \{\par
7574     ITestInvoker::~ITestInvoker() = {\cf19 default};\par
7575     ITestCaseRegistry::~ITestCaseRegistry() = {\cf19 default};\par
7576 \}\par
7577 {\cf20 // end catch_interfaces_testcase.cpp}\par
7578 {\cf20 // start catch_leak_detector.cpp}\par
7579 \par
7580 {\cf21 #ifdef CATCH_CONFIG_WINDOWS_CRTDBG}\par
7581 {\cf21 #include <crtdbg.h>}\par
7582 \par
7583 {\cf17 namespace }Catch \{\par
7584 \par
7585     LeakDetector::LeakDetector() \{\par
7586         {\cf18 int} flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);\par
7587         flag |= _CRTDBG_LEAK_CHECK_DF;\par
7588         flag |= _CRTDBG_ALLOC_MEM_DF;\par
7589         _CrtSetDbgFlag(flag);\par
7590         _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);\par
7591         _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);\par
7592         {\cf20 // Change this to leaking allocation's number to break there}\par
7593         _CrtSetBreakAlloc(-1);\par
7594     \}\par
7595 \}\par
7596 \par
7597 {\cf21 #else}\par
7598 \par
7599     Catch::LeakDetector::LeakDetector() \{\}\par
7600 \par
7601 {\cf21 #endif}\par
7602 {\cf20 // end catch_leak_detector.cpp}\par
7603 {\cf20 // start catch_list.cpp}\par
7604 \par
7605 {\cf20 // start catch_list.h}\par
7606 \par
7607 {\cf21 #include <set>}\par
7608 \par
7609 {\cf17 namespace }Catch \{\par
7610 \par
7611     std::size_t listTests( Config {\cf17 const}& config );\par
7612 \par
7613     std::size_t listTestsNamesOnly( Config {\cf17 const}& config );\par
7614 \par
7615     {\cf17 struct }TagInfo \{\par
7616         {\cf18 void} add( std::string {\cf17 const}& spelling );\par
7617         std::string all() {\cf17 const};\par
7618 \par
7619         std::set<std::string> spellings;\par
7620         std::size_t count = 0;\par
7621     \};\par
7622 \par
7623     std::size_t listTags( Config {\cf17 const}& config );\par
7624 \par
7625     std::size_t listReporters( Config {\cf17 const}& {\cf20 /*config*/} );\par
7626 \par
7627     Option<std::size_t> list( Config {\cf17 const}& config );\par
7628 \par
7629 \} {\cf20 // end namespace Catch}\par
7630 \par
7631 {\cf20 // end catch_list.h}\par
7632 {\cf20 // start catch_text.h}\par
7633 \par
7634 {\cf17 namespace }Catch \{\par
7635     {\cf17 using namespace }clara::TextFlow;\par
7636 \}\par
7637 \par
7638 {\cf20 // end catch_text.h}\par
7639 {\cf21 #include <limits>}\par
7640 {\cf21 #include <algorithm>}\par
7641 {\cf21 #include <iomanip>}\par
7642 \par
7643 {\cf17 namespace }Catch \{\par
7644 \par
7645     std::size_t listTests( Config {\cf17 const}& config ) \{\par
7646         TestSpec testSpec = config.testSpec();\par
7647         {\cf19 if}( config.hasTestFilters() )\par
7648             Catch::cout() << {\cf22 "Matching test cases:\\n"};\par
7649         {\cf19 else} \{\par
7650             Catch::cout() << {\cf22 "All available test cases:\\n"};\par
7651         \}\par
7652 \par
7653         {\cf17 auto} matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );\par
7654         {\cf19 for}( {\cf17 auto} {\cf17 const}& testCaseInfo : matchedTestCases ) \{\par
7655             Colour::Code colour = testCaseInfo.isHidden()\par
7656                 ? Colour::SecondaryText\par
7657                 : Colour::None;\par
7658             Colour colourGuard( colour );\par
7659 \par
7660             Catch::cout() << Column( testCaseInfo.name ).initialIndent( 2 ).indent( 4 ) << {\cf22 "\\n"};\par
7661             {\cf19 if}( config.verbosity() >= Verbosity::High ) \{\par
7662                 Catch::cout() << Column( Catch::Detail::stringify( testCaseInfo.lineInfo ) ).indent(4) << std::endl;\par
7663                 std::string description = testCaseInfo.description;\par
7664                 {\cf19 if}( description.empty() )\par
7665                     description = {\cf22 "(NO DESCRIPTION)"};\par
7666                 Catch::cout() << Column( description ).indent(4) << std::endl;\par
7667             \}\par
7668             {\cf19 if}( !testCaseInfo.tags.empty() )\par
7669                 Catch::cout() << Column( testCaseInfo.tagsAsString() ).indent( 6 ) << {\cf22 "\\n"};\par
7670         \}\par
7671 \par
7672         {\cf19 if}( !config.hasTestFilters() )\par
7673             Catch::cout() << pluralise( matchedTestCases.size(), {\cf22 "test case"} ) << {\cf23 '\\n'} << std::endl;\par
7674         {\cf19 else}\par
7675             Catch::cout() << pluralise( matchedTestCases.size(), {\cf22 "matching test case"} ) << {\cf23 '\\n'} << std::endl;\par
7676         {\cf19 return} matchedTestCases.size();\par
7677     \}\par
7678 \par
7679     std::size_t listTestsNamesOnly( Config {\cf17 const}& config ) \{\par
7680         TestSpec testSpec = config.testSpec();\par
7681         std::size_t matchedTests = 0;\par
7682         std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );\par
7683         {\cf19 for}( {\cf17 auto} {\cf17 const}& testCaseInfo : matchedTestCases ) \{\par
7684             matchedTests++;\par
7685             {\cf19 if}( startsWith( testCaseInfo.name, {\cf23 '#'} ) )\par
7686                Catch::cout() << {\cf23 '"'} << testCaseInfo.name << {\cf23 '"'};\par
7687             {\cf19 else}\par
7688                Catch::cout() << testCaseInfo.name;\par
7689             {\cf19 if} ( config.verbosity() >= Verbosity::High )\par
7690                 Catch::cout() << {\cf22 "\\t@"} << testCaseInfo.lineInfo;\par
7691             Catch::cout() << std::endl;\par
7692         \}\par
7693         {\cf19 return} matchedTests;\par
7694     \}\par
7695 \par
7696     {\cf18 void} TagInfo::add( std::string {\cf17 const}& spelling ) \{\par
7697         ++count;\par
7698         spellings.insert( spelling );\par
7699     \}\par
7700 \par
7701     std::string TagInfo::all(){\cf17  const }\{\par
7702         std::string out;\par
7703         {\cf19 for}( {\cf17 auto} {\cf17 const}& spelling : spellings )\par
7704             out += {\cf22 "["} + spelling + {\cf22 "]"};\par
7705         {\cf19 return} out;\par
7706     \}\par
7707 \par
7708     std::size_t listTags( Config {\cf17 const}& config ) \{\par
7709         TestSpec testSpec = config.testSpec();\par
7710         {\cf19 if}( config.hasTestFilters() )\par
7711             Catch::cout() << {\cf22 "Tags for matching test cases:\\n"};\par
7712         {\cf19 else} \{\par
7713             Catch::cout() << {\cf22 "All available tags:\\n"};\par
7714         \}\par
7715 \par
7716         std::map<std::string, TagInfo> tagCounts;\par
7717 \par
7718         std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );\par
7719         {\cf19 for}( {\cf17 auto} {\cf17 const}& testCase : matchedTestCases ) \{\par
7720             {\cf19 for}( {\cf17 auto} {\cf17 const}& tagName : testCase.getTestCaseInfo().tags ) \{\par
7721                 std::string lcaseTagName = toLower( tagName );\par
7722                 {\cf17 auto} countIt = tagCounts.find( lcaseTagName );\par
7723                 {\cf19 if}( countIt == tagCounts.end() )\par
7724                     countIt = tagCounts.insert( std::make_pair( lcaseTagName, TagInfo() ) ).first;\par
7725                 countIt->second.add( tagName );\par
7726             \}\par
7727         \}\par
7728 \par
7729         {\cf19 for}( {\cf17 auto} {\cf17 const}& tagCount : tagCounts ) \{\par
7730             ReusableStringStream rss;\par
7731             rss << {\cf22 "  "} << std::setw(2) << tagCount.second.count << {\cf22 "  "};\par
7732             {\cf17 auto} str = rss.str();\par
7733             {\cf17 auto} wrapper = Column( tagCount.second.all() )\par
7734                                                     .initialIndent( 0 )\par
7735                                                     .indent( str.size() )\par
7736                                                     .width( CATCH_CONFIG_CONSOLE_WIDTH-10 );\par
7737             Catch::cout() << str << wrapper << {\cf23 '\\n'};\par
7738         \}\par
7739         Catch::cout() << pluralise( tagCounts.size(), {\cf22 "tag"} ) << {\cf23 '\\n'} << std::endl;\par
7740         {\cf19 return} tagCounts.size();\par
7741     \}\par
7742 \par
7743     std::size_t listReporters( Config {\cf17 const}& {\cf20 /*config*/} ) \{\par
7744         Catch::cout() << {\cf22 "Available reporters:\\n"};\par
7745         IReporterRegistry::FactoryMap {\cf17 const}& factories = getRegistryHub().getReporterRegistry().getFactories();\par
7746         std::size_t maxNameLen = 0;\par
7747         {\cf19 for}( {\cf17 auto} {\cf17 const}& factoryKvp : factories )\par
7748             maxNameLen = (std::max)( maxNameLen, factoryKvp.first.size() );\par
7749 \par
7750         {\cf19 for}( {\cf17 auto} {\cf17 const}& factoryKvp : factories ) \{\par
7751             Catch::cout()\par
7752                     << Column( factoryKvp.first + {\cf22 ":"} )\par
7753                             .indent(2)\par
7754                             .width( 5+maxNameLen )\par
7755                     +  Column( factoryKvp.second->getDescription() )\par
7756                             .initialIndent(0)\par
7757                             .indent(2)\par
7758                             .width( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen-8 )\par
7759                     << "\\n";\par
7760         \}\par
7761         Catch::cout() << std::endl;\par
7762         {\cf19 return} factories.size();\par
7763     \}\par
7764 \par
7765     Option<std::size_t> list( Config {\cf17 const}& config ) \{\par
7766         Option<std::size_t> listedCount;\par
7767         {\cf19 if}( config.listTests() )\par
7768             listedCount = listedCount.valueOr(0) + listTests( config );\par
7769         {\cf19 if}( config.listTestNamesOnly() )\par
7770             listedCount = listedCount.valueOr(0) + listTestsNamesOnly( config );\par
7771         {\cf19 if}( config.listTags() )\par
7772             listedCount = listedCount.valueOr(0) + listTags( config );\par
7773         {\cf19 if}( config.listReporters() )\par
7774             listedCount = listedCount.valueOr(0) + listReporters( config );\par
7775         {\cf19 return} listedCount;\par
7776     \}\par
7777 \par
7778 \} {\cf20 // end namespace Catch}\par
7779 {\cf20 // end catch_list.cpp}\par
7780 {\cf20 // start catch_matchers.cpp}\par
7781 \par
7782 {\cf17 namespace }Catch \{\par
7783 {\cf17 namespace }Matchers \{\par
7784     {\cf17 namespace }Impl \{\par
7785 \par
7786         std::string MatcherUntypedBase::toString(){\cf17  const }\{\par
7787             {\cf19 if}( m_cachedToString.empty() )\par
7788                 m_cachedToString = describe();\par
7789             {\cf19 return} m_cachedToString;\par
7790         \}\par
7791 \par
7792         MatcherUntypedBase::~MatcherUntypedBase() = {\cf19 default};\par
7793 \par
7794     \} {\cf20 // namespace Impl}\par
7795 \} {\cf20 // namespace Matchers}\par
7796 \par
7797 {\cf17 using namespace }Matchers;\par
7798 {\cf17 using }Matchers::Impl::MatcherBase;\par
7799 \par
7800 \} {\cf20 // namespace Catch}\par
7801 {\cf20 // end catch_matchers.cpp}\par
7802 {\cf20 // start catch_matchers_floating.cpp}\par
7803 \par
7804 {\cf21 #include <cstdlib>}\par
7805 {\cf21 #include <cstdint>}\par
7806 {\cf21 #include <cstring>}\par
7807 {\cf21 #include <stdexcept>}\par
7808 \par
7809 {\cf17 namespace }Catch \{\par
7810 {\cf17 namespace }Matchers \{\par
7811 {\cf17 namespace }Floating \{\par
7812 {\cf17 enum class} FloatingPointKind : uint8_t \{\par
7813     Float,\par
7814     Double\par
7815 \};\par
7816 \}\par
7817 \}\par
7818 \}\par
7819 \par
7820 {\cf17 namespace }\{\par
7821 \par
7822 {\cf17 template} <{\cf17 typename} T>\par
7823 {\cf17 struct }Converter;\par
7824 \par
7825 {\cf17 template} <>\par
7826 {\cf17 struct }Converter<float> \{\par
7827     {\cf17 static_assert}({\cf17 sizeof}(float) == {\cf17 sizeof}(int32_t), {\cf22 "Important ULP matcher assumption violated"});\par
7828     Converter({\cf18 float} f) \{\par
7829         std::memcpy(&i, &f, {\cf17 sizeof}(f));\par
7830     \}\par
7831     int32_t i;\par
7832 \};\par
7833 \par
7834 {\cf17 template} <>\par
7835 {\cf17 struct }Converter<double> \{\par
7836     {\cf17 static_assert}({\cf17 sizeof}(double) == {\cf17 sizeof}(int64_t), {\cf22 "Important ULP matcher assumption violated"});\par
7837     Converter({\cf18 double} d) \{\par
7838         std::memcpy(&i, &d, {\cf17 sizeof}(d));\par
7839     \}\par
7840     int64_t i;\par
7841 \};\par
7842 \par
7843 {\cf17 template} <{\cf17 typename} T>\par
7844 {\cf17 auto} convert(T t) -> Converter<T> \{\par
7845     {\cf19 return} Converter<T>(t);\par
7846 \}\par
7847 \par
7848 {\cf17 template} <{\cf17 typename} FP>\par
7849 {\cf18 bool} almostEqualUlps(FP lhs, FP rhs, {\cf18 int} maxUlpDiff) \{\par
7850     {\cf20 // Comparison with NaN should always be false.}\par
7851     {\cf20 // This way we can rule it out before getting into the ugly details}\par
7852     {\cf19 if} (std::isnan(lhs) || std::isnan(rhs)) \{\par
7853         {\cf19 return} {\cf17 false};\par
7854     \}\par
7855 \par
7856     {\cf17 auto} lc = convert(lhs);\par
7857     {\cf17 auto} rc = convert(rhs);\par
7858 \par
7859     {\cf19 if} ((lc.i < 0) != (rc.i < 0)) \{\par
7860         {\cf20 // Potentially we can have +0 and -0}\par
7861         {\cf19 return} lhs == rhs;\par
7862     \}\par
7863 \par
7864     {\cf17 auto} ulpDiff = std::abs(lc.i - rc.i);\par
7865     {\cf19 return} ulpDiff <= maxUlpDiff;\par
7866 \}\par
7867 \par
7868 \}\par
7869 \par
7870 {\cf17 namespace }Catch \{\par
7871 {\cf17 namespace }Matchers \{\par
7872 {\cf17 namespace }Floating \{\par
7873     WithinAbsMatcher::WithinAbsMatcher({\cf18 double} target, {\cf18 double} margin)\par
7874         :m_target\{ target \}, m_margin\{ margin \} \{\par
7875         {\cf19 if} (m_margin < 0) \{\par
7876             {\cf19 throw} std::domain_error({\cf22 "Allowed margin difference has to be >= 0"});\par
7877         \}\par
7878     \}\par
7879 \par
7880     {\cf20 // Performs equivalent check of std::fabs(lhs - rhs) <= margin}\par
7881     {\cf20 // But without the subtraction to allow for INFINITY in comparison}\par
7882     {\cf18 bool} WithinAbsMatcher::match({\cf18 double} {\cf17 const}& matchee){\cf17  const }\{\par
7883         {\cf19 return} (matchee + m_margin >= m_target) && (m_target + m_margin >= m_margin);\par
7884     \}\par
7885 \par
7886     std::string WithinAbsMatcher::describe(){\cf17  const }\{\par
7887         {\cf19 return} {\cf22 "is within "} + ::Catch::Detail::stringify(m_margin) + " of " + ::Catch::Detail::stringify(m_target);\par
7888     \}\par
7889 \par
7890     WithinUlpsMatcher::WithinUlpsMatcher({\cf18 double} target, {\cf18 int} ulps, FloatingPointKind baseType)\par
7891         :m_target\{ target \}, m_ulps\{ ulps \}, m_type\{ baseType \} \{\par
7892         {\cf19 if} (m_ulps < 0) \{\par
7893             {\cf19 throw} std::domain_error({\cf22 "Allowed ulp difference has to be >= 0"});\par
7894         \}\par
7895     \}\par
7896 \par
7897     {\cf18 bool} WithinUlpsMatcher::match({\cf18 double} {\cf17 const}& matchee){\cf17  const }\{\par
7898         {\cf19 switch} (m_type) \{\par
7899         {\cf19 case} FloatingPointKind::Float:\par
7900             {\cf19 return} almostEqualUlps<float>({\cf17 static_cast<}{\cf18 float}{\cf17 >}(matchee), {\cf17 static_cast<}{\cf18 float}{\cf17 >}(m_target), m_ulps);\par
7901         {\cf19 case} FloatingPointKind::Double:\par
7902             {\cf19 return} almostEqualUlps<double>(matchee, m_target, m_ulps);\par
7903         {\cf19 default}:\par
7904             {\cf19 throw} std::domain_error({\cf22 "Unknown FloatingPointKind value"});\par
7905         \}\par
7906     \}\par
7907 \par
7908     std::string WithinUlpsMatcher::describe(){\cf17  const }\{\par
7909         {\cf19 return} {\cf22 "is within "} + std::to_string(m_ulps) + " ULPs of " + ::Catch::Detail::stringify(m_target) + ((m_type == FloatingPointKind::Float)? "f" : "");\par
7910     \}\par
7911 \par
7912 \}{\cf20 // namespace Floating}\par
7913 \par
7914 Floating::WithinUlpsMatcher WithinULP({\cf18 double} target, {\cf18 int} maxUlpDiff) \{\par
7915     {\cf19 return} Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Double);\par
7916 \}\par
7917 \par
7918 Floating::WithinUlpsMatcher WithinULP({\cf18 float} target, {\cf18 int} maxUlpDiff) \{\par
7919     {\cf19 return} Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Float);\par
7920 \}\par
7921 \par
7922 Floating::WithinAbsMatcher WithinAbs({\cf18 double} target, {\cf18 double} margin) \{\par
7923     {\cf19 return} Floating::WithinAbsMatcher(target, margin);\par
7924 \}\par
7925 \par
7926 \} {\cf20 // namespace Matchers}\par
7927 \} {\cf20 // namespace Catch}\par
7928 \par
7929 {\cf20 // end catch_matchers_floating.cpp}\par
7930 {\cf20 // start catch_matchers_string.cpp}\par
7931 \par
7932 {\cf21 #include <regex>}\par
7933 \par
7934 {\cf17 namespace }Catch \{\par
7935 {\cf17 namespace }Matchers \{\par
7936 \par
7937     {\cf17 namespace }StdString \{\par
7938 \par
7939         CasedString::CasedString( std::string {\cf17 const}& str, CaseSensitive::Choice caseSensitivity )\par
7940         :   m_caseSensitivity( caseSensitivity ),\par
7941             m_str( adjustString( str ) )\par
7942         \{\}\par
7943         std::string CasedString::adjustString( std::string {\cf17 const}& str ){\cf17  const }\{\par
7944             {\cf19 return} m_caseSensitivity == CaseSensitive::No\par
7945                    ? toLower( str )\par
7946                    : str;\par
7947         \}\par
7948         std::string CasedString::caseSensitivitySuffix(){\cf17  const }\{\par
7949             {\cf19 return} m_caseSensitivity == CaseSensitive::No\par
7950                    ? {\cf22 " (case insensitive)"}\par
7951                    : std::string();\par
7952         \}\par
7953 \par
7954         StringMatcherBase::StringMatcherBase( std::string {\cf17 const}& operation, CasedString {\cf17 const}& comparator )\par
7955         : m_comparator( comparator ),\par
7956           m_operation( operation ) \{\par
7957         \}\par
7958 \par
7959         std::string StringMatcherBase::describe(){\cf17  const }\{\par
7960             std::string description;\par
7961             description.reserve(5 + m_operation.size() + m_comparator.m_str.size() +\par
7962                                         m_comparator.caseSensitivitySuffix().size());\par
7963             description += m_operation;\par
7964             description += ": \\"";\par
7965             description += m_comparator.m_str;\par
7966             description += "\\"";\par
7967             description += m_comparator.caseSensitivitySuffix();\par
7968             {\cf19 return} description;\par
7969         \}\par
7970 \par
7971         EqualsMatcher::EqualsMatcher( CasedString {\cf17 const}& comparator ) : StringMatcherBase( {\cf22 "equals"}, comparator ) \{\}\par
7972 \par
7973         {\cf18 bool} EqualsMatcher::match( std::string {\cf17 const}& source ){\cf17  const }\{\par
7974             {\cf19 return} m_comparator.adjustString( source ) == m_comparator.m_str;\par
7975         \}\par
7976 \par
7977         ContainsMatcher::ContainsMatcher( CasedString {\cf17 const}& comparator ) : StringMatcherBase( {\cf22 "contains"}, comparator ) \{\}\par
7978 \par
7979         {\cf18 bool} ContainsMatcher::match( std::string {\cf17 const}& source ){\cf17  const }\{\par
7980             {\cf19 return} contains( m_comparator.adjustString( source ), m_comparator.m_str );\par
7981         \}\par
7982 \par
7983         StartsWithMatcher::StartsWithMatcher( CasedString {\cf17 const}& comparator ) : StringMatcherBase( {\cf22 "starts with"}, comparator ) \{\}\par
7984 \par
7985         {\cf18 bool} StartsWithMatcher::match( std::string {\cf17 const}& source ){\cf17  const }\{\par
7986             {\cf19 return} startsWith( m_comparator.adjustString( source ), m_comparator.m_str );\par
7987         \}\par
7988 \par
7989         EndsWithMatcher::EndsWithMatcher( CasedString {\cf17 const}& comparator ) : StringMatcherBase( {\cf22 "ends with"}, comparator ) \{\}\par
7990 \par
7991         {\cf18 bool} EndsWithMatcher::match( std::string {\cf17 const}& source ){\cf17  const }\{\par
7992             {\cf19 return} endsWith( m_comparator.adjustString( source ), m_comparator.m_str );\par
7993         \}\par
7994 \par
7995         RegexMatcher::RegexMatcher(std::string regex, CaseSensitive::Choice caseSensitivity): m_regex(std::move(regex)), m_caseSensitivity(caseSensitivity) \{\}\par
7996 \par
7997         {\cf18 bool} RegexMatcher::match(std::string {\cf17 const}& matchee){\cf17  const }\{\par
7998             {\cf17 auto} flags = std::regex::ECMAScript; {\cf20 // ECMAScript is the default syntax option anyway}\par
7999             {\cf19 if} (m_caseSensitivity == CaseSensitive::Choice::No) \{\par
8000                 flags |= std::regex::icase;\par
8001             \}\par
8002             {\cf17 auto} reg = std::regex(m_regex, flags);\par
8003             {\cf19 return} std::regex_match(matchee, reg);\par
8004         \}\par
8005 \par
8006         std::string RegexMatcher::describe(){\cf17  const }\{\par
8007             {\cf19 return} {\cf22 "matches "} + ::Catch::Detail::stringify(m_regex) + ((m_caseSensitivity == CaseSensitive::Choice::Yes)? " case sensitively" : " case insensitively");\par
8008         \}\par
8009 \par
8010     \} {\cf20 // namespace StdString}\par
8011 \par
8012     StdString::EqualsMatcher Equals( std::string {\cf17 const}& str, CaseSensitive::Choice caseSensitivity ) \{\par
8013         {\cf19 return} StdString::EqualsMatcher( StdString::CasedString( str, caseSensitivity) );\par
8014     \}\par
8015     StdString::ContainsMatcher Contains( std::string {\cf17 const}& str, CaseSensitive::Choice caseSensitivity ) \{\par
8016         {\cf19 return} StdString::ContainsMatcher( StdString::CasedString( str, caseSensitivity) );\par
8017     \}\par
8018     StdString::EndsWithMatcher EndsWith( std::string {\cf17 const}& str, CaseSensitive::Choice caseSensitivity ) \{\par
8019         {\cf19 return} StdString::EndsWithMatcher( StdString::CasedString( str, caseSensitivity) );\par
8020     \}\par
8021     StdString::StartsWithMatcher StartsWith( std::string {\cf17 const}& str, CaseSensitive::Choice caseSensitivity ) \{\par
8022         {\cf19 return} StdString::StartsWithMatcher( StdString::CasedString( str, caseSensitivity) );\par
8023     \}\par
8024 \par
8025     StdString::RegexMatcher Matches(std::string {\cf17 const}& regex, CaseSensitive::Choice caseSensitivity) \{\par
8026         {\cf19 return} StdString::RegexMatcher(regex, caseSensitivity);\par
8027     \}\par
8028 \par
8029 \} {\cf20 // namespace Matchers}\par
8030 \} {\cf20 // namespace Catch}\par
8031 {\cf20 // end catch_matchers_string.cpp}\par
8032 {\cf20 // start catch_message.cpp}\par
8033 \par
8034 {\cf20 // start catch_uncaught_exceptions.h}\par
8035 \par
8036 {\cf17 namespace }Catch \{\par
8037     {\cf18 bool} uncaught_exceptions();\par
8038 \} {\cf20 // end namespace Catch}\par
8039 \par
8040 {\cf20 // end catch_uncaught_exceptions.h}\par
8041 {\cf17 namespace }Catch \{\par
8042 \par
8043     MessageInfo::MessageInfo(   std::string {\cf17 const}& _macroName,\par
8044                                 SourceLineInfo {\cf17 const}& _lineInfo,\par
8045                                 ResultWas::OfType _type )\par
8046     :   macroName( _macroName ),\par
8047         lineInfo( _lineInfo ),\par
8048         type( _type ),\par
8049         sequence( ++globalCount )\par
8050     \{\}\par
8051 \par
8052     {\cf18 bool} MessageInfo::operator==( MessageInfo {\cf17 const}& other ){\cf17  const }\{\par
8053         {\cf19 return} sequence == other.sequence;\par
8054     \}\par
8055 \par
8056     {\cf18 bool} MessageInfo::operator<( MessageInfo {\cf17 const}& other ){\cf17  const }\{\par
8057         {\cf19 return} sequence < other.sequence;\par
8058     \}\par
8059 \par
8060     {\cf20 // This may need protecting if threading support is added}\par
8061     {\cf18 unsigned} {\cf18 int} MessageInfo::globalCount = 0;\par
8062 \par
8064 \par
8065     Catch::MessageBuilder::MessageBuilder( std::string {\cf17 const}& macroName,\par
8066                                            SourceLineInfo {\cf17 const}& lineInfo,\par
8067                                            ResultWas::OfType type )\par
8068         :m_info(macroName, lineInfo, type) \{\}\par
8069 \par
8071 \par
8072     ScopedMessage::ScopedMessage( MessageBuilder {\cf17 const}& builder )\par
8073     : m_info( builder.m_info )\par
8074     \{\par
8075         m_info.message = builder.m_stream.str();\par
8076         getResultCapture().pushScopedMessage( m_info );\par
8077     \}\par
8078 \par
8079     ScopedMessage::~ScopedMessage() \{\par
8080         {\cf19 if} ( !uncaught_exceptions() )\{\par
8081             getResultCapture().popScopedMessage(m_info);\par
8082         \}\par
8083     \}\par
8084 \} {\cf20 // end namespace Catch}\par
8085 {\cf20 // end catch_message.cpp}\par
8086 {\cf20 // start catch_random_number_generator.cpp}\par
8087 \par
8088 {\cf20 // start catch_random_number_generator.h}\par
8089 \par
8090 {\cf21 #include <algorithm>}\par
8091 \par
8092 {\cf17 namespace }Catch \{\par
8093 \par
8094     {\cf17 struct }IConfig;\par
8095 \par
8096     {\cf18 void} seedRng( IConfig {\cf17 const}& config );\par
8097 \par
8098     {\cf18 unsigned} {\cf18 int} rngSeed();\par
8099 \par
8100     {\cf17 struct }RandomNumberGenerator \{\par
8101         {\cf17 using }result_type = {\cf18 unsigned} int;\par
8102 \par
8103         {\cf17 static} {\cf17 constexpr} result_type (min)() \{ {\cf19 return} 0; \}\par
8104         {\cf17 static} {\cf17 constexpr} result_type (max)() \{ {\cf19 return} 1000000; \}\par
8105 \par
8106         result_type operator()( result_type n ) {\cf17 const};\par
8107         result_type operator()() {\cf17 const};\par
8108 \par
8109         {\cf17 template}<{\cf17 typename} V>\par
8110         {\cf17 static} {\cf18 void} shuffle( V& vector ) \{\par
8111             RandomNumberGenerator rng;\par
8112             std::shuffle( vector.begin(), vector.end(), rng );\par
8113         \}\par
8114     \};\par
8115 \par
8116 \}\par
8117 \par
8118 {\cf20 // end catch_random_number_generator.h}\par
8119 {\cf21 #include <cstdlib>}\par
8120 \par
8121 {\cf17 namespace }Catch \{\par
8122 \par
8123     {\cf18 void} seedRng( IConfig {\cf17 const}& config ) \{\par
8124         {\cf19 if}( config.rngSeed() != 0 )\par
8125             std::srand( config.rngSeed() );\par
8126     \}\par
8127     {\cf18 unsigned} {\cf18 int} rngSeed() \{\par
8128         {\cf19 return} getCurrentContext().getConfig()->rngSeed();\par
8129     \}\par
8130 \par
8131     RandomNumberGenerator::result_type RandomNumberGenerator::operator()( result_type n ){\cf17  const }\{\par
8132         {\cf19 return} std::rand() % n;\par
8133     \}\par
8134     RandomNumberGenerator::result_type RandomNumberGenerator::operator()(){\cf17  const }\{\par
8135         {\cf19 return} std::rand() % (max)();\par
8136     \}\par
8137 \par
8138 \}\par
8139 {\cf20 // end catch_random_number_generator.cpp}\par
8140 {\cf20 // start catch_registry_hub.cpp}\par
8141 \par
8142 {\cf20 // start catch_test_case_registry_impl.h}\par
8143 \par
8144 {\cf21 #include <vector>}\par
8145 {\cf21 #include <set>}\par
8146 {\cf21 #include <algorithm>}\par
8147 {\cf21 #include <ios>}\par
8148 \par
8149 {\cf17 namespace }Catch \{\par
8150 \par
8151     {\cf17 class }TestCase;\par
8152     {\cf17 struct }IConfig;\par
8153 \par
8154     std::vector<TestCase> sortTests( IConfig {\cf17 const}& config, std::vector<TestCase> {\cf17 const}& unsortedTestCases );\par
8155     {\cf18 bool} matchTest( TestCase {\cf17 const}& testCase, TestSpec {\cf17 const}& testSpec, IConfig {\cf17 const}& config );\par
8156 \par
8157     {\cf18 void} enforceNoDuplicateTestCases( std::vector<TestCase> {\cf17 const}& functions );\par
8158 \par
8159     std::vector<TestCase> filterTests( std::vector<TestCase> {\cf17 const}& testCases, TestSpec {\cf17 const}& testSpec, IConfig {\cf17 const}& config );\par
8160     std::vector<TestCase> {\cf17 const}& getAllTestCasesSorted( IConfig {\cf17 const}& config );\par
8161 \par
8162     {\cf17 class }TestRegistry : {\cf17 public} ITestCaseRegistry \{\par
8163     {\cf17 public}:\par
8164         {\cf17 virtual} ~TestRegistry() = {\cf19 default};\par
8165 \par
8166         {\cf17 virtual} {\cf18 void} registerTest( TestCase {\cf17 const}& testCase );\par
8167 \par
8168         std::vector<TestCase> {\cf17 const}& getAllTests() {\cf17 const override};\par
8169         std::vector<TestCase> {\cf17 const}& getAllTestsSorted( IConfig {\cf17 const}& config ) {\cf17 const override};\par
8170 \par
8171     {\cf17 private}:\par
8172         std::vector<TestCase> m_functions;\par
8173         {\cf17 mutable} RunTests::InWhatOrder m_currentSortOrder = RunTests::InDeclarationOrder;\par
8174         {\cf17 mutable} std::vector<TestCase> m_sortedFunctions;\par
8175         std::size_t m_unnamedCount = 0;\par
8176         std::ios_base::Init m_ostreamInit; {\cf20 // Forces cout/ cerr to be initialised}\par
8177     \};\par
8178 \par
8180 \par
8181     {\cf17 class }TestInvokerAsFunction : {\cf17 public} ITestInvoker \{\par
8182         void(*m_testAsFunction)();\par
8183     {\cf17 public}:\par
8184         TestInvokerAsFunction( {\cf18 void}(*testAsFunction)() ) noexcept;\par
8185 \par
8186         {\cf18 void} invoke() const override;\par
8187     \};\par
8188 \par
8189     std::{\cf18 string} extractClassName( StringRef const& classOrQualifiedMethodName );\par
8190 \par
8192 \par
8193 \} {\cf20 // end namespace Catch}\par
8194 \par
8195 {\cf20 // end catch_test_case_registry_impl.h}\par
8196 {\cf20 // start catch_reporter_registry.h}\par
8197 \par
8198 {\cf21 #include <map>}\par
8199 \par
8200 {\cf17 namespace }Catch \{\par
8201 \par
8202     {\cf17 class }ReporterRegistry : {\cf17 public} IReporterRegistry \{\par
8203 \par
8204     {\cf17 public}:\par
8205 \par
8206         ~ReporterRegistry() {\cf17 override};\par
8207 \par
8208         IStreamingReporterPtr create( std::string {\cf17 const}& name, IConfigPtr {\cf17 const}& config ) {\cf17 const override};\par
8209 \par
8210         {\cf18 void} registerReporter( std::string {\cf17 const}& name, IReporterFactoryPtr {\cf17 const}& factory );\par
8211         {\cf18 void} registerListener( IReporterFactoryPtr {\cf17 const}& factory );\par
8212 \par
8213         FactoryMap {\cf17 const}& getFactories() {\cf17 const override};\par
8214         Listeners {\cf17 const}& getListeners() {\cf17 const override};\par
8215 \par
8216     {\cf17 private}:\par
8217         FactoryMap m_factories;\par
8218         Listeners m_listeners;\par
8219     \};\par
8220 \}\par
8221 \par
8222 {\cf20 // end catch_reporter_registry.h}\par
8223 {\cf20 // start catch_tag_alias_registry.h}\par
8224 \par
8225 {\cf20 // start catch_tag_alias.h}\par
8226 \par
8227 {\cf21 #include <string>}\par
8228 \par
8229 {\cf17 namespace }Catch \{\par
8230 \par
8231     {\cf17 struct }TagAlias \{\par
8232         TagAlias(std::string {\cf17 const}& _tag, SourceLineInfo _lineInfo);\par
8233 \par
8234         std::string tag;\par
8235         SourceLineInfo lineInfo;\par
8236     \};\par
8237 \par
8238 \} {\cf20 // end namespace Catch}\par
8239 \par
8240 {\cf20 // end catch_tag_alias.h}\par
8241 {\cf21 #include <map>}\par
8242 \par
8243 {\cf17 namespace }Catch \{\par
8244 \par
8245     {\cf17 class }TagAliasRegistry : {\cf17 public} ITagAliasRegistry \{\par
8246     {\cf17 public}:\par
8247         ~TagAliasRegistry() {\cf17 override};\par
8248         TagAlias {\cf17 const}* find( std::string {\cf17 const}& alias ) {\cf17 const override};\par
8249         std::string expandAliases( std::string {\cf17 const}& unexpandedTestSpec ) {\cf17 const override};\par
8250         {\cf18 void} add( std::string {\cf17 const}& alias, std::string {\cf17 const}& tag, SourceLineInfo {\cf17 const}& lineInfo );\par
8251 \par
8252     {\cf17 private}:\par
8253         std::map<std::string, TagAlias> m_registry;\par
8254     \};\par
8255 \par
8256 \} {\cf20 // end namespace Catch}\par
8257 \par
8258 {\cf20 // end catch_tag_alias_registry.h}\par
8259 {\cf20 // start catch_startup_exception_registry.h}\par
8260 \par
8261 {\cf21 #include <vector>}\par
8262 {\cf21 #include <exception>}\par
8263 \par
8264 {\cf17 namespace }Catch \{\par
8265 \par
8266     {\cf17 class }StartupExceptionRegistry \{\par
8267     {\cf17 public}:\par
8268         {\cf18 void} add(std::exception_ptr {\cf17 const}& exception) {\cf17 noexcept};\par
8269         std::vector<std::exception_ptr> {\cf17 const}& getExceptions() const noexcept;\par
8270     private:\par
8271         std::vector<std::exception_ptr> m_exceptions;\par
8272     \};\par
8273 \par
8274 \} {\cf20 // end namespace Catch}\par
8275 \par
8276 {\cf20 // end catch_startup_exception_registry.h}\par
8277 namespace Catch \{\par
8278 \par
8279     {\cf17 namespace }\{\par
8280 \par
8281         {\cf17 class }RegistryHub : {\cf17 public} IRegistryHub, {\cf17 public} IMutableRegistryHub,\par
8282                             {\cf17 private} NonCopyable \{\par
8283 \par
8284         {\cf17 public}: {\cf20 // IRegistryHub}\par
8285             RegistryHub() = {\cf19 default};\par
8286             IReporterRegistry {\cf17 const}& getReporterRegistry(){\cf17  const override }\{\par
8287                 {\cf19 return} m_reporterRegistry;\par
8288             \}\par
8289             ITestCaseRegistry {\cf17 const}& getTestCaseRegistry(){\cf17  const override }\{\par
8290                 {\cf19 return} m_testCaseRegistry;\par
8291             \}\par
8292             IExceptionTranslatorRegistry& getExceptionTranslatorRegistry(){\cf17  override }\{\par
8293                 {\cf19 return} m_exceptionTranslatorRegistry;\par
8294             \}\par
8295             ITagAliasRegistry {\cf17 const}& getTagAliasRegistry(){\cf17  const override }\{\par
8296                 {\cf19 return} m_tagAliasRegistry;\par
8297             \}\par
8298             StartupExceptionRegistry {\cf17 const}& getStartupExceptionRegistry(){\cf17  const override }\{\par
8299                 {\cf19 return} m_exceptionRegistry;\par
8300             \}\par
8301 \par
8302         {\cf17 public}: {\cf20 // IMutableRegistryHub}\par
8303             {\cf18 void} registerReporter( std::string {\cf17 const}& name, IReporterFactoryPtr {\cf17 const}& factory ){\cf17  override }\{\par
8304                 m_reporterRegistry.registerReporter( name, factory );\par
8305             \}\par
8306             {\cf18 void} registerListener( IReporterFactoryPtr {\cf17 const}& factory ){\cf17  override }\{\par
8307                 m_reporterRegistry.registerListener( factory );\par
8308             \}\par
8309             {\cf18 void} registerTest( TestCase {\cf17 const}& testInfo ){\cf17  override }\{\par
8310                 m_testCaseRegistry.registerTest( testInfo );\par
8311             \}\par
8312             {\cf18 void} registerTranslator( {\cf17 const} IExceptionTranslator* translator ){\cf17  override }\{\par
8313                 m_exceptionTranslatorRegistry.registerTranslator( translator );\par
8314             \}\par
8315             {\cf18 void} registerTagAlias( std::string {\cf17 const}& alias, std::string {\cf17 const}& tag, SourceLineInfo {\cf17 const}& lineInfo ){\cf17  override }\{\par
8316                 m_tagAliasRegistry.add( alias, tag, lineInfo );\par
8317             \}\par
8318             {\cf18 void} registerStartupException() noexcept{\cf17  override }\{\par
8319                 m_exceptionRegistry.add(std::current_exception());\par
8320             \}\par
8321 \par
8322         {\cf17 private}:\par
8323             TestRegistry m_testCaseRegistry;\par
8324             ReporterRegistry m_reporterRegistry;\par
8325             ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;\par
8326             TagAliasRegistry m_tagAliasRegistry;\par
8327             StartupExceptionRegistry m_exceptionRegistry;\par
8328         \};\par
8329 \par
8330         {\cf20 // Single, global, instance}\par
8331         RegistryHub*& getTheRegistryHub() \{\par
8332             {\cf17 static} RegistryHub* theRegistryHub = {\cf17 nullptr};\par
8333             {\cf19 if}( !theRegistryHub )\par
8334                 theRegistryHub = {\cf17 new} RegistryHub();\par
8335             {\cf19 return} theRegistryHub;\par
8336         \}\par
8337     \}\par
8338 \par
8339     IRegistryHub& getRegistryHub() \{\par
8340         {\cf19 return} *getTheRegistryHub();\par
8341     \}\par
8342     IMutableRegistryHub& getMutableRegistryHub() \{\par
8343         {\cf19 return} *getTheRegistryHub();\par
8344     \}\par
8345     {\cf18 void} cleanUp() \{\par
8346         {\cf17 delete} getTheRegistryHub();\par
8347         getTheRegistryHub() = {\cf17 nullptr};\par
8348         cleanUpContext();\par
8349         ReusableStringStream::cleanup();\par
8350     \}\par
8351     std::string translateActiveException() \{\par
8352         {\cf19 return} getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();\par
8353     \}\par
8354 \par
8355 \} {\cf20 // end namespace Catch}\par
8356 {\cf20 // end catch_registry_hub.cpp}\par
8357 {\cf20 // start catch_reporter_registry.cpp}\par
8358 \par
8359 {\cf17 namespace }Catch \{\par
8360 \par
8361     ReporterRegistry::~ReporterRegistry() = {\cf19 default};\par
8362 \par
8363     IStreamingReporterPtr ReporterRegistry::create( std::string {\cf17 const}& name, IConfigPtr {\cf17 const}& config ){\cf17  const }\{\par
8364         {\cf17 auto} it =  m_factories.find( name );\par
8365         {\cf19 if}( it == m_factories.end() )\par
8366             {\cf19 return} {\cf17 nullptr};\par
8367         {\cf19 return} it->second->create( ReporterConfig( config ) );\par
8368     \}\par
8369 \par
8370     {\cf18 void} ReporterRegistry::registerReporter( std::string {\cf17 const}& name, IReporterFactoryPtr {\cf17 const}& factory ) \{\par
8371         m_factories.emplace(name, factory);\par
8372     \}\par
8373     {\cf18 void} ReporterRegistry::registerListener( IReporterFactoryPtr {\cf17 const}& factory ) \{\par
8374         m_listeners.push_back( factory );\par
8375     \}\par
8376 \par
8377     IReporterRegistry::FactoryMap {\cf17 const}& ReporterRegistry::getFactories(){\cf17  const }\{\par
8378         {\cf19 return} m_factories;\par
8379     \}\par
8380     IReporterRegistry::Listeners {\cf17 const}& ReporterRegistry::getListeners(){\cf17  const }\{\par
8381         {\cf19 return} m_listeners;\par
8382     \}\par
8383 \par
8384 \}\par
8385 {\cf20 // end catch_reporter_registry.cpp}\par
8386 {\cf20 // start catch_result_type.cpp}\par
8387 \par
8388 {\cf17 namespace }Catch \{\par
8389 \par
8390     {\cf18 bool} isOk( ResultWas::OfType resultType ) \{\par
8391         {\cf19 return} ( resultType & ResultWas::FailureBit ) == 0;\par
8392     \}\par
8393     {\cf18 bool} isJustInfo( {\cf18 int} flags ) \{\par
8394         {\cf19 return} flags == ResultWas::Info;\par
8395     \}\par
8396 \par
8397     ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) \{\par
8398         {\cf19 return} {\cf17 static_cast<}ResultDisposition::Flags{\cf17 >}( {\cf17 static_cast<}{\cf18 int}{\cf17 >}( lhs ) | {\cf17 static_cast<}{\cf18 int}{\cf17 >}( rhs ) );\par
8399     \}\par
8400 \par
8401     {\cf18 bool} shouldContinueOnFailure( {\cf18 int} flags )    \{ {\cf19 return} ( flags & ResultDisposition::ContinueOnFailure ) != 0; \}\par
8402     {\cf18 bool} shouldSuppressFailure( {\cf18 int} flags )      \{ {\cf19 return} ( flags & ResultDisposition::SuppressFail ) != 0; \}\par
8403 \par
8404 \} {\cf20 // end namespace Catch}\par
8405 {\cf20 // end catch_result_type.cpp}\par
8406 {\cf20 // start catch_run_context.cpp}\par
8407 \par
8408 {\cf21 #include <cassert>}\par
8409 {\cf21 #include <algorithm>}\par
8410 {\cf21 #include <sstream>}\par
8411 \par
8412 {\cf17 namespace }Catch \{\par
8413 \par
8414     {\cf17 class }RedirectedStream \{\par
8415         std::ostream& m_originalStream;\par
8416         std::ostream& m_redirectionStream;\par
8417         std::streambuf* m_prevBuf;\par
8418 \par
8419     {\cf17 public}:\par
8420         RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream )\par
8421         :   m_originalStream( originalStream ),\par
8422             m_redirectionStream( redirectionStream ),\par
8423             m_prevBuf( m_originalStream.rdbuf() )\par
8424         \{\par
8425             m_originalStream.rdbuf( m_redirectionStream.rdbuf() );\par
8426         \}\par
8427         ~RedirectedStream() \{\par
8428             m_originalStream.rdbuf( m_prevBuf );\par
8429         \}\par
8430     \};\par
8431 \par
8432     {\cf17 class }RedirectedStdOut \{\par
8433         ReusableStringStream m_rss;\par
8434         RedirectedStream m_cout;\par
8435     {\cf17 public}:\par
8436         RedirectedStdOut() : m_cout( Catch::cout(), m_rss.get() ) \{\}\par
8437         {\cf17 auto} str() const -> std::{\cf18 string} \{ {\cf19 return} m_rss.str(); \}\par
8438     \};\par
8439 \par
8440     {\cf20 // StdErr has two constituent streams in C++, std::cerr and std::clog}\par
8441     {\cf20 // This means that we need to redirect 2 streams into 1 to keep proper}\par
8442     {\cf20 // order of writes}\par
8443     {\cf17 class }RedirectedStdErr \{\par
8444         ReusableStringStream m_rss;\par
8445         RedirectedStream m_cerr;\par
8446         RedirectedStream m_clog;\par
8447     {\cf17 public}:\par
8448         RedirectedStdErr()\par
8449         :   m_cerr( Catch::cerr(), m_rss.get() ),\par
8450             m_clog( Catch::clog(), m_rss.get() )\par
8451         \{\}\par
8452         {\cf17 auto} str() const -> std::{\cf18 string} \{ {\cf19 return} m_rss.str(); \}\par
8453     \};\par
8454 \par
8455     RunContext::RunContext(IConfigPtr {\cf17 const}& _config, IStreamingReporterPtr&& reporter)\par
8456     :   m_runInfo(_config->name()),\par
8457         m_context(getCurrentMutableContext()),\par
8458         m_config(_config),\par
8459         m_reporter(std::move(reporter)),\par
8460         m_lastAssertionInfo\{ StringRef(), SourceLineInfo({\cf22 ""},0), StringRef(), ResultDisposition::Normal \},\par
8461         m_includeSuccessfulResults( m_config->includeSuccessfulResults() )\par
8462     \{\par
8463         m_context.setRunner({\cf17 this});\par
8464         m_context.setConfig(m_config);\par
8465         m_context.setResultCapture({\cf17 this});\par
8466         m_reporter->testRunStarting(m_runInfo);\par
8467     \}\par
8468 \par
8469     RunContext::~RunContext() \{\par
8470         m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, aborting()));\par
8471     \}\par
8472 \par
8473     {\cf18 void} RunContext::testGroupStarting(std::string {\cf17 const}& testSpec, std::size_t groupIndex, std::size_t groupsCount) \{\par
8474         m_reporter->testGroupStarting(GroupInfo(testSpec, groupIndex, groupsCount));\par
8475     \}\par
8476 \par
8477     {\cf18 void} RunContext::testGroupEnded(std::string {\cf17 const}& testSpec, Totals {\cf17 const}& totals, std::size_t groupIndex, std::size_t groupsCount) \{\par
8478         m_reporter->testGroupEnded(TestGroupStats(GroupInfo(testSpec, groupIndex, groupsCount), totals, aborting()));\par
8479     \}\par
8480 \par
8481     Totals RunContext::runTest(TestCase {\cf17 const}& testCase) \{\par
8482         Totals prevTotals = m_totals;\par
8483 \par
8484         std::string redirectedCout;\par
8485         std::string redirectedCerr;\par
8486 \par
8487         {\cf17 auto} {\cf17 const}& testInfo = testCase.getTestCaseInfo();\par
8488 \par
8489         m_reporter->testCaseStarting(testInfo);\par
8490 \par
8491         m_activeTestCase = &testCase;\par
8492 \par
8493         ITracker& rootTracker = m_trackerContext.startRun();\par
8494         assert(rootTracker.isSectionTracker());\par
8495         {\cf17 static_cast<}SectionTracker&{\cf17 >}(rootTracker).addInitialFilters(m_config->getSectionsToRun());\par
8496         {\cf19 do} \{\par
8497             m_trackerContext.startCycle();\par
8498             m_testCaseTracker = &SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(testInfo.name, testInfo.lineInfo));\par
8499             runCurrentTest(redirectedCout, redirectedCerr);\par
8500         \} {\cf19 while} (!m_testCaseTracker->isSuccessfullyCompleted() && !aborting());\par
8501 \par
8502         Totals deltaTotals = m_totals.delta(prevTotals);\par
8503         {\cf19 if} (testInfo.expectedToFail() && deltaTotals.testCases.passed > 0) \{\par
8504             deltaTotals.assertions.failed++;\par
8505             deltaTotals.testCases.passed--;\par
8506             deltaTotals.testCases.failed++;\par
8507         \}\par
8508         m_totals.testCases += deltaTotals.testCases;\par
8509         m_reporter->testCaseEnded(TestCaseStats(testInfo,\par
8510                                   deltaTotals,\par
8511                                   redirectedCout,\par
8512                                   redirectedCerr,\par
8513                                   aborting()));\par
8514 \par
8515         m_activeTestCase = {\cf17 nullptr};\par
8516         m_testCaseTracker = {\cf17 nullptr};\par
8517 \par
8518         {\cf19 return} deltaTotals;\par
8519     \}\par
8520 \par
8521     IConfigPtr RunContext::config(){\cf17  const }\{\par
8522         {\cf19 return} m_config;\par
8523     \}\par
8524 \par
8525     IStreamingReporter& RunContext::reporter(){\cf17  const }\{\par
8526         {\cf19 return} *m_reporter;\par
8527     \}\par
8528 \par
8529     {\cf18 void} RunContext::assertionEnded(AssertionResult {\cf17 const} & result) \{\par
8530         {\cf19 if} (result.getResultType() == ResultWas::Ok) \{\par
8531             m_totals.assertions.passed++;\par
8532             m_lastAssertionPassed = {\cf17 true};\par
8533         \} {\cf19 else} {\cf19 if} (!result.isOk()) \{\par
8534             m_lastAssertionPassed = {\cf17 false};\par
8535             {\cf19 if}( m_activeTestCase->getTestCaseInfo().okToFail() )\par
8536                 m_totals.assertions.failedButOk++;\par
8537             {\cf19 else}\par
8538                 m_totals.assertions.failed++;\par
8539         \}\par
8540         {\cf19 else} \{\par
8541             m_lastAssertionPassed = {\cf17 true};\par
8542         \}\par
8543 \par
8544         {\cf20 // We have no use for the return value (whether messages should be cleared), because messages were made scoped}\par
8545         {\cf20 // and should be let to clear themselves out.}\par
8546         {\cf17 static_cast<}{\cf18 void}{\cf17 >}(m_reporter->assertionEnded(AssertionStats(result, m_messages, m_totals)));\par
8547 \par
8548         {\cf20 // Reset working state}\par
8549         resetAssertionInfo();\par
8550         m_lastResult = result;\par
8551     \}\par
8552     {\cf18 void} RunContext::resetAssertionInfo() \{\par
8553         m_lastAssertionInfo.macroName = StringRef();\par
8554         m_lastAssertionInfo.capturedExpression = {\cf22 "\{Unknown expression after the reported line\}"}_sr;\par
8555     \}\par
8556 \par
8557     {\cf18 bool} RunContext::sectionStarted(SectionInfo {\cf17 const} & sectionInfo, Counts & assertions) \{\par
8558         ITracker& sectionTracker = SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(sectionInfo.name, sectionInfo.lineInfo));\par
8559         {\cf19 if} (!sectionTracker.isOpen())\par
8560             {\cf19 return} {\cf17 false};\par
8561         m_activeSections.push_back(&sectionTracker);\par
8562 \par
8563         m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;\par
8564 \par
8565         m_reporter->sectionStarting(sectionInfo);\par
8566 \par
8567         assertions = m_totals.assertions;\par
8568 \par
8569         {\cf19 return} {\cf17 true};\par
8570     \}\par
8571 \par
8572     {\cf18 bool} RunContext::testForMissingAssertions(Counts& assertions) \{\par
8573         {\cf19 if} (assertions.total() != 0)\par
8574             {\cf19 return} {\cf17 false};\par
8575         {\cf19 if} (!m_config->warnAboutMissingAssertions())\par
8576             {\cf19 return} {\cf17 false};\par
8577         {\cf19 if} (m_trackerContext.currentTracker().hasChildren())\par
8578             {\cf19 return} {\cf17 false};\par
8579         m_totals.assertions.failed++;\par
8580         assertions.failed++;\par
8581         {\cf19 return} {\cf17 true};\par
8582     \}\par
8583 \par
8584     {\cf18 void} RunContext::sectionEnded(SectionEndInfo {\cf17 const} & endInfo) \{\par
8585         Counts assertions = m_totals.assertions - endInfo.prevAssertions;\par
8586         {\cf18 bool} missingAssertions = testForMissingAssertions(assertions);\par
8587 \par
8588         {\cf19 if} (!m_activeSections.empty()) \{\par
8589             m_activeSections.back()->close();\par
8590             m_activeSections.pop_back();\par
8591         \}\par
8592 \par
8593         m_reporter->sectionEnded(SectionStats(endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions));\par
8594         m_messages.clear();\par
8595     \}\par
8596 \par
8597     {\cf18 void} RunContext::sectionEndedEarly(SectionEndInfo {\cf17 const} & endInfo) \{\par
8598         {\cf19 if} (m_unfinishedSections.empty())\par
8599             m_activeSections.back()->fail();\par
8600         {\cf19 else}\par
8601             m_activeSections.back()->close();\par
8602         m_activeSections.pop_back();\par
8603 \par
8604         m_unfinishedSections.push_back(endInfo);\par
8605     \}\par
8606     {\cf18 void} RunContext::benchmarkStarting( BenchmarkInfo {\cf17 const}& info ) \{\par
8607         m_reporter->benchmarkStarting( info );\par
8608     \}\par
8609     {\cf18 void} RunContext::benchmarkEnded( BenchmarkStats {\cf17 const}& stats ) \{\par
8610         m_reporter->benchmarkEnded( stats );\par
8611     \}\par
8612 \par
8613     {\cf18 void} RunContext::pushScopedMessage(MessageInfo {\cf17 const} & message) \{\par
8614         m_messages.push_back(message);\par
8615     \}\par
8616 \par
8617     {\cf18 void} RunContext::popScopedMessage(MessageInfo {\cf17 const} & message) \{\par
8618         m_messages.erase(std::remove(m_messages.begin(), m_messages.end(), message), m_messages.end());\par
8619     \}\par
8620 \par
8621     std::string RunContext::getCurrentTestName(){\cf17  const }\{\par
8622         {\cf19 return} m_activeTestCase\par
8623             ? m_activeTestCase->getTestCaseInfo().name\par
8624             : std::string();\par
8625     \}\par
8626 \par
8627     {\cf17 const} AssertionResult * RunContext::getLastResult(){\cf17  const }\{\par
8628         {\cf19 return} &(*m_lastResult);\par
8629     \}\par
8630 \par
8631     {\cf18 void} RunContext::exceptionEarlyReported() \{\par
8632         m_shouldReportUnexpected = {\cf17 false};\par
8633     \}\par
8634 \par
8635     {\cf18 void} RunContext::handleFatalErrorCondition( StringRef message ) \{\par
8636         {\cf20 // First notify reporter that bad things happened}\par
8637         m_reporter->fatalErrorEncountered(message);\par
8638 \par
8639         {\cf20 // Don't rebuild the result -- the stringification itself can cause more fatal errors}\par
8640         {\cf20 // Instead, fake a result data.}\par
8641         AssertionResultData tempResult( ResultWas::FatalErrorCondition, \{ {\cf17 false} \} );\par
8642         tempResult.message = message;\par
8643         AssertionResult result(m_lastAssertionInfo, tempResult);\par
8644 \par
8645         assertionEnded(result);\par
8646 \par
8647         handleUnfinishedSections();\par
8648 \par
8649         {\cf20 // Recreate section for test case (as we will lose the one that was in scope)}\par
8650         {\cf17 auto} {\cf17 const}& testCaseInfo = m_activeTestCase->getTestCaseInfo();\par
8651         SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description);\par
8652 \par
8653         Counts assertions;\par
8654         assertions.failed = 1;\par
8655         SectionStats testCaseSectionStats(testCaseSection, assertions, 0, {\cf17 false});\par
8656         m_reporter->sectionEnded(testCaseSectionStats);\par
8657 \par
8658         {\cf17 auto} {\cf17 const}& testInfo = m_activeTestCase->getTestCaseInfo();\par
8659 \par
8660         Totals deltaTotals;\par
8661         deltaTotals.testCases.failed = 1;\par
8662         deltaTotals.assertions.failed = 1;\par
8663         m_reporter->testCaseEnded(TestCaseStats(testInfo,\par
8664                                   deltaTotals,\par
8665                                   std::string(),\par
8666                                   std::string(),\par
8667                                   {\cf17 false}));\par
8668         m_totals.testCases.failed++;\par
8669         testGroupEnded(std::string(), m_totals, 1, 1);\par
8670         m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, {\cf17 false}));\par
8671     \}\par
8672 \par
8673     {\cf18 bool} RunContext::lastAssertionPassed() \{\par
8674          {\cf19 return} m_lastAssertionPassed;\par
8675     \}\par
8676 \par
8677     {\cf18 void} RunContext::assertionPassed() \{\par
8678         m_lastAssertionPassed = {\cf17 true};\par
8679         ++m_totals.assertions.passed;\par
8680         resetAssertionInfo();\par
8681     \}\par
8682 \par
8683     {\cf18 bool} RunContext::aborting(){\cf17  const }\{\par
8684         {\cf19 return} m_totals.assertions.failed == {\cf17 static_cast<}std::size_t{\cf17 >}(m_config->abortAfter());\par
8685     \}\par
8686 \par
8687     {\cf18 void} RunContext::runCurrentTest(std::string & redirectedCout, std::string & redirectedCerr) \{\par
8688         {\cf17 auto} {\cf17 const}& testCaseInfo = m_activeTestCase->getTestCaseInfo();\par
8689         SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description);\par
8690         m_reporter->sectionStarting(testCaseSection);\par
8691         Counts prevAssertions = m_totals.assertions;\par
8692         {\cf18 double} duration = 0;\par
8693         m_shouldReportUnexpected = {\cf17 true};\par
8694         m_lastAssertionInfo = \{ {\cf22 "TEST_CASE"}_sr, testCaseInfo.lineInfo, StringRef(), ResultDisposition::Normal \};\par
8695 \par
8696         seedRng(*m_config);\par
8697 \par
8698         Timer timer;\par
8699         {\cf19 try} \{\par
8700             {\cf19 if} (m_reporter->getPreferences().shouldRedirectStdOut) \{\par
8701                 RedirectedStdOut redirectedStdOut;\par
8702                 RedirectedStdErr redirectedStdErr;\par
8703                 timer.start();\par
8704                 invokeActiveTestCase();\par
8705                 redirectedCout += redirectedStdOut.str();\par
8706                 redirectedCerr += redirectedStdErr.str();\par
8707 \par
8708             \} {\cf19 else} \{\par
8709                 timer.start();\par
8710                 invokeActiveTestCase();\par
8711             \}\par
8712             duration = timer.getElapsedSeconds();\par
8713         \} {\cf19 catch} (TestFailureException&) \{\par
8714             {\cf20 // This just means the test was aborted due to failure}\par
8715         \} {\cf19 catch} (...) \{\par
8716             {\cf20 // Under CATCH_CONFIG_FAST_COMPILE, unexpected exceptions under REQUIRE assertions}\par
8717             {\cf20 // are reported without translation at the point of origin.}\par
8718             {\cf19 if}( m_shouldReportUnexpected ) \{\par
8719                 AssertionReaction dummyReaction;\par
8720                 handleUnexpectedInflightException( m_lastAssertionInfo, translateActiveException(), dummyReaction );\par
8721             \}\par
8722         \}\par
8723         Counts assertions = m_totals.assertions - prevAssertions;\par
8724         {\cf18 bool} missingAssertions = testForMissingAssertions(assertions);\par
8725 \par
8726         m_testCaseTracker->close();\par
8727         handleUnfinishedSections();\par
8728         m_messages.clear();\par
8729 \par
8730         SectionStats testCaseSectionStats(testCaseSection, assertions, duration, missingAssertions);\par
8731         m_reporter->sectionEnded(testCaseSectionStats);\par
8732     \}\par
8733 \par
8734     {\cf18 void} RunContext::invokeActiveTestCase() \{\par
8735         FatalConditionHandler fatalConditionHandler; {\cf20 // Handle signals}\par
8736         m_activeTestCase->invoke();\par
8737         fatalConditionHandler.reset();\par
8738     \}\par
8739 \par
8740     {\cf18 void} RunContext::handleUnfinishedSections() \{\par
8741         {\cf20 // If sections ended prematurely due to an exception we stored their}\par
8742         {\cf20 // infos here so we can tear them down outside the unwind process.}\par
8743         {\cf19 for} ({\cf17 auto} it = m_unfinishedSections.rbegin(),\par
8744              itEnd = m_unfinishedSections.rend();\par
8745              it != itEnd;\par
8746              ++it)\par
8747             sectionEnded(*it);\par
8748         m_unfinishedSections.clear();\par
8749     \}\par
8750 \par
8751     {\cf18 void} RunContext::handleExpr(\par
8752         AssertionInfo {\cf17 const}& info,\par
8753         ITransientExpression {\cf17 const}& expr,\par
8754         AssertionReaction& reaction\par
8755     ) \{\par
8756         m_reporter->assertionStarting( info );\par
8757 \par
8758         {\cf18 bool} negated = isFalseTest( info.resultDisposition );\par
8759         {\cf18 bool} result = expr.getResult() != negated;\par
8760 \par
8761         {\cf19 if}( result ) \{\par
8762             {\cf19 if} (!m_includeSuccessfulResults) \{\par
8763                 assertionPassed();\par
8764             \}\par
8765             {\cf19 else} \{\par
8766                 reportExpr(info, ResultWas::Ok, &expr, negated);\par
8767             \}\par
8768         \}\par
8769         {\cf19 else} \{\par
8770             reportExpr(info, ResultWas::ExpressionFailed, &expr, negated );\par
8771             populateReaction( reaction );\par
8772         \}\par
8773     \}\par
8774     {\cf18 void} RunContext::reportExpr(\par
8775             AssertionInfo {\cf17 const} &info,\par
8776             ResultWas::OfType resultType,\par
8777             ITransientExpression {\cf17 const} *expr,\par
8778             {\cf18 bool} negated ) \{\par
8779 \par
8780         m_lastAssertionInfo = info;\par
8781         AssertionResultData data( resultType, LazyExpression( negated ) );\par
8782 \par
8783         AssertionResult assertionResult\{ info, data \};\par
8784         assertionResult.m_resultData.lazyExpression.m_transientExpression = expr;\par
8785 \par
8786         assertionEnded( assertionResult );\par
8787     \}\par
8788 \par
8789     {\cf18 void} RunContext::handleMessage(\par
8790             AssertionInfo {\cf17 const}& info,\par
8791             ResultWas::OfType resultType,\par
8792             StringRef {\cf17 const}& message,\par
8793             AssertionReaction& reaction\par
8794     ) \{\par
8795         m_reporter->assertionStarting( info );\par
8796 \par
8797         m_lastAssertionInfo = info;\par
8798 \par
8799         AssertionResultData data( resultType, LazyExpression( {\cf17 false} ) );\par
8800         data.message = message;\par
8801         AssertionResult assertionResult\{ m_lastAssertionInfo, data \};\par
8802         assertionEnded( assertionResult );\par
8803         {\cf19 if}( !assertionResult.isOk() )\par
8804             populateReaction( reaction );\par
8805     \}\par
8806     {\cf18 void} RunContext::handleUnexpectedExceptionNotThrown(\par
8807             AssertionInfo {\cf17 const}& info,\par
8808             AssertionReaction& reaction\par
8809     ) \{\par
8810         handleNonExpr(info, Catch::ResultWas::DidntThrowException, reaction);\par
8811     \}\par
8812 \par
8813     {\cf18 void} RunContext::handleUnexpectedInflightException(\par
8814             AssertionInfo {\cf17 const}& info,\par
8815             std::string {\cf17 const}& message,\par
8816             AssertionReaction& reaction\par
8817     ) \{\par
8818         m_lastAssertionInfo = info;\par
8819 \par
8820         AssertionResultData data( ResultWas::ThrewException, LazyExpression( {\cf17 false} ) );\par
8821         data.message = message;\par
8822         AssertionResult assertionResult\{ info, data \};\par
8823         assertionEnded( assertionResult );\par
8824         populateReaction( reaction );\par
8825     \}\par
8826 \par
8827     {\cf18 void} RunContext::populateReaction( AssertionReaction& reaction ) \{\par
8828         reaction.shouldDebugBreak = m_config->shouldDebugBreak();\par
8829         reaction.shouldThrow = aborting() || (m_lastAssertionInfo.resultDisposition & ResultDisposition::Normal);\par
8830     \}\par
8831 \par
8832     {\cf18 void} RunContext::handleIncomplete(\par
8833             AssertionInfo {\cf17 const}& info\par
8834     ) \{\par
8835         m_lastAssertionInfo = info;\par
8836 \par
8837         AssertionResultData data( ResultWas::ThrewException, LazyExpression( {\cf17 false} ) );\par
8838         data.message = {\cf22 "Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE"};\par
8839         AssertionResult assertionResult\{ info, data \};\par
8840         assertionEnded( assertionResult );\par
8841     \}\par
8842     {\cf18 void} RunContext::handleNonExpr(\par
8843             AssertionInfo {\cf17 const} &info,\par
8844             ResultWas::OfType resultType,\par
8845             AssertionReaction &reaction\par
8846     ) \{\par
8847         m_lastAssertionInfo = info;\par
8848 \par
8849         AssertionResultData data( resultType, LazyExpression( {\cf17 false} ) );\par
8850         AssertionResult assertionResult\{ info, data \};\par
8851         assertionEnded( assertionResult );\par
8852 \par
8853         {\cf19 if}( !assertionResult.isOk() )\par
8854             populateReaction( reaction );\par
8855     \}\par
8856 \par
8857     IResultCapture& getResultCapture() \{\par
8858         {\cf19 if} ({\cf17 auto}* capture = getCurrentContext().getResultCapture())\par
8859             {\cf19 return} *capture;\par
8860         {\cf19 else}\par
8861             CATCH_INTERNAL_ERROR({\cf22 "No result capture instance"});\par
8862     \}\par
8863 \}\par
8864 {\cf20 // end catch_run_context.cpp}\par
8865 {\cf20 // start catch_section.cpp}\par
8866 \par
8867 {\cf17 namespace }Catch \{\par
8868 \par
8869     Section::Section( SectionInfo {\cf17 const}& info )\par
8870     :   m_info( info ),\par
8871         m_sectionIncluded( getResultCapture().sectionStarted( m_info, m_assertions ) )\par
8872     \{\par
8873         m_timer.start();\par
8874     \}\par
8875 \par
8876     Section::~Section() \{\par
8877         {\cf19 if}( m_sectionIncluded ) \{\par
8878             SectionEndInfo endInfo( m_info, m_assertions, m_timer.getElapsedSeconds() );\par
8879             {\cf19 if}( uncaught_exceptions() )\par
8880                 getResultCapture().sectionEndedEarly( endInfo );\par
8881             {\cf19 else}\par
8882                 getResultCapture().sectionEnded( endInfo );\par
8883         \}\par
8884     \}\par
8885 \par
8886     {\cf20 // This indicates whether the section should be executed or not}\par
8887     Section::operator bool(){\cf17  const }\{\par
8888         {\cf19 return} m_sectionIncluded;\par
8889     \}\par
8890 \par
8891 \} {\cf20 // end namespace Catch}\par
8892 {\cf20 // end catch_section.cpp}\par
8893 {\cf20 // start catch_section_info.cpp}\par
8894 \par
8895 {\cf17 namespace }Catch \{\par
8896 \par
8897     SectionInfo::SectionInfo\par
8898         (   SourceLineInfo {\cf17 const}& _lineInfo,\par
8899             std::string {\cf17 const}& _name,\par
8900             std::string {\cf17 const}& _description )\par
8901     :   name( _name ),\par
8902         description( _description ),\par
8903         lineInfo( _lineInfo )\par
8904     \{\}\par
8905 \par
8906     SectionEndInfo::SectionEndInfo( SectionInfo {\cf17 const}& _sectionInfo, Counts {\cf17 const}& _prevAssertions, {\cf18 double} _durationInSeconds )\par
8907     : sectionInfo( _sectionInfo ), prevAssertions( _prevAssertions ), durationInSeconds( _durationInSeconds )\par
8908     \{\}\par
8909 \par
8910 \} {\cf20 // end namespace Catch}\par
8911 {\cf20 // end catch_section_info.cpp}\par
8912 {\cf20 // start catch_session.cpp}\par
8913 \par
8914 {\cf20 // start catch_session.h}\par
8915 \par
8916 {\cf21 #include <memory>}\par
8917 \par
8918 {\cf17 namespace }Catch \{\par
8919 \par
8920     {\cf17 class }Session : NonCopyable \{\par
8921     {\cf17 public}:\par
8922 \par
8923         Session();\par
8924         ~Session() {\cf17 override};\par
8925 \par
8926         {\cf18 void} showHelp() {\cf17 const};\par
8927         {\cf18 void} libIdentify();\par
8928 \par
8929         {\cf18 int} applyCommandLine( {\cf18 int} argc, {\cf18 char} {\cf17 const} * {\cf17 const} * argv );\par
8930 \par
8931         {\cf18 void} useConfigData( ConfigData {\cf17 const}& configData );\par
8932 \par
8933         {\cf18 int} run( {\cf18 int} argc, {\cf18 char}* argv[] );\par
8934 {\cf21     #if defined(CATCH_CONFIG_WCHAR) && defined(WIN32) && defined(UNICODE)}\par
8935         {\cf18 int} run( {\cf18 int} argc, {\cf18 wchar_t}* {\cf17 const} argv[] );\par
8936 {\cf21     #endif}\par
8937         {\cf18 int} run();\par
8938 \par
8939         clara::Parser {\cf17 const}& cli() {\cf17 const};\par
8940         {\cf18 void} cli( clara::Parser {\cf17 const}& newParser );\par
8941         ConfigData& configData();\par
8942         Config& config();\par
8943     {\cf17 private}:\par
8944         {\cf18 int} runInternal();\par
8945 \par
8946         clara::Parser m_cli;\par
8947         ConfigData m_configData;\par
8948         std::shared_ptr<Config> m_config;\par
8949         {\cf18 bool} m_startupExceptions = {\cf17 false};\par
8950     \};\par
8951 \par
8952 \} {\cf20 // end namespace Catch}\par
8953 \par
8954 {\cf20 // end catch_session.h}\par
8955 {\cf20 // start catch_version.h}\par
8956 \par
8957 {\cf21 #include <iosfwd>}\par
8958 \par
8959 {\cf17 namespace }Catch \{\par
8960 \par
8961     {\cf20 // Versioning information}\par
8962     {\cf17 struct }Version \{\par
8963         Version( Version {\cf17 const}& ) = {\cf17 delete};\par
8964         Version& operator=( Version {\cf17 const}& ) = {\cf17 delete};\par
8965         Version(    {\cf18 unsigned} {\cf18 int} _majorVersion,\par
8966                     {\cf18 unsigned} {\cf18 int} _minorVersion,\par
8967                     {\cf18 unsigned} {\cf18 int} _patchNumber,\par
8968                     {\cf18 char} {\cf17 const} * {\cf17 const} _branchName,\par
8969                     {\cf18 unsigned} {\cf18 int} _buildNumber );\par
8970 \par
8971         {\cf18 unsigned} {\cf18 int} {\cf17 const} majorVersion;\par
8972         {\cf18 unsigned} {\cf18 int} {\cf17 const} minorVersion;\par
8973         {\cf18 unsigned} {\cf18 int} {\cf17 const} patchNumber;\par
8974 \par
8975         {\cf20 // buildNumber is only used if branchName is not null}\par
8976         {\cf18 char} {\cf17 const} * {\cf17 const} branchName;\par
8977         {\cf18 unsigned} {\cf18 int} {\cf17 const} buildNumber;\par
8978 \par
8979         {\cf17 friend} std::ostream& operator << ( std::ostream& os, Version {\cf17 const}& version );\par
8980     \};\par
8981 \par
8982     Version {\cf17 const}& libraryVersion();\par
8983 \}\par
8984 \par
8985 {\cf20 // end catch_version.h}\par
8986 {\cf21 #include <cstdlib>}\par
8987 {\cf21 #include <iomanip>}\par
8988 \par
8989 {\cf17 namespace }Catch \{\par
8990 \par
8991     {\cf17 namespace }\{\par
8992         {\cf17 const} {\cf18 int} MaxExitCode = 255;\par
8993 \par
8994         IStreamingReporterPtr createReporter(std::string {\cf17 const}& reporterName, IConfigPtr {\cf17 const}& config) \{\par
8995             {\cf17 auto} reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, config);\par
8996             CATCH_ENFORCE(reporter, {\cf22 "No reporter registered with name: '"} << reporterName << {\cf22 "'"});\par
8997 \par
8998             {\cf19 return} reporter;\par
8999         \}\par
9000 \par
9001 {\cf21 #ifndef CATCH_CONFIG_DEFAULT_REPORTER}\par
9002 {\cf21 #define CATCH_CONFIG_DEFAULT_REPORTER "console"}\par
9003 {\cf21 #endif}\par
9004 \par
9005         IStreamingReporterPtr makeReporter(std::shared_ptr<Config> {\cf17 const}& config) \{\par
9006             {\cf17 auto} {\cf17 const}& reporterNames = config->getReporterNames();\par
9007             {\cf19 if} (reporterNames.empty())\par
9008                 {\cf19 return} createReporter(CATCH_CONFIG_DEFAULT_REPORTER, config);\par
9009 \par
9010             IStreamingReporterPtr reporter;\par
9011             {\cf19 for} ({\cf17 auto} {\cf17 const}& name : reporterNames)\par
9012                 addReporter(reporter, createReporter(name, config));\par
9013             {\cf19 return} reporter;\par
9014         \}\par
9015 \par
9016 {\cf21 #undef CATCH_CONFIG_DEFAULT_REPORTER}\par
9017 \par
9018         {\cf18 void} addListeners(IStreamingReporterPtr& reporters, IConfigPtr {\cf17 const}& config) \{\par
9019             {\cf17 auto} {\cf17 const}& listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();\par
9020             {\cf19 for} ({\cf17 auto} {\cf17 const}& listener : listeners)\par
9021                 addReporter(reporters, listener->create(Catch::ReporterConfig(config)));\par
9022         \}\par
9023 \par
9024         Catch::Totals runTests(std::shared_ptr<Config> {\cf17 const}& config) \{\par
9025             IStreamingReporterPtr reporter = makeReporter(config);\par
9026             addListeners(reporter, config);\par
9027 \par
9028             RunContext context(config, std::move(reporter));\par
9029 \par
9030             Totals totals;\par
9031 \par
9032             context.testGroupStarting(config->name(), 1, 1);\par
9033 \par
9034             TestSpec testSpec = config->testSpec();\par
9035 \par
9036             {\cf17 auto} {\cf17 const}& allTestCases = getAllTestCasesSorted(*config);\par
9037             {\cf19 for} ({\cf17 auto} {\cf17 const}& testCase : allTestCases) \{\par
9038                 {\cf19 if} (!context.aborting() && matchTest(testCase, testSpec, *config))\par
9039                     totals += context.runTest(testCase);\par
9040                 {\cf19 else}\par
9041                     context.reporter().skipTest(testCase);\par
9042             \}\par
9043 \par
9044             {\cf19 if} (config->warnAboutNoTests() && totals.testCases.total() == 0) \{\par
9045                 ReusableStringStream testConfig;\par
9046 \par
9047                 {\cf18 bool} first = {\cf17 true};\par
9048                 {\cf19 for} ({\cf17 const} {\cf17 auto}& input : config->getTestsOrTags()) \{\par
9049                     {\cf19 if} (!first) \{ testConfig << {\cf23 ' '}; \}\par
9050                     first = {\cf17 false};\par
9051                     testConfig << input;\par
9052                 \}\par
9053 \par
9054                 context.reporter().noMatchingTestCases(testConfig.str());\par
9055                 totals.error = -1;\par
9056             \}\par
9057 \par
9058             context.testGroupEnded(config->name(), totals, 1, 1);\par
9059             {\cf19 return} totals;\par
9060         \}\par
9061 \par
9062         {\cf18 void} applyFilenamesAsTags(Catch::IConfig {\cf17 const}& config) \{\par
9063             {\cf17 auto}& tests = {\cf17 const_cast<}std::vector<TestCase>&{\cf17 >}(getAllTestCasesSorted(config));\par
9064             {\cf19 for} ({\cf17 auto}& testCase : tests) \{\par
9065                 {\cf17 auto} tags = testCase.tags;\par
9066 \par
9067                 std::string filename = testCase.lineInfo.file;\par
9068                 {\cf17 auto} lastSlash = filename.find_last_of({\cf22 "\\\\/"});\par
9069                 {\cf19 if} (lastSlash != std::string::npos) \{\par
9070                     filename.erase(0, lastSlash);\par
9071                     filename[0] = {\cf23 '#'};\par
9072                 \}\par
9073 \par
9074                 {\cf17 auto} lastDot = filename.find_last_of({\cf23 '.'});\par
9075                 {\cf19 if} (lastDot != std::string::npos) \{\par
9076                     filename.erase(lastDot);\par
9077                 \}\par
9078 \par
9079                 tags.push_back(std::move(filename));\par
9080                 setTags(testCase, tags);\par
9081             \}\par
9082         \}\par
9083 \par
9084     \} {\cf20 // anon namespace}\par
9085 \par
9086     Session::Session() \{\par
9087         {\cf17 static} {\cf18 bool} alreadyInstantiated = {\cf17 false};\par
9088         {\cf19 if}( alreadyInstantiated ) \{\par
9089             {\cf19 try}         \{ CATCH_INTERNAL_ERROR( {\cf22 "Only one instance of Catch::Session can ever be used"} ); \}\par
9090             {\cf19 catch}(...)  \{ getMutableRegistryHub().registerStartupException(); \}\par
9091         \}\par
9092 \par
9093         {\cf17 const} {\cf17 auto}& exceptions = getRegistryHub().getStartupExceptionRegistry().getExceptions();\par
9094         {\cf19 if} ( !exceptions.empty() ) \{\par
9095             m_startupExceptions = {\cf17 true};\par
9096             Colour colourGuard( Colour::Red );\par
9097             Catch::cerr() << {\cf22 "Errors occurred during startup!"} << {\cf23 '\\n'};\par
9098             {\cf20 // iterate over all exceptions and notify user}\par
9099             {\cf19 for} ( {\cf17 const} {\cf17 auto}& ex_ptr : exceptions ) \{\par
9100                 {\cf19 try} \{\par
9101                     std::rethrow_exception(ex_ptr);\par
9102                 \} {\cf19 catch} ( std::exception {\cf17 const}& ex ) \{\par
9103                     Catch::cerr() << Column( ex.what() ).indent(2) << {\cf23 '\\n'};\par
9104                 \}\par
9105             \}\par
9106         \}\par
9107 \par
9108         alreadyInstantiated = {\cf17 true};\par
9109         m_cli = makeCommandLineParser( m_configData );\par
9110     \}\par
9111     Session::~Session() \{\par
9112         Catch::cleanUp();\par
9113     \}\par
9114 \par
9115     {\cf18 void} Session::showHelp(){\cf17  const }\{\par
9116         Catch::cout()\par
9117                 << {\cf22 "\\nCatch v"} << libraryVersion() << {\cf22 "\\n"}\par
9118                 << m_cli << std::endl\par
9119                 << {\cf22 "For more detailed usage please see the project docs\\n"} << std::endl;\par
9120     \}\par
9121     {\cf18 void} Session::libIdentify() \{\par
9122         Catch::cout()\par
9123                 << std::left << std::setw(16) << {\cf22 "description: "} << {\cf22 "A Catch test executable\\n"}\par
9124                 << std::left << std::setw(16) << {\cf22 "category: "} << {\cf22 "testframework\\n"}\par
9125                 << std::left << std::setw(16) << {\cf22 "framework: "} << {\cf22 "Catch Test\\n"}\par
9126                 << std::left << std::setw(16) << {\cf22 "version: "} << libraryVersion() << std::endl;\par
9127     \}\par
9128 \par
9129     {\cf18 int} Session::applyCommandLine( {\cf18 int} argc, {\cf18 char} {\cf17 const} * {\cf17 const} * argv ) \{\par
9130         {\cf19 if}( m_startupExceptions )\par
9131             {\cf19 return} 1;\par
9132 \par
9133         {\cf17 auto} result = m_cli.parse( clara::Args( argc, argv ) );\par
9134         {\cf19 if}( !result ) \{\par
9135             Catch::cerr()\par
9136                 << Colour( Colour::Red )\par
9137                 << {\cf22 "\\nError(s) in input:\\n"}\par
9138                 << Column( result.errorMessage() ).indent( 2 )\par
9139                 << {\cf22 "\\n\\n"};\par
9140             Catch::cerr() << {\cf22 "Run with -? for usage\\n"} << std::endl;\par
9141             {\cf19 return} MaxExitCode;\par
9142         \}\par
9143 \par
9144         {\cf19 if}( m_configData.showHelp )\par
9145             showHelp();\par
9146         {\cf19 if}( m_configData.libIdentify )\par
9147             libIdentify();\par
9148         m_config.reset();\par
9149         {\cf19 return} 0;\par
9150     \}\par
9151 \par
9152     {\cf18 void} Session::useConfigData( ConfigData {\cf17 const}& configData ) \{\par
9153         m_configData = configData;\par
9154         m_config.reset();\par
9155     \}\par
9156 \par
9157     {\cf18 int} Session::run( {\cf18 int} argc, {\cf18 char}* argv[] ) \{\par
9158         {\cf19 if}( m_startupExceptions )\par
9159             {\cf19 return} 1;\par
9160         {\cf18 int} returnCode = applyCommandLine( argc, argv );\par
9161         {\cf19 if}( returnCode == 0 )\par
9162             returnCode = run();\par
9163         {\cf19 return} returnCode;\par
9164     \}\par
9165 \par
9166 {\cf21 #if defined(CATCH_CONFIG_WCHAR) && defined(WIN32) && defined(UNICODE)}\par
9167     {\cf18 int} Session::run( {\cf18 int} argc, {\cf18 wchar_t}* {\cf17 const} argv[] ) \{\par
9168 \par
9169         {\cf18 char} **utf8Argv = {\cf17 new} {\cf18 char} *[ argc ];\par
9170 \par
9171         {\cf19 for} ( {\cf18 int} i = 0; i < argc; ++i ) \{\par
9172             {\cf18 int} bufSize = WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, NULL, 0, NULL, NULL );\par
9173 \par
9174             utf8Argv[ i ] = {\cf17 new} {\cf18 char}[ bufSize ];\par
9175 \par
9176             WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, utf8Argv[i], bufSize, NULL, NULL );\par
9177         \}\par
9178 \par
9179         {\cf18 int} returnCode = run( argc, utf8Argv );\par
9180 \par
9181         {\cf19 for} ( {\cf18 int} i = 0; i < argc; ++i )\par
9182             delete [] utf8Argv[ i ];\par
9183 \par
9184         {\cf17 delete} [] utf8Argv;\par
9185 \par
9186         {\cf19 return} returnCode;\par
9187     \}\par
9188 {\cf21 #endif}\par
9189     {\cf18 int} Session::run() \{\par
9190         {\cf19 if}( ( m_configData.waitForKeypress & WaitForKeypress::BeforeStart ) != 0 ) \{\par
9191             Catch::cout() << {\cf22 "...waiting for enter/ return before starting"} << std::endl;\par
9192             {\cf17 static_cast<}{\cf18 void}{\cf17 >}(std::getchar());\par
9193         \}\par
9194         {\cf18 int} exitCode = runInternal();\par
9195         {\cf19 if}( ( m_configData.waitForKeypress & WaitForKeypress::BeforeExit ) != 0 ) \{\par
9196             Catch::cout() << {\cf22 "...waiting for enter/ return before exiting, with code: "} << exitCode << std::endl;\par
9197             {\cf17 static_cast<}{\cf18 void}{\cf17 >}(std::getchar());\par
9198         \}\par
9199         {\cf19 return} exitCode;\par
9200     \}\par
9201 \par
9202     clara::Parser {\cf17 const}& Session::cli(){\cf17  const }\{\par
9203         {\cf19 return} m_cli;\par
9204     \}\par
9205     {\cf18 void} Session::cli( clara::Parser {\cf17 const}& newParser ) \{\par
9206         m_cli = newParser;\par
9207     \}\par
9208     ConfigData& Session::configData() \{\par
9209         {\cf19 return} m_configData;\par
9210     \}\par
9211     Config& Session::config() \{\par
9212         {\cf19 if}( !m_config )\par
9213             m_config = std::make_shared<Config>( m_configData );\par
9214         {\cf19 return} *m_config;\par
9215     \}\par
9216 \par
9217     {\cf18 int} Session::runInternal() \{\par
9218         {\cf19 if}( m_startupExceptions )\par
9219             {\cf19 return} 1;\par
9220 \par
9221         {\cf19 if}( m_configData.showHelp || m_configData.libIdentify )\par
9222             {\cf19 return} 0;\par
9223 \par
9224         {\cf19 try}\par
9225         \{\par
9226             config(); {\cf20 // Force config to be constructed}\par
9227 \par
9228             seedRng( *m_config );\par
9229 \par
9230             {\cf19 if}( m_configData.filenamesAsTags )\par
9231                 applyFilenamesAsTags( *m_config );\par
9232 \par
9233             {\cf20 // Handle list request}\par
9234             {\cf19 if}( Option<std::size_t> listed = list( config() ) )\par
9235                 {\cf19 return} {\cf17 static_cast<}{\cf18 int}{\cf17 >}( *listed );\par
9236 \par
9237             {\cf17 auto} totals = runTests( m_config );\par
9238             {\cf20 // Note that on unices only the lower 8 bits are usually used, clamping}\par
9239             {\cf20 // the return value to 255 prevents false negative when some multiple}\par
9240             {\cf20 // of 256 tests has failed}\par
9241             {\cf19 return} (std::min) (MaxExitCode, (std::max) (totals.error, {\cf17 static_cast<}{\cf18 int}{\cf17 >}(totals.assertions.failed)));\par
9242         \}\par
9243         {\cf19 catch}( std::exception& ex ) \{\par
9244             Catch::cerr() << ex.what() << std::endl;\par
9245             {\cf19 return} MaxExitCode;\par
9246         \}\par
9247     \}\par
9248 \par
9249 \} {\cf20 // end namespace Catch}\par
9250 {\cf20 // end catch_session.cpp}\par
9251 {\cf20 // start catch_startup_exception_registry.cpp}\par
9252 \par
9253 {\cf17 namespace }Catch \{\par
9254     {\cf18 void} StartupExceptionRegistry::add( std::exception_ptr {\cf17 const}& exception ) {\cf17 noexcept} \{\par
9255         {\cf19 try} \{\par
9256             m_exceptions.push_back(exception);\par
9257         \}\par
9258         {\cf19 catch}(...) \{\par
9259             {\cf20 // If we run out of memory during start-up there's really not a lot more we can do about it}\par
9260             std::terminate();\par
9261         \}\par
9262     \}\par
9263 \par
9264     std::vector<std::exception_ptr> {\cf17 const}& StartupExceptionRegistry::getExceptions() const noexcept \{\par
9265         {\cf19 return} m_exceptions;\par
9266     \}\par
9267 \par
9268 \} {\cf20 // end namespace Catch}\par
9269 {\cf20 // end catch_startup_exception_registry.cpp}\par
9270 {\cf20 // start catch_stream.cpp}\par
9271 \par
9272 {\cf21 #include <cstdio>}\par
9273 {\cf21 #include <iostream>}\par
9274 {\cf21 #include <fstream>}\par
9275 {\cf21 #include <sstream>}\par
9276 {\cf21 #include <vector>}\par
9277 {\cf21 #include <memory>}\par
9278 \par
9279 {\cf21 #if defined(__clang__)}\par
9280 {\cf21 #    pragma clang diagnostic push}\par
9281 {\cf21 #    pragma clang diagnostic ignored "-Wexit-time-destructors"}\par
9282 {\cf21 #endif}\par
9283 \par
9284 {\cf17 namespace }Catch \{\par
9285 \par
9286     Catch::IStream::~IStream() = {\cf19 default};\par
9287 \par
9288     {\cf17 namespace }detail \{ {\cf17 namespace }\{\par
9289         {\cf17 template}<{\cf17 typename} WriterF, std::{\cf18 size_t} bufferSize=256>\par
9290         {\cf17 class }StreamBufImpl : {\cf17 public} std::streambuf \{\par
9291             {\cf18 char} data[bufferSize];\par
9292             WriterF m_writer;\par
9293 \par
9294         {\cf17 public}:\par
9295             StreamBufImpl() \{\par
9296                 setp( data, data + {\cf17 sizeof}(data) );\par
9297             \}\par
9298 \par
9299             ~StreamBufImpl() noexcept \{\par
9300                 StreamBufImpl::sync();\par
9301             \}\par
9302 \par
9303         {\cf17 private}:\par
9304             {\cf18 int} overflow( {\cf18 int} c ){\cf17  override }\{\par
9305                 sync();\par
9306 \par
9307                 {\cf19 if}( c != EOF ) \{\par
9308                     {\cf19 if}( pbase() == epptr() )\par
9309                         m_writer( std::string( 1, {\cf17 static_cast<}{\cf18 char}{\cf17 >}( c ) ) );\par
9310                     {\cf19 else}\par
9311                         sputc( {\cf17 static_cast<}{\cf18 char}{\cf17 >}( c ) );\par
9312                 \}\par
9313                 {\cf19 return} 0;\par
9314             \}\par
9315 \par
9316             {\cf18 int} sync(){\cf17  override }\{\par
9317                 {\cf19 if}( pbase() != pptr() ) \{\par
9318                     m_writer( std::string( pbase(), {\cf17 static_cast<}std::string::size_type{\cf17 >}( pptr() - pbase() ) ) );\par
9319                     setp( pbase(), epptr() );\par
9320                 \}\par
9321                 {\cf19 return} 0;\par
9322             \}\par
9323         \};\par
9324 \par
9326 \par
9327         {\cf17 struct }OutputDebugWriter \{\par
9328 \par
9329             {\cf18 void} operator()( std::string {\cf17 const}&str ) \{\par
9330                 writeToDebugConsole( str );\par
9331             \}\par
9332         \};\par
9333 \par
9335 \par
9336         {\cf17 class }FileStream : {\cf17 public} IStream \{\par
9337             {\cf17 mutable} std::ofstream m_ofs;\par
9338         {\cf17 public}:\par
9339             FileStream( StringRef filename ) \{\par
9340                 m_ofs.open( filename.c_str() );\par
9341                 CATCH_ENFORCE( !m_ofs.fail(), {\cf22 "Unable to open file: '"} << filename << {\cf22 "'"} );\par
9342             \}\par
9343             ~FileStream() {\cf17 override} = {\cf19 default};\par
9344         {\cf17 public}: {\cf20 // IStream}\par
9345             std::ostream& stream(){\cf17  const override }\{\par
9346                 {\cf19 return} m_ofs;\par
9347             \}\par
9348         \};\par
9349 \par
9351 \par
9352         {\cf17 class }CoutStream : {\cf17 public} IStream \{\par
9353             {\cf17 mutable} std::ostream m_os;\par
9354         {\cf17 public}:\par
9355             {\cf20 // Store the streambuf from cout up-front because}\par
9356             {\cf20 // cout may get redirected when running tests}\par
9357             CoutStream() : m_os( Catch::cout().rdbuf() ) \{\}\par
9358             ~CoutStream() {\cf17 override} = {\cf19 default};\par
9359 \par
9360         {\cf17 public}: {\cf20 // IStream}\par
9361             std::ostream& stream(){\cf17  const override }\{ {\cf19 return} m_os; \}\par
9362         \};\par
9363 \par
9365 \par
9366         {\cf17 class }DebugOutStream : {\cf17 public} IStream \{\par
9367             std::unique_ptr<StreamBufImpl<OutputDebugWriter>> m_streamBuf;\par
9368             {\cf17 mutable} std::ostream m_os;\par
9369         {\cf17 public}:\par
9370             DebugOutStream()\par
9371             :   m_streamBuf( new StreamBufImpl<OutputDebugWriter>() ),\par
9372                 m_os( m_streamBuf.get() )\par
9373             \{\}\par
9374 \par
9375             ~DebugOutStream() {\cf17 override} = {\cf19 default};\par
9376 \par
9377         {\cf17 public}: {\cf20 // IStream}\par
9378             std::ostream& stream(){\cf17  const override }\{ {\cf19 return} m_os; \}\par
9379         \};\par
9380 \par
9381     \}\} {\cf20 // namespace anon::detail}\par
9382 \par
9384 \par
9385     {\cf17 auto} makeStream( StringRef {\cf17 const} &filename ) -> IStream {\cf17 const}* \{\par
9386         {\cf19 if}( filename.empty() )\par
9387             {\cf19 return} {\cf17 new} detail::CoutStream();\par
9388         {\cf19 else} {\cf19 if}( filename[0] == {\cf23 '%'} ) \{\par
9389             {\cf19 if}( filename == {\cf22 "%debug"} )\par
9390                 {\cf19 return} {\cf17 new} detail::DebugOutStream();\par
9391             {\cf19 else}\par
9392                 CATCH_ERROR( {\cf22 "Unrecognised stream: '"} << filename << {\cf22 "'"} );\par
9393         \}\par
9394         {\cf19 else}\par
9395             {\cf19 return} {\cf17 new} detail::FileStream( filename );\par
9396     \}\par
9397 \par
9398     {\cf20 // This class encapsulates the idea of a pool of ostringstreams that can be reused.}\par
9399     {\cf17 struct }StringStreams \{\par
9400         std::vector<std::unique_ptr<std::ostringstream>> m_streams;\par
9401         std::vector<std::size_t> m_unused;\par
9402         std::ostringstream m_referenceStream; {\cf20 // Used for copy state/ flags from}\par
9403         {\cf17 static} StringStreams* s_instance;\par
9404 \par
9405         {\cf17 auto} add() -> std::size_t \{\par
9406             {\cf19 if}( m_unused.empty() ) \{\par
9407                 m_streams.push_back( std::unique_ptr<std::ostringstream>( {\cf17 new} std::ostringstream ) );\par
9408                 {\cf19 return} m_streams.size()-1;\par
9409             \}\par
9410             {\cf19 else} \{\par
9411                 {\cf17 auto} index = m_unused.back();\par
9412                 m_unused.pop_back();\par
9413                 {\cf19 return} index;\par
9414             \}\par
9415         \}\par
9416 \par
9417         {\cf18 void} release( std::size_t index ) \{\par
9418             m_streams[index]->copyfmt( m_referenceStream ); {\cf20 // Restore initial flags and other state}\par
9419             m_unused.push_back(index);\par
9420         \}\par
9421 \par
9422         {\cf20 // !TBD: put in TLS}\par
9423         {\cf17 static} {\cf17 auto} instance() -> StringStreams& \{\par
9424             {\cf19 if}( !s_instance )\par
9425                 s_instance = {\cf17 new} StringStreams();\par
9426             {\cf19 return} *s_instance;\par
9427         \}\par
9428         {\cf17 static} {\cf18 void} cleanup() \{\par
9429             {\cf17 delete} s_instance;\par
9430             s_instance = {\cf17 nullptr};\par
9431         \}\par
9432     \};\par
9433 \par
9434     StringStreams* StringStreams::s_instance = {\cf17 nullptr};\par
9435 \par
9436     {\cf18 void} ReusableStringStream::cleanup() \{\par
9437         StringStreams::cleanup();\par
9438     \}\par
9439 \par
9440     ReusableStringStream::ReusableStringStream()\par
9441     :   m_index( StringStreams::instance().add() ),\par
9442         m_oss( StringStreams::instance().m_streams[m_index].get() )\par
9443     \{\}\par
9444 \par
9445     ReusableStringStream::~ReusableStringStream() \{\par
9446         {\cf17 static_cast<}std::ostringstream*{\cf17 >}( m_oss )->str({\cf22 ""});\par
9447         m_oss->clear();\par
9448         StringStreams::instance().release( m_index );\par
9449     \}\par
9450 \par
9451     {\cf17 auto} ReusableStringStream::str() const -> std::{\cf18 string} \{\par
9452         {\cf19 return} {\cf17 static_cast<}std::ostringstream*{\cf17 >}( m_oss )->str();\par
9453     \}\par
9454 \par
9456 \par
9457 {\cf21 #ifndef CATCH_CONFIG_NOSTDOUT }{\cf20 // If you #define this you must implement these functions}\par
9458     std::ostream& cout() \{ {\cf19 return} std::cout; \}\par
9459     std::ostream& cerr() \{ {\cf19 return} std::cerr; \}\par
9460     std::ostream& clog() \{ {\cf19 return} std::clog; \}\par
9461 {\cf21 #endif}\par
9462 \}\par
9463 \par
9464 {\cf21 #if defined(__clang__)}\par
9465 {\cf21 #    pragma clang diagnostic pop}\par
9466 {\cf21 #endif}\par
9467 {\cf20 // end catch_stream.cpp}\par
9468 {\cf20 // start catch_string_manip.cpp}\par
9469 \par
9470 {\cf21 #include <algorithm>}\par
9471 {\cf21 #include <ostream>}\par
9472 {\cf21 #include <cstring>}\par
9473 {\cf21 #include <cctype>}\par
9474 \par
9475 {\cf17 namespace }Catch \{\par
9476 \par
9477     {\cf18 bool} startsWith( std::string {\cf17 const}& s, std::string {\cf17 const}& prefix ) \{\par
9478         {\cf19 return} s.size() >= prefix.size() && std::equal(prefix.begin(), prefix.end(), s.begin());\par
9479     \}\par
9480     {\cf18 bool} startsWith( std::string {\cf17 const}& s, {\cf18 char} prefix ) \{\par
9481         {\cf19 return} !s.empty() && s[0] == prefix;\par
9482     \}\par
9483     {\cf18 bool} endsWith( std::string {\cf17 const}& s, std::string {\cf17 const}& suffix ) \{\par
9484         {\cf19 return} s.size() >= suffix.size() && std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());\par
9485     \}\par
9486     {\cf18 bool} endsWith( std::string {\cf17 const}& s, {\cf18 char} suffix ) \{\par
9487         {\cf19 return} !s.empty() && s[s.size()-1] == suffix;\par
9488     \}\par
9489     {\cf18 bool} contains( std::string {\cf17 const}& s, std::string {\cf17 const}& infix ) \{\par
9490         {\cf19 return} s.find( infix ) != std::string::npos;\par
9491     \}\par
9492     {\cf18 char} toLowerCh({\cf18 char} c) \{\par
9493         {\cf19 return} {\cf17 static_cast<}{\cf18 char}{\cf17 >}( std::tolower( c ) );\par
9494     \}\par
9495     {\cf18 void} toLowerInPlace( std::string& s ) \{\par
9496         std::transform( s.begin(), s.end(), s.begin(), toLowerCh );\par
9497     \}\par
9498     std::string toLower( std::string {\cf17 const}& s ) \{\par
9499         std::string lc = s;\par
9500         toLowerInPlace( lc );\par
9501         {\cf19 return} lc;\par
9502     \}\par
9503     std::string trim( std::string {\cf17 const}& str ) \{\par
9504         {\cf17 static} {\cf18 char} {\cf17 const}* whitespaceChars = {\cf22 "\\n\\r\\t "};\par
9505         std::string::size_type start = str.find_first_not_of( whitespaceChars );\par
9506         std::string::size_type end = str.find_last_not_of( whitespaceChars );\par
9507 \par
9508         {\cf19 return} start != std::string::npos ? str.substr( start, 1+end-start ) : std::string();\par
9509     \}\par
9510 \par
9511     {\cf18 bool} replaceInPlace( std::string& str, std::string {\cf17 const}& replaceThis, std::string {\cf17 const}& withThis ) \{\par
9512         {\cf18 bool} replaced = {\cf17 false};\par
9513         std::size_t i = str.find( replaceThis );\par
9514         {\cf19 while}( i != std::string::npos ) \{\par
9515             replaced = {\cf17 true};\par
9516             str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );\par
9517             {\cf19 if}( i < str.size()-withThis.size() )\par
9518                 i = str.find( replaceThis, i+withThis.size() );\par
9519             {\cf19 else}\par
9520                 i = std::string::npos;\par
9521         \}\par
9522         {\cf19 return} replaced;\par
9523     \}\par
9524 \par
9525     pluralise::pluralise( std::size_t count, std::string {\cf17 const}& label )\par
9526     :   m_count( count ),\par
9527         m_label( label )\par
9528     \{\}\par
9529 \par
9530     std::ostream& operator << ( std::ostream& os, pluralise {\cf17 const}& pluraliser ) \{\par
9531         os << pluraliser.m_count << {\cf23 ' '} << pluraliser.m_label;\par
9532         {\cf19 if}( pluraliser.m_count != 1 )\par
9533             os << {\cf23 's'};\par
9534         {\cf19 return} os;\par
9535     \}\par
9536 \par
9537 \}\par
9538 {\cf20 // end catch_string_manip.cpp}\par
9539 {\cf20 // start catch_stringref.cpp}\par
9540 \par
9541 {\cf21 #if defined(__clang__)}\par
9542 {\cf21 #    pragma clang diagnostic push}\par
9543 {\cf21 #    pragma clang diagnostic ignored "-Wexit-time-destructors"}\par
9544 {\cf21 #endif}\par
9545 \par
9546 {\cf21 #include <ostream>}\par
9547 {\cf21 #include <cstring>}\par
9548 {\cf21 #include <cstdint>}\par
9549 \par
9550 {\cf17 namespace }\{\par
9551     {\cf17 const} uint32_t byte_2_lead = 0xC0;\par
9552     {\cf17 const} uint32_t byte_3_lead = 0xE0;\par
9553     {\cf17 const} uint32_t byte_4_lead = 0xF0;\par
9554 \}\par
9555 \par
9556 {\cf17 namespace }Catch \{\par
9557     StringRef::StringRef( {\cf18 char} {\cf17 const}* rawChars ) noexcept\par
9558     : StringRef( rawChars, {\cf17 static_cast<}StringRef::size_type{\cf17 >}(std::strlen(rawChars) ) )\par
9559     \{\}\par
9560 \par
9561     StringRef::operator std::string(){\cf17  const }\{\par
9562         {\cf19 return} std::string( m_start, m_size );\par
9563     \}\par
9564 \par
9565     {\cf18 void} StringRef::swap( StringRef& other ) {\cf17 noexcept} \{\par
9566         std::swap( m_start, other.m_start );\par
9567         std::swap( m_size, other.m_size );\par
9568         std::swap( m_data, other.m_data );\par
9569     \}\par
9570 \par
9571     {\cf17 auto} StringRef::c_str() const -> {\cf18 char} const* \{\par
9572         {\cf19 if}( isSubstring() )\par
9573            {\cf17 const_cast<}StringRef*{\cf17 >}( this )->takeOwnership();\par
9574         {\cf19 return} m_start;\par
9575     \}\par
9576     {\cf17 auto} StringRef::currentData() const noexcept -> {\cf18 char} const* \{\par
9577         {\cf19 return} m_start;\par
9578     \}\par
9579 \par
9580     {\cf17 auto} StringRef::isOwned() const noexcept -> {\cf18 bool} \{\par
9581         {\cf19 return} m_data != {\cf17 nullptr};\par
9582     \}\par
9583     {\cf17 auto} StringRef::isSubstring() const noexcept -> {\cf18 bool} \{\par
9584         {\cf19 return} m_start[m_size] != {\cf23 '\\0'};\par
9585     \}\par
9586 \par
9587     {\cf18 void} StringRef::takeOwnership() \{\par
9588         {\cf19 if}( !isOwned() ) \{\par
9589             m_data = {\cf17 new} {\cf18 char}[m_size+1];\par
9590             memcpy( m_data, m_start, m_size );\par
9591             m_data[m_size] = {\cf23 '\\0'};\par
9592             m_start = m_data;\par
9593         \}\par
9594     \}\par
9595     {\cf17 auto} StringRef::substr( size_type start, size_type size ) {\cf17 const} {\cf17 noexcept} -> StringRef \{\par
9596         {\cf19 if}( start < m_size )\par
9597             {\cf19 return} StringRef( m_start+start, size );\par
9598         {\cf19 else}\par
9599             {\cf19 return} StringRef();\par
9600     \}\par
9601     {\cf17 auto} StringRef::operator == ( StringRef {\cf17 const}& other ) {\cf17 const} {\cf17 noexcept} -> {\cf18 bool} \{\par
9602         {\cf19 return}\par
9603             size() == other.size() &&\par
9604             (std::strncmp( m_start, other.m_start, size() ) == 0);\par
9605     \}\par
9606     {\cf17 auto} StringRef::operator != ( StringRef {\cf17 const}& other ) {\cf17 const} {\cf17 noexcept} -> {\cf18 bool} \{\par
9607         {\cf19 return} !operator==( other );\par
9608     \}\par
9609 \par
9610     {\cf17 auto} StringRef::operator[](size_type index) {\cf17 const} {\cf17 noexcept} -> {\cf18 char} \{\par
9611         {\cf19 return} m_start[index];\par
9612     \}\par
9613 \par
9614     {\cf17 auto} StringRef::numberOfCharacters() const noexcept -> size_type \{\par
9615         size_type noChars = m_size;\par
9616         {\cf20 // Make adjustments for uft encodings}\par
9617         {\cf19 for}( size_type i=0; i < m_size; ++i ) \{\par
9618             {\cf18 char} c = m_start[i];\par
9619             {\cf19 if}( ( c & byte_2_lead ) == byte_2_lead ) \{\par
9620                 noChars--;\par
9621                 {\cf19 if} (( c & byte_3_lead ) == byte_3_lead )\par
9622                     noChars--;\par
9623                 {\cf19 if}( ( c & byte_4_lead ) == byte_4_lead )\par
9624                     noChars--;\par
9625             \}\par
9626         \}\par
9627         {\cf19 return} noChars;\par
9628     \}\par
9629 \par
9630     {\cf17 auto} operator + ( StringRef {\cf17 const}& lhs, StringRef {\cf17 const}& rhs ) -> std::string \{\par
9631         std::string str;\par
9632         str.reserve( lhs.size() + rhs.size() );\par
9633         str += lhs;\par
9634         str += rhs;\par
9635         {\cf19 return} str;\par
9636     \}\par
9637     {\cf17 auto} operator + ( StringRef {\cf17 const}& lhs, {\cf17 const} {\cf18 char}* rhs ) -> std::string \{\par
9638         {\cf19 return} std::string( lhs ) + std::string( rhs );\par
9639     \}\par
9640     {\cf17 auto} operator + ( {\cf18 char} {\cf17 const}* lhs, StringRef {\cf17 const}& rhs ) -> std::string \{\par
9641         {\cf19 return} std::string( lhs ) + std::string( rhs );\par
9642     \}\par
9643 \par
9644     {\cf17 auto} operator << ( std::ostream& os, StringRef {\cf17 const}& str ) -> std::ostream& \{\par
9645         {\cf19 return} os.write(str.currentData(), str.size());\par
9646     \}\par
9647 \par
9648     {\cf17 auto} operator+=( std::string& lhs, StringRef {\cf17 const}& rhs ) -> std::string& \{\par
9649         lhs.append(rhs.currentData(), rhs.size());\par
9650         {\cf19 return} lhs;\par
9651     \}\par
9652 \par
9653 \} {\cf20 // namespace Catch}\par
9654 \par
9655 {\cf21 #if defined(__clang__)}\par
9656 {\cf21 #    pragma clang diagnostic pop}\par
9657 {\cf21 #endif}\par
9658 {\cf20 // end catch_stringref.cpp}\par
9659 {\cf20 // start catch_tag_alias.cpp}\par
9660 \par
9661 {\cf17 namespace }Catch \{\par
9662     TagAlias::TagAlias(std::string {\cf17 const} & _tag, SourceLineInfo _lineInfo): tag(_tag), lineInfo(_lineInfo) \{\}\par
9663 \}\par
9664 {\cf20 // end catch_tag_alias.cpp}\par
9665 {\cf20 // start catch_tag_alias_autoregistrar.cpp}\par
9666 \par
9667 {\cf17 namespace }Catch \{\par
9668 \par
9669     RegistrarForTagAliases::RegistrarForTagAliases({\cf18 char} {\cf17 const}* alias, {\cf18 char} {\cf17 const}* tag, SourceLineInfo {\cf17 const}& lineInfo) \{\par
9670         {\cf19 try} \{\par
9671             getMutableRegistryHub().registerTagAlias(alias, tag, lineInfo);\par
9672         \} {\cf19 catch} (...) \{\par
9673             {\cf20 // Do not throw when constructing global objects, instead register the exception to be processed later}\par
9674             getMutableRegistryHub().registerStartupException();\par
9675         \}\par
9676     \}\par
9677 \par
9678 \}\par
9679 {\cf20 // end catch_tag_alias_autoregistrar.cpp}\par
9680 {\cf20 // start catch_tag_alias_registry.cpp}\par
9681 \par
9682 {\cf21 #include <sstream>}\par
9683 \par
9684 {\cf17 namespace }Catch \{\par
9685 \par
9686     TagAliasRegistry::~TagAliasRegistry() \{\}\par
9687 \par
9688     TagAlias {\cf17 const}* TagAliasRegistry::find( std::string {\cf17 const}& alias ){\cf17  const }\{\par
9689         {\cf17 auto} it = m_registry.find( alias );\par
9690         {\cf19 if}( it != m_registry.end() )\par
9691             {\cf19 return} &(it->second);\par
9692         {\cf19 else}\par
9693             {\cf19 return} {\cf17 nullptr};\par
9694     \}\par
9695 \par
9696     std::string TagAliasRegistry::expandAliases( std::string {\cf17 const}& unexpandedTestSpec ){\cf17  const }\{\par
9697         std::string expandedTestSpec = unexpandedTestSpec;\par
9698         {\cf19 for}( {\cf17 auto} {\cf17 const}& registryKvp : m_registry ) \{\par
9699             std::size_t pos = expandedTestSpec.find( registryKvp.first );\par
9700             {\cf19 if}( pos != std::string::npos ) \{\par
9701                 expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +\par
9702                                     registryKvp.second.tag +\par
9703                                     expandedTestSpec.substr( pos + registryKvp.first.size() );\par
9704             \}\par
9705         \}\par
9706         {\cf19 return} expandedTestSpec;\par
9707     \}\par
9708 \par
9709     {\cf18 void} TagAliasRegistry::add( std::string {\cf17 const}& alias, std::string {\cf17 const}& tag, SourceLineInfo {\cf17 const}& lineInfo ) \{\par
9710         CATCH_ENFORCE( startsWith(alias, {\cf22 "[@"}) && endsWith(alias, {\cf23 ']'}),\par
9711                       {\cf22 "error: tag alias, '"} << alias << {\cf22 "' is not of the form [@alias name].\\n"} << lineInfo );\par
9712 \par
9713         CATCH_ENFORCE( m_registry.insert(std::make_pair(alias, TagAlias(tag, lineInfo))).second,\par
9714                       {\cf22 "error: tag alias, '"} << alias << {\cf22 "' already registered.\\n"}\par
9715                       << {\cf22 "\\tFirst seen at: "} << find(alias)->lineInfo << {\cf22 "\\n"}\par
9716                       << {\cf22 "\\tRedefined at: "} << lineInfo );\par
9717     \}\par
9718 \par
9719     ITagAliasRegistry::~ITagAliasRegistry() \{\}\par
9720 \par
9721     ITagAliasRegistry {\cf17 const}& ITagAliasRegistry::get() \{\par
9722         {\cf19 return} getRegistryHub().getTagAliasRegistry();\par
9723     \}\par
9724 \par
9725 \} {\cf20 // end namespace Catch}\par
9726 {\cf20 // end catch_tag_alias_registry.cpp}\par
9727 {\cf20 // start catch_test_case_info.cpp}\par
9728 \par
9729 {\cf21 #include <cctype>}\par
9730 {\cf21 #include <exception>}\par
9731 {\cf21 #include <algorithm>}\par
9732 {\cf21 #include <sstream>}\par
9733 \par
9734 {\cf17 namespace }Catch \{\par
9735 \par
9736     TestCaseInfo::SpecialProperties parseSpecialTag( std::string {\cf17 const}& tag ) \{\par
9737         {\cf19 if}( startsWith( tag, {\cf23 '.'} ) ||\par
9738             tag == {\cf22 "!hide"} )\par
9739             {\cf19 return} TestCaseInfo::IsHidden;\par
9740         {\cf19 else} {\cf19 if}( tag == {\cf22 "!throws"} )\par
9741             {\cf19 return} TestCaseInfo::Throws;\par
9742         {\cf19 else} {\cf19 if}( tag == {\cf22 "!shouldfail"} )\par
9743             {\cf19 return} TestCaseInfo::ShouldFail;\par
9744         {\cf19 else} {\cf19 if}( tag == {\cf22 "!mayfail"} )\par
9745             {\cf19 return} TestCaseInfo::MayFail;\par
9746         {\cf19 else} {\cf19 if}( tag == {\cf22 "!nonportable"} )\par
9747             {\cf19 return} TestCaseInfo::NonPortable;\par
9748         {\cf19 else} {\cf19 if}( tag == {\cf22 "!benchmark"} )\par
9749             {\cf19 return} {\cf17 static_cast<}TestCaseInfo::SpecialProperties{\cf17 >}( TestCaseInfo::Benchmark | TestCaseInfo::IsHidden );\par
9750         {\cf19 else}\par
9751             {\cf19 return} TestCaseInfo::None;\par
9752     \}\par
9753     {\cf18 bool} isReservedTag( std::string {\cf17 const}& tag ) \{\par
9754         {\cf19 return} parseSpecialTag( tag ) == TestCaseInfo::None && tag.size() > 0 && !std::isalnum( tag[0] );\par
9755     \}\par
9756     {\cf18 void} enforceNotReservedTag( std::string {\cf17 const}& tag, SourceLineInfo {\cf17 const}& _lineInfo ) \{\par
9757         CATCH_ENFORCE( !isReservedTag(tag),\par
9758                       {\cf22 "Tag name: ["} << tag << {\cf22 "] is not allowed.\\n"}\par
9759                       << {\cf22 "Tag names starting with non alpha-numeric characters are reserved\\n"}\par
9760                       << _lineInfo );\par
9761     \}\par
9762 \par
9763     TestCase makeTestCase(  ITestInvoker* _testCase,\par
9764                             std::string {\cf17 const}& _className,\par
9765                             NameAndTags {\cf17 const}& nameAndTags,\par
9766                             SourceLineInfo {\cf17 const}& _lineInfo )\par
9767     \{\par
9768         {\cf18 bool} isHidden = {\cf17 false};\par
9769 \par
9770         {\cf20 // Parse out tags}\par
9771         std::vector<std::string> tags;\par
9772         std::string desc, tag;\par
9773         {\cf18 bool} inTag = {\cf17 false};\par
9774         std::string _descOrTags = nameAndTags.tags;\par
9775         {\cf19 for} ({\cf18 char} c : _descOrTags) \{\par
9776             {\cf19 if}( !inTag ) \{\par
9777                 {\cf19 if}( c == {\cf23 '['} )\par
9778                     inTag = {\cf17 true};\par
9779                 {\cf19 else}\par
9780                     desc += c;\par
9781             \}\par
9782             {\cf19 else} \{\par
9783                 {\cf19 if}( c == {\cf23 ']'} ) \{\par
9784                     TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );\par
9785                     {\cf19 if}( ( prop & TestCaseInfo::IsHidden ) != 0 )\par
9786                         isHidden = {\cf17 true};\par
9787                     {\cf19 else} {\cf19 if}( prop == TestCaseInfo::None )\par
9788                         enforceNotReservedTag( tag, _lineInfo );\par
9789 \par
9790                     tags.push_back( tag );\par
9791                     tag.clear();\par
9792                     inTag = {\cf17 false};\par
9793                 \}\par
9794                 {\cf19 else}\par
9795                     tag += c;\par
9796             \}\par
9797         \}\par
9798         {\cf19 if}( isHidden ) \{\par
9799             tags.push_back( {\cf22 "."} );\par
9800         \}\par
9801 \par
9802         TestCaseInfo info( nameAndTags.name, _className, desc, tags, _lineInfo );\par
9803         {\cf19 return} TestCase( _testCase, std::move(info) );\par
9804     \}\par
9805 \par
9806     {\cf18 void} setTags( TestCaseInfo& testCaseInfo, std::vector<std::string> tags ) \{\par
9807         std::sort(begin(tags), end(tags));\par
9808         tags.erase(std::unique(begin(tags), end(tags)), end(tags));\par
9809         testCaseInfo.lcaseTags.clear();\par
9810 \par
9811         {\cf19 for}( {\cf17 auto} {\cf17 const}& tag : tags ) \{\par
9812             std::string lcaseTag = toLower( tag );\par
9813             testCaseInfo.properties = {\cf17 static_cast<}TestCaseInfo::SpecialProperties{\cf17 >}( testCaseInfo.properties | parseSpecialTag( lcaseTag ) );\par
9814             testCaseInfo.lcaseTags.push_back( lcaseTag );\par
9815         \}\par
9816         testCaseInfo.tags = std::move(tags);\par
9817     \}\par
9818 \par
9819     TestCaseInfo::TestCaseInfo( std::string {\cf17 const}& _name,\par
9820                                 std::string {\cf17 const}& _className,\par
9821                                 std::string {\cf17 const}& _description,\par
9822                                 std::vector<std::string> {\cf17 const}& _tags,\par
9823                                 SourceLineInfo {\cf17 const}& _lineInfo )\par
9824     :   name( _name ),\par
9825         className( _className ),\par
9826         description( _description ),\par
9827         lineInfo( _lineInfo ),\par
9828         properties( None )\par
9829     \{\par
9830         setTags( *{\cf17 this}, _tags );\par
9831     \}\par
9832 \par
9833     {\cf18 bool} TestCaseInfo::isHidden(){\cf17  const }\{\par
9834         {\cf19 return} ( properties & IsHidden ) != 0;\par
9835     \}\par
9836     {\cf18 bool} TestCaseInfo::throws(){\cf17  const }\{\par
9837         {\cf19 return} ( properties & Throws ) != 0;\par
9838     \}\par
9839     {\cf18 bool} TestCaseInfo::okToFail(){\cf17  const }\{\par
9840         {\cf19 return} ( properties & (ShouldFail | MayFail ) ) != 0;\par
9841     \}\par
9842     {\cf18 bool} TestCaseInfo::expectedToFail(){\cf17  const }\{\par
9843         {\cf19 return} ( properties & (ShouldFail ) ) != 0;\par
9844     \}\par
9845 \par
9846     std::string TestCaseInfo::tagsAsString(){\cf17  const }\{\par
9847         std::string ret;\par
9848         {\cf20 // '[' and ']' per tag}\par
9849         std::size_t full_size = 2 * tags.size();\par
9850         {\cf19 for} ({\cf17 const} {\cf17 auto}& tag : tags) \{\par
9851             full_size += tag.size();\par
9852         \}\par
9853         ret.reserve(full_size);\par
9854         {\cf19 for} ({\cf17 const} {\cf17 auto}& tag : tags) \{\par
9855             ret.push_back({\cf23 '['});\par
9856             ret.append(tag);\par
9857             ret.push_back({\cf23 ']'});\par
9858         \}\par
9859 \par
9860         {\cf19 return} ret;\par
9861     \}\par
9862 \par
9863     TestCase::TestCase( ITestInvoker* testCase, TestCaseInfo&& info ) : TestCaseInfo( std::move(info) ), test( testCase ) \{\}\par
9864 \par
9865     TestCase TestCase::withName( std::string {\cf17 const}& _newName ){\cf17  const }\{\par
9866         TestCase other( *{\cf17 this} );\par
9867         other.name = _newName;\par
9868         {\cf19 return} other;\par
9869     \}\par
9870 \par
9871     {\cf18 void} TestCase::invoke(){\cf17  const }\{\par
9872         test->invoke();\par
9873     \}\par
9874 \par
9875     {\cf18 bool} TestCase::operator == ( TestCase {\cf17 const}& other ){\cf17  const }\{\par
9876         {\cf19 return}  test.get() == other.test.get() &&\par
9877                 name == other.name &&\par
9878                 className == other.className;\par
9879     \}\par
9880 \par
9881     {\cf18 bool} TestCase::operator < ( TestCase {\cf17 const}& other ){\cf17  const }\{\par
9882         {\cf19 return} name < other.name;\par
9883     \}\par
9884 \par
9885     TestCaseInfo {\cf17 const}& TestCase::getTestCaseInfo(){\cf17  const}\par
9886 {\cf17     }\{\par
9887         {\cf19 return} *{\cf17 this};\par
9888     \}\par
9889 \par
9890 \} {\cf20 // end namespace Catch}\par
9891 {\cf20 // end catch_test_case_info.cpp}\par
9892 {\cf20 // start catch_test_case_registry_impl.cpp}\par
9893 \par
9894 {\cf21 #include <sstream>}\par
9895 \par
9896 {\cf17 namespace }Catch \{\par
9897 \par
9898     std::vector<TestCase> sortTests( IConfig {\cf17 const}& config, std::vector<TestCase> {\cf17 const}& unsortedTestCases ) \{\par
9899 \par
9900         std::vector<TestCase> sorted = unsortedTestCases;\par
9901 \par
9902         {\cf19 switch}( config.runOrder() ) \{\par
9903             {\cf19 case} RunTests::InLexicographicalOrder:\par
9904                 std::sort( sorted.begin(), sorted.end() );\par
9905                 {\cf19 break};\par
9906             {\cf19 case} RunTests::InRandomOrder:\par
9907                 seedRng( config );\par
9908                 RandomNumberGenerator::shuffle( sorted );\par
9909                 {\cf19 break};\par
9910             {\cf19 case} RunTests::InDeclarationOrder:\par
9911                 {\cf20 // already in declaration order}\par
9912                 {\cf19 break};\par
9913         \}\par
9914         {\cf19 return} sorted;\par
9915     \}\par
9916     {\cf18 bool} matchTest( TestCase {\cf17 const}& testCase, TestSpec {\cf17 const}& testSpec, IConfig {\cf17 const}& config ) \{\par
9917         {\cf19 return} testSpec.matches( testCase ) && ( config.allowThrows() || !testCase.throws() );\par
9918     \}\par
9919 \par
9920     {\cf18 void} enforceNoDuplicateTestCases( std::vector<TestCase> {\cf17 const}& functions ) \{\par
9921         std::set<TestCase> seenFunctions;\par
9922         {\cf19 for}( {\cf17 auto} {\cf17 const}& function : functions ) \{\par
9923             {\cf17 auto} prev = seenFunctions.insert( function );\par
9924             CATCH_ENFORCE( prev.second,\par
9925                     {\cf22 "error: TEST_CASE( \\""} << function.name << {\cf22 "\\" ) already defined.\\n"}\par
9926                     << {\cf22 "\\tFirst seen at "} << prev.first->getTestCaseInfo().lineInfo << {\cf22 "\\n"}\par
9927                     << {\cf22 "\\tRedefined at "} << function.getTestCaseInfo().lineInfo );\par
9928         \}\par
9929     \}\par
9930 \par
9931     std::vector<TestCase> filterTests( std::vector<TestCase> {\cf17 const}& testCases, TestSpec {\cf17 const}& testSpec, IConfig {\cf17 const}& config ) \{\par
9932         std::vector<TestCase> filtered;\par
9933         filtered.reserve( testCases.size() );\par
9934         {\cf19 for}( {\cf17 auto} {\cf17 const}& testCase : testCases )\par
9935             if( matchTest( testCase, testSpec, config ) )\par
9936                 filtered.push_back( testCase );\par
9937         {\cf19 return} filtered;\par
9938     \}\par
9939     std::vector<TestCase> {\cf17 const}& getAllTestCasesSorted( IConfig {\cf17 const}& config ) \{\par
9940         {\cf19 return} getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );\par
9941     \}\par
9942 \par
9943     {\cf18 void} TestRegistry::registerTest( TestCase {\cf17 const}& testCase ) \{\par
9944         std::string name = testCase.getTestCaseInfo().name;\par
9945         {\cf19 if}( name.empty() ) \{\par
9946             ReusableStringStream rss;\par
9947             rss << {\cf22 "Anonymous test case "} << ++m_unnamedCount;\par
9948             {\cf19 return} registerTest( testCase.withName( rss.str() ) );\par
9949         \}\par
9950         m_functions.push_back( testCase );\par
9951     \}\par
9952 \par
9953     std::vector<TestCase> {\cf17 const}& TestRegistry::getAllTests(){\cf17  const }\{\par
9954         {\cf19 return} m_functions;\par
9955     \}\par
9956     std::vector<TestCase> {\cf17 const}& TestRegistry::getAllTestsSorted( IConfig {\cf17 const}& config ){\cf17  const }\{\par
9957         {\cf19 if}( m_sortedFunctions.empty() )\par
9958             enforceNoDuplicateTestCases( m_functions );\par
9959 \par
9960         {\cf19 if}(  m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty() ) \{\par
9961             m_sortedFunctions = sortTests( config, m_functions );\par
9962             m_currentSortOrder = config.runOrder();\par
9963         \}\par
9964         {\cf19 return} m_sortedFunctions;\par
9965     \}\par
9966 \par
9968     TestInvokerAsFunction::TestInvokerAsFunction( {\cf18 void}(*testAsFunction)() ) noexcept : m_testAsFunction( testAsFunction ) \{\}\par
9969 \par
9970     {\cf18 void} TestInvokerAsFunction::invoke(){\cf17  const }\{\par
9971         m_testAsFunction();\par
9972     \}\par
9973 \par
9974     std::string extractClassName( StringRef {\cf17 const}& classOrQualifiedMethodName ) \{\par
9975         std::string className = classOrQualifiedMethodName;\par
9976         {\cf19 if}( startsWith( className, {\cf23 '&'} ) )\par
9977         \{\par
9978             std::size_t lastColons = className.rfind( {\cf22 "::"} );\par
9979             std::size_t penultimateColons = className.rfind( {\cf22 "::"}, lastColons-1 );\par
9980             {\cf19 if}( penultimateColons == std::string::npos )\par
9981                 penultimateColons = 1;\par
9982             className = className.substr( penultimateColons, lastColons-penultimateColons );\par
9983         \}\par
9984         {\cf19 return} className;\par
9985     \}\par
9986 \par
9987 \} {\cf20 // end namespace Catch}\par
9988 {\cf20 // end catch_test_case_registry_impl.cpp}\par
9989 {\cf20 // start catch_test_case_tracker.cpp}\par
9990 \par
9991 {\cf21 #include <algorithm>}\par
9992 {\cf21 #include <assert.h>}\par
9993 {\cf21 #include <stdexcept>}\par
9994 {\cf21 #include <memory>}\par
9995 {\cf21 #include <sstream>}\par
9996 \par
9997 {\cf21 #if defined(__clang__)}\par
9998 {\cf21 #    pragma clang diagnostic push}\par
9999 {\cf21 #    pragma clang diagnostic ignored "-Wexit-time-destructors"}\par
10000 {\cf21 #endif}\par
10001 \par
10002 {\cf17 namespace }Catch \{\par
10003 {\cf17 namespace }TestCaseTracking \{\par
10004 \par
10005     NameAndLocation::NameAndLocation( std::string {\cf17 const}& _name, SourceLineInfo {\cf17 const}& _location )\par
10006     :   name( _name ),\par
10007         location( _location )\par
10008     \{\}\par
10009 \par
10010     ITracker::~ITracker() = {\cf19 default};\par
10011 \par
10012     TrackerContext& TrackerContext::instance() \{\par
10013         {\cf17 static} TrackerContext s_instance;\par
10014         {\cf19 return} s_instance;\par
10015     \}\par
10016 \par
10017     ITracker& TrackerContext::startRun() \{\par
10018         m_rootTracker = std::make_shared<SectionTracker>( NameAndLocation( {\cf22 "\{root\}"}, CATCH_INTERNAL_LINEINFO ), *{\cf17 this}, {\cf17 nullptr} );\par
10019         m_currentTracker = {\cf17 nullptr};\par
10020         m_runState = Executing;\par
10021         {\cf19 return} *m_rootTracker;\par
10022     \}\par
10023 \par
10024     {\cf18 void} TrackerContext::endRun() \{\par
10025         m_rootTracker.reset();\par
10026         m_currentTracker = {\cf17 nullptr};\par
10027         m_runState = NotStarted;\par
10028     \}\par
10029 \par
10030     {\cf18 void} TrackerContext::startCycle() \{\par
10031         m_currentTracker = m_rootTracker.get();\par
10032         m_runState = Executing;\par
10033     \}\par
10034     {\cf18 void} TrackerContext::completeCycle() \{\par
10035         m_runState = CompletedCycle;\par
10036     \}\par
10037 \par
10038     {\cf18 bool} TrackerContext::completedCycle(){\cf17  const }\{\par
10039         {\cf19 return} m_runState == CompletedCycle;\par
10040     \}\par
10041     ITracker& TrackerContext::currentTracker() \{\par
10042         {\cf19 return} *m_currentTracker;\par
10043     \}\par
10044     {\cf18 void} TrackerContext::setCurrentTracker( ITracker* tracker ) \{\par
10045         m_currentTracker = tracker;\par
10046     \}\par
10047 \par
10048     TrackerBase::TrackerHasName::TrackerHasName( NameAndLocation {\cf17 const}& nameAndLocation ) : m_nameAndLocation( nameAndLocation ) \{\}\par
10049     {\cf18 bool} TrackerBase::TrackerHasName::operator ()( ITrackerPtr {\cf17 const}& tracker ){\cf17  const }\{\par
10050         {\cf19 return}\par
10051             tracker->nameAndLocation().name == m_nameAndLocation.name &&\par
10052             tracker->nameAndLocation().location == m_nameAndLocation.location;\par
10053     \}\par
10054 \par
10055     TrackerBase::TrackerBase( NameAndLocation {\cf17 const}& nameAndLocation, TrackerContext& ctx, ITracker* parent )\par
10056     :   m_nameAndLocation( nameAndLocation ),\par
10057         m_ctx( ctx ),\par
10058         m_parent( parent )\par
10059     \{\}\par
10060 \par
10061     NameAndLocation {\cf17 const}& TrackerBase::nameAndLocation(){\cf17  const }\{\par
10062         {\cf19 return} m_nameAndLocation;\par
10063     \}\par
10064     {\cf18 bool} TrackerBase::isComplete(){\cf17  const }\{\par
10065         {\cf19 return} m_runState == CompletedSuccessfully || m_runState == Failed;\par
10066     \}\par
10067     {\cf18 bool} TrackerBase::isSuccessfullyCompleted(){\cf17  const }\{\par
10068         {\cf19 return} m_runState == CompletedSuccessfully;\par
10069     \}\par
10070     {\cf18 bool} TrackerBase::isOpen(){\cf17  const }\{\par
10071         {\cf19 return} m_runState != NotStarted && !isComplete();\par
10072     \}\par
10073     {\cf18 bool} TrackerBase::hasChildren(){\cf17  const }\{\par
10074         {\cf19 return} !m_children.empty();\par
10075     \}\par
10076 \par
10077     {\cf18 void} TrackerBase::addChild( ITrackerPtr {\cf17 const}& child ) \{\par
10078         m_children.push_back( child );\par
10079     \}\par
10080 \par
10081     ITrackerPtr TrackerBase::findChild( NameAndLocation {\cf17 const}& nameAndLocation ) \{\par
10082         {\cf17 auto} it = std::find_if( m_children.begin(), m_children.end(), TrackerHasName( nameAndLocation ) );\par
10083         {\cf19 return}( it != m_children.end() )\par
10084             ? *it\par
10085             : {\cf17 nullptr};\par
10086     \}\par
10087     ITracker& TrackerBase::parent() \{\par
10088         assert( m_parent ); {\cf20 // Should always be non-null except for root}\par
10089         {\cf19 return} *m_parent;\par
10090     \}\par
10091 \par
10092     {\cf18 void} TrackerBase::openChild() \{\par
10093         {\cf19 if}( m_runState != ExecutingChildren ) \{\par
10094             m_runState = ExecutingChildren;\par
10095             {\cf19 if}( m_parent )\par
10096                 m_parent->openChild();\par
10097         \}\par
10098     \}\par
10099 \par
10100     {\cf18 bool} TrackerBase::isSectionTracker(){\cf17  const }\{ {\cf19 return} {\cf17 false}; \}\par
10101     {\cf18 bool} TrackerBase::isIndexTracker(){\cf17  const }\{ {\cf19 return} {\cf17 false}; \}\par
10102 \par
10103     {\cf18 void} TrackerBase::open() \{\par
10104         m_runState = Executing;\par
10105         moveToThis();\par
10106         {\cf19 if}( m_parent )\par
10107             m_parent->openChild();\par
10108     \}\par
10109 \par
10110     {\cf18 void} TrackerBase::close() \{\par
10111 \par
10112         {\cf20 // Close any still open children (e.g. generators)}\par
10113         {\cf19 while}( &m_ctx.currentTracker() != {\cf17 this} )\par
10114             m_ctx.currentTracker().close();\par
10115 \par
10116         {\cf19 switch}( m_runState ) \{\par
10117             {\cf19 case} NeedsAnotherRun:\par
10118                 {\cf19 break};\par
10119 \par
10120             {\cf19 case} Executing:\par
10121                 m_runState = CompletedSuccessfully;\par
10122                 {\cf19 break};\par
10123             {\cf19 case} ExecutingChildren:\par
10124                 {\cf19 if}( m_children.empty() || m_children.back()->isComplete() )\par
10125                     m_runState = CompletedSuccessfully;\par
10126                 {\cf19 break};\par
10127 \par
10128             {\cf19 case} NotStarted:\par
10129             {\cf19 case} CompletedSuccessfully:\par
10130             {\cf19 case} Failed:\par
10131                 CATCH_INTERNAL_ERROR( {\cf22 "Illogical state: "} << m_runState );\par
10132 \par
10133             {\cf19 default}:\par
10134                 CATCH_INTERNAL_ERROR( {\cf22 "Unknown state: "} << m_runState );\par
10135         \}\par
10136         moveToParent();\par
10137         m_ctx.completeCycle();\par
10138     \}\par
10139     {\cf18 void} TrackerBase::fail() \{\par
10140         m_runState = Failed;\par
10141         {\cf19 if}( m_parent )\par
10142             m_parent->markAsNeedingAnotherRun();\par
10143         moveToParent();\par
10144         m_ctx.completeCycle();\par
10145     \}\par
10146     {\cf18 void} TrackerBase::markAsNeedingAnotherRun() \{\par
10147         m_runState = NeedsAnotherRun;\par
10148     \}\par
10149 \par
10150     {\cf18 void} TrackerBase::moveToParent() \{\par
10151         assert( m_parent );\par
10152         m_ctx.setCurrentTracker( m_parent );\par
10153     \}\par
10154     {\cf18 void} TrackerBase::moveToThis() \{\par
10155         m_ctx.setCurrentTracker( {\cf17 this} );\par
10156     \}\par
10157 \par
10158     SectionTracker::SectionTracker( NameAndLocation {\cf17 const}& nameAndLocation, TrackerContext& ctx, ITracker* parent )\par
10159     :   TrackerBase( nameAndLocation, ctx, parent )\par
10160     \{\par
10161         {\cf19 if}( parent ) \{\par
10162             {\cf19 while}( !parent->isSectionTracker() )\par
10163                 parent = &parent->parent();\par
10164 \par
10165             SectionTracker& parentSection = {\cf17 static_cast<}SectionTracker&{\cf17 >}( *parent );\par
10166             addNextFilters( parentSection.m_filters );\par
10167         \}\par
10168     \}\par
10169 \par
10170     {\cf18 bool} SectionTracker::isSectionTracker(){\cf17  const }\{ {\cf19 return} {\cf17 true}; \}\par
10171 \par
10172     SectionTracker& SectionTracker::acquire( TrackerContext& ctx, NameAndLocation {\cf17 const}& nameAndLocation ) \{\par
10173         std::shared_ptr<SectionTracker> section;\par
10174 \par
10175         ITracker& currentTracker = ctx.currentTracker();\par
10176         {\cf19 if}( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) \{\par
10177             assert( childTracker );\par
10178             assert( childTracker->isSectionTracker() );\par
10179             section = std::static_pointer_cast<SectionTracker>( childTracker );\par
10180         \}\par
10181         {\cf19 else} \{\par
10182             section = std::make_shared<SectionTracker>( nameAndLocation, ctx, &currentTracker );\par
10183             currentTracker.addChild( section );\par
10184         \}\par
10185         {\cf19 if}( !ctx.completedCycle() )\par
10186             section->tryOpen();\par
10187         {\cf19 return} *section;\par
10188     \}\par
10189 \par
10190     {\cf18 void} SectionTracker::tryOpen() \{\par
10191         {\cf19 if}( !isComplete() && (m_filters.empty() || m_filters[0].empty() ||  m_filters[0] == m_nameAndLocation.name ) )\par
10192             open();\par
10193     \}\par
10194 \par
10195     {\cf18 void} SectionTracker::addInitialFilters( std::vector<std::string> {\cf17 const}& filters ) \{\par
10196         {\cf19 if}( !filters.empty() ) \{\par
10197             m_filters.push_back({\cf22 ""}); {\cf20 // Root - should never be consulted}\par
10198             m_filters.push_back({\cf22 ""}); {\cf20 // Test Case - not a section filter}\par
10199             m_filters.insert( m_filters.end(), filters.begin(), filters.end() );\par
10200         \}\par
10201     \}\par
10202     {\cf18 void} SectionTracker::addNextFilters( std::vector<std::string> {\cf17 const}& filters ) \{\par
10203         {\cf19 if}( filters.size() > 1 )\par
10204             m_filters.insert( m_filters.end(), ++filters.begin(), filters.end() );\par
10205     \}\par
10206 \par
10207     IndexTracker::IndexTracker( NameAndLocation {\cf17 const}& nameAndLocation, TrackerContext& ctx, ITracker* parent, {\cf18 int} size )\par
10208     :   TrackerBase( nameAndLocation, ctx, parent ),\par
10209         m_size( size )\par
10210     \{\}\par
10211 \par
10212     {\cf18 bool} IndexTracker::isIndexTracker(){\cf17  const }\{ {\cf19 return} {\cf17 true}; \}\par
10213 \par
10214     IndexTracker& IndexTracker::acquire( TrackerContext& ctx, NameAndLocation {\cf17 const}& nameAndLocation, {\cf18 int} size ) \{\par
10215         std::shared_ptr<IndexTracker> tracker;\par
10216 \par
10217         ITracker& currentTracker = ctx.currentTracker();\par
10218         {\cf19 if}( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) \{\par
10219             assert( childTracker );\par
10220             assert( childTracker->isIndexTracker() );\par
10221             tracker = std::static_pointer_cast<IndexTracker>( childTracker );\par
10222         \}\par
10223         {\cf19 else} \{\par
10224             tracker = std::make_shared<IndexTracker>( nameAndLocation, ctx, &currentTracker, size );\par
10225             currentTracker.addChild( tracker );\par
10226         \}\par
10227 \par
10228         {\cf19 if}( !ctx.completedCycle() && !tracker->isComplete() ) \{\par
10229             {\cf19 if}( tracker->m_runState != ExecutingChildren && tracker->m_runState != NeedsAnotherRun )\par
10230                 tracker->moveNext();\par
10231             tracker->open();\par
10232         \}\par
10233 \par
10234         {\cf19 return} *tracker;\par
10235     \}\par
10236 \par
10237     {\cf18 int} IndexTracker::index(){\cf17  const }\{ {\cf19 return} m_index; \}\par
10238 \par
10239     {\cf18 void} IndexTracker::moveNext() \{\par
10240         m_index++;\par
10241         m_children.clear();\par
10242     \}\par
10243 \par
10244     {\cf18 void} IndexTracker::close() \{\par
10245         TrackerBase::close();\par
10246         {\cf19 if}( m_runState == CompletedSuccessfully && m_index < m_size-1 )\par
10247             m_runState = Executing;\par
10248     \}\par
10249 \par
10250 \} {\cf20 // namespace TestCaseTracking}\par
10251 \par
10252 {\cf17 using }TestCaseTracking::ITracker;\par
10253 {\cf17 using }TestCaseTracking::TrackerContext;\par
10254 {\cf17 using }TestCaseTracking::SectionTracker;\par
10255 {\cf17 using }TestCaseTracking::IndexTracker;\par
10256 \par
10257 \} {\cf20 // namespace Catch}\par
10258 \par
10259 {\cf21 #if defined(__clang__)}\par
10260 {\cf21 #    pragma clang diagnostic pop}\par
10261 {\cf21 #endif}\par
10262 {\cf20 // end catch_test_case_tracker.cpp}\par
10263 {\cf20 // start catch_test_registry.cpp}\par
10264 \par
10265 {\cf17 namespace }Catch \{\par
10266 \par
10267     {\cf17 auto} makeTestInvoker( {\cf18 void}(*testAsFunction)() ) noexcept -> ITestInvoker* \{\par
10268         {\cf19 return} {\cf17 new}(std::nothrow) TestInvokerAsFunction( testAsFunction );\par
10269     \}\par
10270 \par
10271     NameAndTags::NameAndTags( StringRef {\cf17 const}& name_ , StringRef {\cf17 const}& tags_ ) noexcept : name( name_ ), tags( tags_ ) \{\}\par
10272 \par
10273     AutoReg::AutoReg( ITestInvoker* invoker, SourceLineInfo {\cf17 const}& lineInfo, StringRef {\cf17 const}& classOrMethod, NameAndTags {\cf17 const}& nameAndTags ) {\cf17 noexcept} \{\par
10274         {\cf19 try} \{\par
10275             getMutableRegistryHub()\par
10276                     .registerTest(\par
10277                         makeTestCase(\par
10278                             invoker,\par
10279                             extractClassName( classOrMethod ),\par
10280                             nameAndTags,\par
10281                             lineInfo));\par
10282         \} {\cf19 catch} (...) \{\par
10283             {\cf20 // Do not throw when constructing global objects, instead register the exception to be processed later}\par
10284             getMutableRegistryHub().registerStartupException();\par
10285         \}\par
10286     \}\par
10287 \par
10288     AutoReg::~AutoReg() = {\cf19 default};\par
10289 \}\par
10290 {\cf20 // end catch_test_registry.cpp}\par
10291 {\cf20 // start catch_test_spec.cpp}\par
10292 \par
10293 {\cf21 #include <algorithm>}\par
10294 {\cf21 #include <string>}\par
10295 {\cf21 #include <vector>}\par
10296 {\cf21 #include <memory>}\par
10297 \par
10298 {\cf17 namespace }Catch \{\par
10299 \par
10300     TestSpec::Pattern::~Pattern() = {\cf19 default};\par
10301     TestSpec::NamePattern::~NamePattern() = {\cf19 default};\par
10302     TestSpec::TagPattern::~TagPattern() = {\cf19 default};\par
10303     TestSpec::ExcludedPattern::~ExcludedPattern() = {\cf19 default};\par
10304 \par
10305     TestSpec::NamePattern::NamePattern( std::string {\cf17 const}& name )\par
10306     : m_wildcardPattern( toLower( name ), CaseSensitive::No )\par
10307     \{\}\par
10308     {\cf18 bool} TestSpec::NamePattern::matches( TestCaseInfo {\cf17 const}& testCase ){\cf17  const }\{\par
10309         {\cf19 return} m_wildcardPattern.matches( toLower( testCase.name ) );\par
10310     \}\par
10311 \par
10312     TestSpec::TagPattern::TagPattern( std::string {\cf17 const}& tag ) : m_tag( toLower( tag ) ) \{\}\par
10313     {\cf18 bool} TestSpec::TagPattern::matches( TestCaseInfo {\cf17 const}& testCase ){\cf17  const }\{\par
10314         {\cf19 return} std::find(begin(testCase.lcaseTags),\par
10315                          end(testCase.lcaseTags),\par
10316                          m_tag) != end(testCase.lcaseTags);\par
10317     \}\par
10318 \par
10319     TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr {\cf17 const}& underlyingPattern ) : m_underlyingPattern( underlyingPattern ) \{\}\par
10320     {\cf18 bool} TestSpec::ExcludedPattern::matches( TestCaseInfo {\cf17 const}& testCase ){\cf17  const }\{ {\cf19 return} !m_underlyingPattern->matches( testCase ); \}\par
10321 \par
10322     {\cf18 bool} TestSpec::Filter::matches( TestCaseInfo {\cf17 const}& testCase ){\cf17  const }\{\par
10323         {\cf20 // All patterns in a filter must match for the filter to be a match}\par
10324         {\cf19 for}( {\cf17 auto} {\cf17 const}& pattern : m_patterns ) \{\par
10325             {\cf19 if}( !pattern->matches( testCase ) )\par
10326                 {\cf19 return} {\cf17 false};\par
10327         \}\par
10328         {\cf19 return} {\cf17 true};\par
10329     \}\par
10330 \par
10331     {\cf18 bool} TestSpec::hasFilters(){\cf17  const }\{\par
10332         {\cf19 return} !m_filters.empty();\par
10333     \}\par
10334     {\cf18 bool} TestSpec::matches( TestCaseInfo {\cf17 const}& testCase ){\cf17  const }\{\par
10335         {\cf20 // A TestSpec matches if any filter matches}\par
10336         {\cf19 for}( {\cf17 auto} {\cf17 const}& filter : m_filters )\par
10337             if( filter.matches( testCase ) )\par
10338                 return true;\par
10339         {\cf19 return} {\cf17 false};\par
10340     \}\par
10341 \}\par
10342 {\cf20 // end catch_test_spec.cpp}\par
10343 {\cf20 // start catch_test_spec_parser.cpp}\par
10344 \par
10345 {\cf17 namespace }Catch \{\par
10346 \par
10347     TestSpecParser::TestSpecParser( ITagAliasRegistry {\cf17 const}& tagAliases ) : m_tagAliases( &tagAliases ) \{\}\par
10348 \par
10349     TestSpecParser& TestSpecParser::parse( std::string {\cf17 const}& arg ) \{\par
10350         m_mode = None;\par
10351         m_exclusion = {\cf17 false};\par
10352         m_start = std::string::npos;\par
10353         m_arg = m_tagAliases->expandAliases( arg );\par
10354         m_escapeChars.clear();\par
10355         {\cf19 for}( m_pos = 0; m_pos < m_arg.size(); ++m_pos )\par
10356             visitChar( m_arg[m_pos] );\par
10357         {\cf19 if}( m_mode == Name )\par
10358             addPattern<TestSpec::NamePattern>();\par
10359         {\cf19 return} *{\cf17 this};\par
10360     \}\par
10361     TestSpec TestSpecParser::testSpec() \{\par
10362         addFilter();\par
10363         {\cf19 return} m_testSpec;\par
10364     \}\par
10365 \par
10366     {\cf18 void} TestSpecParser::visitChar( {\cf18 char} c ) \{\par
10367         {\cf19 if}( m_mode == None ) \{\par
10368             {\cf19 switch}( c ) \{\par
10369             {\cf19 case} {\cf23 ' '}: {\cf19 return};\par
10370             {\cf19 case} {\cf23 '~'}: m_exclusion = {\cf17 true}; {\cf19 return};\par
10371             {\cf19 case} {\cf23 '['}: {\cf19 return} startNewMode( Tag, ++m_pos );\par
10372             {\cf19 case} {\cf23 '"'}: {\cf19 return} startNewMode( QuotedName, ++m_pos );\par
10373             {\cf19 case} {\cf23 '\\\\'}: {\cf19 return} escape();\par
10374             {\cf19 default}: startNewMode( Name, m_pos ); {\cf19 break};\par
10375             \}\par
10376         \}\par
10377         {\cf19 if}( m_mode == Name ) \{\par
10378             {\cf19 if}( c == {\cf23 ','} ) \{\par
10379                 addPattern<TestSpec::NamePattern>();\par
10380                 addFilter();\par
10381             \}\par
10382             {\cf19 else} {\cf19 if}( c == {\cf23 '['} ) \{\par
10383                 {\cf19 if}( subString() == {\cf22 "exclude:"} )\par
10384                     m_exclusion = {\cf17 true};\par
10385                 {\cf19 else}\par
10386                     addPattern<TestSpec::NamePattern>();\par
10387                 startNewMode( Tag, ++m_pos );\par
10388             \}\par
10389             {\cf19 else} {\cf19 if}( c == {\cf23 '\\\\'} )\par
10390                 escape();\par
10391         \}\par
10392         {\cf19 else} {\cf19 if}( m_mode == EscapedName )\par
10393             m_mode = Name;\par
10394         {\cf19 else} {\cf19 if}( m_mode == QuotedName && c == {\cf23 '"'} )\par
10395             addPattern<TestSpec::NamePattern>();\par
10396         {\cf19 else} {\cf19 if}( m_mode == Tag && c == {\cf23 ']'} )\par
10397             addPattern<TestSpec::TagPattern>();\par
10398     \}\par
10399     {\cf18 void} TestSpecParser::startNewMode( Mode mode, std::size_t start ) \{\par
10400         m_mode = mode;\par
10401         m_start = start;\par
10402     \}\par
10403     {\cf18 void} TestSpecParser::escape() \{\par
10404         {\cf19 if}( m_mode == None )\par
10405             m_start = m_pos;\par
10406         m_mode = EscapedName;\par
10407         m_escapeChars.push_back( m_pos );\par
10408     \}\par
10409     std::string TestSpecParser::subString(){\cf17  const }\{ {\cf19 return} m_arg.substr( m_start, m_pos - m_start ); \}\par
10410 \par
10411     {\cf18 void} TestSpecParser::addFilter() \{\par
10412         {\cf19 if}( !m_currentFilter.m_patterns.empty() ) \{\par
10413             m_testSpec.m_filters.push_back( m_currentFilter );\par
10414             m_currentFilter = TestSpec::Filter();\par
10415         \}\par
10416     \}\par
10417 \par
10418     TestSpec parseTestSpec( std::string {\cf17 const}& arg ) \{\par
10419         {\cf19 return} TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();\par
10420     \}\par
10421 \par
10422 \} {\cf20 // namespace Catch}\par
10423 {\cf20 // end catch_test_spec_parser.cpp}\par
10424 {\cf20 // start catch_timer.cpp}\par
10425 \par
10426 {\cf21 #include <chrono>}\par
10427 \par
10428 {\cf17 namespace }Catch \{\par
10429 \par
10430     {\cf17 auto} getCurrentNanosecondsSinceEpoch() -> uint64_t \{\par
10431         {\cf19 return} std::chrono::duration_cast<std::chrono::nanoseconds>( std::chrono::high_resolution_clock::now().time_since_epoch() ).count();\par
10432     \}\par
10433 \par
10434     {\cf17 auto} estimateClockResolution() -> uint64_t \{\par
10435         uint64_t sum = 0;\par
10436         {\cf17 static} {\cf17 const} uint64_t iterations = 1000000;\par
10437 \par
10438         {\cf19 for}( std::size_t i = 0; i < iterations; ++i ) \{\par
10439 \par
10440             uint64_t ticks;\par
10441             uint64_t baseTicks = getCurrentNanosecondsSinceEpoch();\par
10442             {\cf19 do} \{\par
10443                 ticks = getCurrentNanosecondsSinceEpoch();\par
10444             \}\par
10445             {\cf19 while}( ticks == baseTicks );\par
10446 \par
10447             {\cf17 auto} delta = ticks - baseTicks;\par
10448             sum += delta;\par
10449         \}\par
10450 \par
10451         {\cf20 // We're just taking the mean, here. To do better we could take the std. dev and exclude outliers}\par
10452         {\cf20 // - and potentially do more iterations if there's a high variance.}\par
10453         {\cf19 return} sum/iterations;\par
10454     \}\par
10455     {\cf17 auto} getEstimatedClockResolution() -> uint64_t \{\par
10456         {\cf17 static} {\cf17 auto} s_resolution = estimateClockResolution();\par
10457         {\cf19 return} s_resolution;\par
10458     \}\par
10459 \par
10460     {\cf18 void} Timer::start() \{\par
10461        m_nanoseconds = getCurrentNanosecondsSinceEpoch();\par
10462     \}\par
10463     {\cf17 auto} Timer::getElapsedNanoseconds() const -> uint64_t \{\par
10464         {\cf19 return} getCurrentNanosecondsSinceEpoch() - m_nanoseconds;\par
10465     \}\par
10466     {\cf17 auto} Timer::getElapsedMicroseconds() const -> uint64_t \{\par
10467         {\cf19 return} getElapsedNanoseconds()/1000;\par
10468     \}\par
10469     {\cf17 auto} Timer::getElapsedMilliseconds() const -> {\cf18 unsigned} {\cf18 int} \{\par
10470         {\cf19 return} {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(getElapsedMicroseconds()/1000);\par
10471     \}\par
10472     {\cf17 auto} Timer::getElapsedSeconds() const -> {\cf18 double} \{\par
10473         {\cf19 return} getElapsedMicroseconds()/1000000.0;\par
10474     \}\par
10475 \par
10476 \} {\cf20 // namespace Catch}\par
10477 {\cf20 // end catch_timer.cpp}\par
10478 {\cf20 // start catch_tostring.cpp}\par
10479 \par
10480 {\cf21 #if defined(__clang__)}\par
10481 {\cf21 #    pragma clang diagnostic push}\par
10482 {\cf21 #    pragma clang diagnostic ignored "-Wexit-time-destructors"}\par
10483 {\cf21 #    pragma clang diagnostic ignored "-Wglobal-constructors"}\par
10484 {\cf21 #endif}\par
10485 \par
10486 {\cf20 // Enable specific decls locally}\par
10487 {\cf21 #if !defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)}\par
10488 {\cf21 #define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER}\par
10489 {\cf21 #endif}\par
10490 \par
10491 {\cf21 #include <cmath>}\par
10492 {\cf21 #include <iomanip>}\par
10493 \par
10494 {\cf17 namespace }Catch \{\par
10495 \par
10496 {\cf17 namespace }Detail \{\par
10497 \par
10498     {\cf17 const} std::string unprintableString = {\cf22 "\{?\}"};\par
10499 \par
10500     {\cf17 namespace }\{\par
10501         {\cf17 const} {\cf18 int} hexThreshold = 255;\par
10502 \par
10503         {\cf17 struct }Endianness \{\par
10504             {\cf17 enum} Arch \{ Big, Little \};\par
10505 \par
10506             {\cf17 static} Arch which() \{\par
10507                 {\cf17 union }_\{\par
10508                     {\cf18 int} asInt;\par
10509                     {\cf18 char} asChar[sizeof (int)];\par
10510                 \} u;\par
10511 \par
10512                 u.asInt = 1;\par
10513                 {\cf19 return} ( u.asChar[{\cf17 sizeof}({\cf18 int})-1] == 1 ) ? Big : Little;\par
10514             \}\par
10515         \};\par
10516     \}\par
10517 \par
10518     std::string rawMemoryToString( {\cf17 const} {\cf18 void} *{\cf18 object}, std::size_t size ) \{\par
10519         {\cf20 // Reverse order for little endian architectures}\par
10520         {\cf18 int} i = 0, end = {\cf17 static_cast<}{\cf18 int}{\cf17 >}( size ), inc = 1;\par
10521         {\cf19 if}( Endianness::which() == Endianness::Little ) \{\par
10522             i = end-1;\par
10523             end = inc = -1;\par
10524         \}\par
10525 \par
10526         {\cf18 unsigned} {\cf18 char} {\cf17 const} *bytes = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char} {\cf17 const }*{\cf17 >}(object);\par
10527         ReusableStringStream rss;\par
10528         rss << {\cf22 "0x"} << std::setfill({\cf23 '0'}) << std::hex;\par
10529         {\cf19 for}( ; i != end; i += inc )\par
10530              rss << std::setw(2) << static_cast<unsigned>(bytes[i]);\par
10531        {\cf19 return} rss.str();\par
10532     \}\par
10533 \}\par
10534 \par
10535 {\cf17 template}<{\cf17 typename} T>\par
10536 std::string fpToString( T value, {\cf18 int} precision ) \{\par
10537     {\cf19 if} (std::isnan(value)) \{\par
10538         {\cf19 return} {\cf22 "nan"};\par
10539     \}\par
10540 \par
10541     ReusableStringStream rss;\par
10542     rss << std::setprecision( precision )\par
10543         << std::fixed\par
10544         << value;\par
10545     std::string d = rss.str();\par
10546     std::size_t i = d.find_last_not_of( {\cf23 '0'} );\par
10547     {\cf19 if}( i != std::string::npos && i != d.size()-1 ) \{\par
10548         {\cf19 if}( d[i] == {\cf23 '.'} )\par
10549             i++;\par
10550         d = d.substr( 0, i+1 );\par
10551     \}\par
10552     {\cf19 return} d;\par
10553 \}\par
10554 \par
10556 {\cf20 //}\par
10557 {\cf20 //   Out-of-line defs for full specialization of StringMaker}\par
10558 {\cf20 //}\par
10560 {\cf20 }\par
10561 std::string StringMaker<std::string>::convert({\cf17 const} std::string& str) \{\par
10562     {\cf19 if} (!getCurrentContext().getConfig()->showInvisibles()) \{\par
10563         {\cf19 return} {\cf23 '"'} + str + '"';\par
10564     \}\par
10565 \par
10566     std::string s({\cf22 "\\""});\par
10567     {\cf19 for} ({\cf18 char} c : str) \{\par
10568         {\cf19 switch} (c) \{\par
10569         {\cf19 case} {\cf23 '\\n'}:\par
10570             s.append({\cf22 "\\\\n"});\par
10571             {\cf19 break};\par
10572         {\cf19 case} {\cf23 '\\t'}:\par
10573             s.append({\cf22 "\\\\t"});\par
10574             {\cf19 break};\par
10575         {\cf19 default}:\par
10576             s.push_back(c);\par
10577             {\cf19 break};\par
10578         \}\par
10579     \}\par
10580     s.append({\cf22 "\\""});\par
10581     {\cf19 return} s;\par
10582 \}\par
10583 \par
10584 {\cf21 #ifdef CATCH_CONFIG_WCHAR}\par
10585 std::string StringMaker<std::wstring>::convert({\cf17 const} std::wstring& wstr) \{\par
10586     std::string s;\par
10587     s.reserve(wstr.size());\par
10588     {\cf19 for} ({\cf17 auto} c : wstr) \{\par
10589         s += (c <= 0xff) ? static_cast<char>(c) : '?';\par
10590     \}\par
10591     return ::Catch::Detail::stringify(s);\par
10592 \}\par
10593 {\cf21 #endif}\par
10594 \par
10595 std::string StringMaker<char const*>::convert({\cf18 char} {\cf17 const}* str) \{\par
10596     {\cf19 if} (str) \{\par
10597         return ::Catch::Detail::stringify(std::string\{ str \});\par
10598     \} {\cf19 else} \{\par
10599         {\cf19 return}\{ {\cf22 "\{null string\}"} \};\par
10600     \}\par
10601 \}\par
10602 std::string StringMaker<char*>::convert({\cf18 char}* str) \{\par
10603     {\cf19 if} (str) \{\par
10604         return ::Catch::Detail::stringify(std::string\{ str \});\par
10605     \} {\cf19 else} \{\par
10606         {\cf19 return}\{ {\cf22 "\{null string\}"} \};\par
10607     \}\par
10608 \}\par
10609 {\cf21 #ifdef CATCH_CONFIG_WCHAR}\par
10610 std::string StringMaker<wchar_t const*>::convert({\cf18 wchar_t} {\cf17 const} * str) \{\par
10611     {\cf19 if} (str) \{\par
10612         return ::Catch::Detail::stringify(std::wstring\{ str \});\par
10613     \} {\cf19 else} \{\par
10614         {\cf19 return}\{ {\cf22 "\{null string\}"} \};\par
10615     \}\par
10616 \}\par
10617 std::string StringMaker<wchar_t *>::convert({\cf18 wchar_t} * str) \{\par
10618     {\cf19 if} (str) \{\par
10619         return ::Catch::Detail::stringify(std::wstring\{ str \});\par
10620     \} {\cf19 else} \{\par
10621         {\cf19 return}\{ {\cf22 "\{null string\}"} \};\par
10622     \}\par
10623 \}\par
10624 {\cf21 #endif}\par
10625 \par
10626 std::string StringMaker<int>::convert({\cf18 int} value) \{\par
10627     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 long} {\cf18 long}{\cf17 >}(value));\par
10628 \}\par
10629 std::string StringMaker<long>::convert({\cf18 long} value) \{\par
10630     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 long} {\cf18 long}{\cf17 >}(value));\par
10631 \}\par
10632 std::string StringMaker<long long>::convert({\cf18 long} {\cf18 long} value) \{\par
10633     ReusableStringStream rss;\par
10634     rss << value;\par
10635     {\cf19 if} (value > Detail::hexThreshold) \{\par
10636         rss << {\cf22 " (0x"} << std::hex << value << {\cf23 ')'};\par
10637     \}\par
10638     {\cf19 return} rss.str();\par
10639 \}\par
10640 \par
10641 std::string StringMaker<unsigned int>::convert({\cf18 unsigned} {\cf18 int} value) \{\par
10642     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 unsigned} {\cf18 long} {\cf18 long}{\cf17 >}(value));\par
10643 \}\par
10644 std::string StringMaker<unsigned long>::convert({\cf18 unsigned} {\cf18 long} value) \{\par
10645     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 unsigned} {\cf18 long} {\cf18 long}{\cf17 >}(value));\par
10646 \}\par
10647 std::string StringMaker<unsigned long long>::convert({\cf18 unsigned} {\cf18 long} {\cf18 long} value) \{\par
10648     ReusableStringStream rss;\par
10649     rss << value;\par
10650     {\cf19 if} (value > Detail::hexThreshold) \{\par
10651         rss << {\cf22 " (0x"} << std::hex << value << {\cf23 ')'};\par
10652     \}\par
10653     {\cf19 return} rss.str();\par
10654 \}\par
10655 \par
10656 std::string StringMaker<bool>::convert({\cf18 bool} b) \{\par
10657     {\cf19 return} b ? {\cf22 "true"} : {\cf22 "false"};\par
10658 \}\par
10659 \par
10660 std::string StringMaker<char>::convert({\cf18 char} value) \{\par
10661     {\cf19 if} (value == {\cf23 '\\r'}) \{\par
10662         {\cf19 return} {\cf22 "'\\\\r'"};\par
10663     \} {\cf19 else} {\cf19 if} (value == {\cf23 '\\f'}) \{\par
10664         {\cf19 return} {\cf22 "'\\\\f'"};\par
10665     \} {\cf19 else} {\cf19 if} (value == {\cf23 '\\n'}) \{\par
10666         {\cf19 return} {\cf22 "'\\\\n'"};\par
10667     \} {\cf19 else} {\cf19 if} (value == {\cf23 '\\t'}) \{\par
10668         {\cf19 return} {\cf22 "'\\\\t'"};\par
10669     \} {\cf19 else} {\cf19 if} ({\cf23 '\\0'} <= value && value < {\cf23 ' '}) \{\par
10670         return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(value));\par
10671     \} {\cf19 else} \{\par
10672         {\cf18 char} chstr[] = {\cf22 "' '"};\par
10673         chstr[1] = value;\par
10674         {\cf19 return} chstr;\par
10675     \}\par
10676 \}\par
10677 std::string StringMaker<signed char>::convert({\cf18 signed} {\cf18 char} c) \{\par
10678     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 char}{\cf17 >}(c));\par
10679 \}\par
10680 std::string StringMaker<unsigned char>::convert({\cf18 unsigned} {\cf18 char} c) \{\par
10681     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 char}{\cf17 >}(c));\par
10682 \}\par
10683 \par
10684 std::string StringMaker<std::nullptr_t>::convert(std::nullptr_t) \{\par
10685     {\cf19 return} {\cf22 "nullptr"};\par
10686 \}\par
10687 \par
10688 std::string StringMaker<float>::convert({\cf18 float} value) \{\par
10689     {\cf19 return} fpToString(value, 5) + 'f';\par
10690 \}\par
10691 std::string StringMaker<double>::convert({\cf18 double} value) \{\par
10692     {\cf19 return} fpToString(value, 10);\par
10693 \}\par
10694 \par
10695 std::string ratio_string<std::atto>::symbol() \{ {\cf19 return} {\cf22 "a"}; \}\par
10696 std::string ratio_string<std::femto>::symbol() \{ {\cf19 return} {\cf22 "f"}; \}\par
10697 std::string  ratio_string<std::pico>::symbol() \{ {\cf19 return} {\cf22 "p"}; \}\par
10698 std::string  ratio_string<std::nano>::symbol() \{ {\cf19 return} {\cf22 "n"}; \}\par
10699 std::string ratio_string<std::micro>::symbol() \{ {\cf19 return} {\cf22 "u"}; \}\par
10700 std::string ratio_string<std::milli>::symbol() \{ {\cf19 return} {\cf22 "m"}; \}\par
10701 \par
10702 \} {\cf20 // end namespace Catch}\par
10703 \par
10704 {\cf21 #if defined(__clang__)}\par
10705 {\cf21 #    pragma clang diagnostic pop}\par
10706 {\cf21 #endif}\par
10707 \par
10708 {\cf20 // end catch_tostring.cpp}\par
10709 {\cf20 // start catch_totals.cpp}\par
10710 \par
10711 {\cf17 namespace }Catch \{\par
10712 \par
10713     Counts Counts::operator - ( Counts {\cf17 const}& other ){\cf17  const }\{\par
10714         Counts diff;\par
10715         diff.passed = passed - other.passed;\par
10716         diff.failed = failed - other.failed;\par
10717         diff.failedButOk = failedButOk - other.failedButOk;\par
10718         {\cf19 return} diff;\par
10719     \}\par
10720 \par
10721     Counts& Counts::operator += ( Counts {\cf17 const}& other ) \{\par
10722         passed += other.passed;\par
10723         failed += other.failed;\par
10724         failedButOk += other.failedButOk;\par
10725         {\cf19 return} *{\cf17 this};\par
10726     \}\par
10727 \par
10728     std::size_t Counts::total(){\cf17  const }\{\par
10729         {\cf19 return} passed + failed + failedButOk;\par
10730     \}\par
10731     {\cf18 bool} Counts::allPassed(){\cf17  const }\{\par
10732         {\cf19 return} failed == 0 && failedButOk == 0;\par
10733     \}\par
10734     {\cf18 bool} Counts::allOk(){\cf17  const }\{\par
10735         {\cf19 return} failed == 0;\par
10736     \}\par
10737 \par
10738     Totals Totals::operator - ( Totals {\cf17 const}& other ){\cf17  const }\{\par
10739         Totals diff;\par
10740         diff.assertions = assertions - other.assertions;\par
10741         diff.testCases = testCases - other.testCases;\par
10742         {\cf19 return} diff;\par
10743     \}\par
10744 \par
10745     Totals& Totals::operator += ( Totals {\cf17 const}& other ) \{\par
10746         assertions += other.assertions;\par
10747         testCases += other.testCases;\par
10748         {\cf19 return} *{\cf17 this};\par
10749     \}\par
10750 \par
10751     Totals Totals::delta( Totals {\cf17 const}& prevTotals ){\cf17  const }\{\par
10752         Totals diff = *{\cf17 this} - prevTotals;\par
10753         {\cf19 if}( diff.assertions.failed > 0 )\par
10754             ++diff.testCases.failed;\par
10755         {\cf19 else} {\cf19 if}( diff.assertions.failedButOk > 0 )\par
10756             ++diff.testCases.failedButOk;\par
10757         {\cf19 else}\par
10758             ++diff.testCases.passed;\par
10759         {\cf19 return} diff;\par
10760     \}\par
10761 \par
10762 \}\par
10763 {\cf20 // end catch_totals.cpp}\par
10764 {\cf20 // start catch_uncaught_exceptions.cpp}\par
10765 \par
10766 {\cf21 #include <exception>}\par
10767 \par
10768 {\cf17 namespace }Catch \{\par
10769     {\cf18 bool} uncaught_exceptions() \{\par
10770 {\cf21 #if defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)}\par
10771         {\cf19 return} std::uncaught_exceptions() > 0;\par
10772 {\cf21 #else}\par
10773         {\cf19 return} std::uncaught_exception();\par
10774 {\cf21 #endif}\par
10775   \}\par
10776 \} {\cf20 // end namespace Catch}\par
10777 {\cf20 // end catch_uncaught_exceptions.cpp}\par
10778 {\cf20 // start catch_version.cpp}\par
10779 \par
10780 {\cf21 #include <ostream>}\par
10781 \par
10782 {\cf17 namespace }Catch \{\par
10783 \par
10784     Version::Version\par
10785         (   {\cf18 unsigned} {\cf18 int} _majorVersion,\par
10786             {\cf18 unsigned} {\cf18 int} _minorVersion,\par
10787             {\cf18 unsigned} {\cf18 int} _patchNumber,\par
10788             {\cf18 char} {\cf17 const} * {\cf17 const} _branchName,\par
10789             {\cf18 unsigned} {\cf18 int} _buildNumber )\par
10790     :   majorVersion( _majorVersion ),\par
10791         minorVersion( _minorVersion ),\par
10792         patchNumber( _patchNumber ),\par
10793         branchName( _branchName ),\par
10794         buildNumber( _buildNumber )\par
10795     \{\}\par
10796 \par
10797     std::ostream& operator << ( std::ostream& os, Version {\cf17 const}& version ) \{\par
10798         os  << version.majorVersion << {\cf23 '.'}\par
10799             << version.minorVersion << {\cf23 '.'}\par
10800             << version.patchNumber;\par
10801         {\cf20 // branchName is never null -> 0th char is \\0 if it is empty}\par
10802         {\cf19 if} (version.branchName[0]) \{\par
10803             os << {\cf23 '-'} << version.branchName\par
10804                << {\cf23 '.'} << version.buildNumber;\par
10805         \}\par
10806         {\cf19 return} os;\par
10807     \}\par
10808 \par
10809     Version {\cf17 const}& libraryVersion() \{\par
10810         {\cf17 static} Version version( 2, 2, 1, {\cf22 ""}, 0 );\par
10811         {\cf19 return} version;\par
10812     \}\par
10813 \par
10814 \}\par
10815 {\cf20 // end catch_version.cpp}\par
10816 {\cf20 // start catch_wildcard_pattern.cpp}\par
10817 \par
10818 {\cf21 #include <sstream>}\par
10819 \par
10820 {\cf17 namespace }Catch \{\par
10821 \par
10822     WildcardPattern::WildcardPattern( std::string {\cf17 const}& pattern,\par
10823                                       CaseSensitive::Choice caseSensitivity )\par
10824     :   m_caseSensitivity( caseSensitivity ),\par
10825         m_pattern( adjustCase( pattern ) )\par
10826     \{\par
10827         {\cf19 if}( startsWith( m_pattern, {\cf23 '*'} ) ) \{\par
10828             m_pattern = m_pattern.substr( 1 );\par
10829             m_wildcard = WildcardAtStart;\par
10830         \}\par
10831         {\cf19 if}( endsWith( m_pattern, {\cf23 '*'} ) ) \{\par
10832             m_pattern = m_pattern.substr( 0, m_pattern.size()-1 );\par
10833             m_wildcard = {\cf17 static_cast<}WildcardPosition{\cf17 >}( m_wildcard | WildcardAtEnd );\par
10834         \}\par
10835     \}\par
10836 \par
10837     {\cf18 bool} WildcardPattern::matches( std::string {\cf17 const}& str ){\cf17  const }\{\par
10838         {\cf19 switch}( m_wildcard ) \{\par
10839             {\cf19 case} NoWildcard:\par
10840                 {\cf19 return} m_pattern == adjustCase( str );\par
10841             {\cf19 case} WildcardAtStart:\par
10842                 {\cf19 return} endsWith( adjustCase( str ), m_pattern );\par
10843             {\cf19 case} WildcardAtEnd:\par
10844                 {\cf19 return} startsWith( adjustCase( str ), m_pattern );\par
10845             {\cf19 case} WildcardAtBothEnds:\par
10846                 {\cf19 return} contains( adjustCase( str ), m_pattern );\par
10847             {\cf19 default}:\par
10848                 CATCH_INTERNAL_ERROR( {\cf22 "Unknown enum"} );\par
10849         \}\par
10850     \}\par
10851 \par
10852     std::string WildcardPattern::adjustCase( std::string {\cf17 const}& str ){\cf17  const }\{\par
10853         {\cf19 return} m_caseSensitivity == CaseSensitive::No ? toLower( str ) : str;\par
10854     \}\par
10855 \}\par
10856 {\cf20 // end catch_wildcard_pattern.cpp}\par
10857 {\cf20 // start catch_xmlwriter.cpp}\par
10858 \par
10859 {\cf21 #include <iomanip>}\par
10860 \par
10861 {\cf17 namespace }Catch \{\par
10862 \par
10863     XmlEncode::XmlEncode( std::string {\cf17 const}& str, ForWhat forWhat )\par
10864     :   m_str( str ),\par
10865         m_forWhat( forWhat )\par
10866     \{\}\par
10867 \par
10868     {\cf18 void} XmlEncode::encodeTo( std::ostream& os ){\cf17  const }\{\par
10869 \par
10870         {\cf20 // Apostrophe escaping not necessary if we always use " to write attributes}\par
10871         {\cf20 // (see: http://www.w3.org/TR/xml/#syntax)}\par
10872 \par
10873         {\cf19 for}( std::size_t i = 0; i < m_str.size(); ++ i ) \{\par
10874             {\cf18 char} c = m_str[i];\par
10875             {\cf19 switch}( c ) \{\par
10876                 {\cf19 case} {\cf23 '<'}:   os << {\cf22 "&lt;"}; {\cf19 break};\par
10877                 {\cf19 case} {\cf23 '&'}:   os << {\cf22 "&amp;"}; {\cf19 break};\par
10878 \par
10879                 {\cf19 case} {\cf23 '>'}:\par
10880                     {\cf20 // See: http://www.w3.org/TR/xml/#syntax}\par
10881                     {\cf19 if}( i > 2 && m_str[i-1] == {\cf23 ']'} && m_str[i-2] == {\cf23 ']'} )\par
10882                         os << {\cf22 "&gt;"};\par
10883                     {\cf19 else}\par
10884                         os << c;\par
10885                     {\cf19 break};\par
10886 \par
10887                 {\cf19 case} {\cf23 '\\"'}:\par
10888                     {\cf19 if}( m_forWhat == ForAttributes )\par
10889                         os << {\cf22 "&quot;"};\par
10890                     {\cf19 else}\par
10891                         os << c;\par
10892                     {\cf19 break};\par
10893 \par
10894                 {\cf19 default}:\par
10895                     {\cf20 // Escape control chars - based on contribution by @espenalb in PR #465 and}\par
10896                     {\cf20 // by @mrpi PR #588}\par
10897                     {\cf19 if} ( ( c >= 0 && c < {\cf22 '\\x09'} ) || ( c > {\cf22 '\\x0D'} && c < {\cf22 '\\x20'}) || c=={\cf22 '\\x7F'} ) \{\par
10898                         {\cf20 // see http://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0}\par
10899                         os << {\cf22 "\\\\x"} << std::uppercase << std::hex << std::setfill({\cf23 '0'}) << std::setw(2)\par
10900                            << {\cf17 static_cast<}{\cf18 int}{\cf17 >}( c );\par
10901                     \}\par
10902                     {\cf19 else}\par
10903                         os << c;\par
10904             \}\par
10905         \}\par
10906     \}\par
10907 \par
10908     std::ostream& operator << ( std::ostream& os, XmlEncode {\cf17 const}& xmlEncode ) \{\par
10909         xmlEncode.encodeTo( os );\par
10910         {\cf19 return} os;\par
10911     \}\par
10912 \par
10913     XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer )\par
10914     :   m_writer( writer )\par
10915     \{\}\par
10916 \par
10917     XmlWriter::ScopedElement::ScopedElement( ScopedElement&& other ) noexcept\par
10918     :   m_writer( other.m_writer )\{\par
10919         other.m_writer = {\cf17 nullptr};\par
10920     \}\par
10921     XmlWriter::ScopedElement& XmlWriter::ScopedElement::operator=( ScopedElement&& other ) {\cf17 noexcept} \{\par
10922         {\cf19 if} ( m_writer ) \{\par
10923             m_writer->endElement();\par
10924         \}\par
10925         m_writer = other.m_writer;\par
10926         other.m_writer = {\cf17 nullptr};\par
10927         {\cf19 return} *{\cf17 this};\par
10928     \}\par
10929 \par
10930     XmlWriter::ScopedElement::~ScopedElement() \{\par
10931         {\cf19 if}( m_writer )\par
10932             m_writer->endElement();\par
10933     \}\par
10934 \par
10935     XmlWriter::ScopedElement& XmlWriter::ScopedElement::writeText( std::string {\cf17 const}& text, {\cf18 bool} indent ) \{\par
10936         m_writer->writeText( text, indent );\par
10937         {\cf19 return} *{\cf17 this};\par
10938     \}\par
10939 \par
10940     XmlWriter::XmlWriter( std::ostream& os ) : m_os( os )\par
10941     \{\par
10942         writeDeclaration();\par
10943     \}\par
10944 \par
10945     XmlWriter::~XmlWriter() \{\par
10946         {\cf19 while}( !m_tags.empty() )\par
10947             endElement();\par
10948     \}\par
10949 \par
10950     XmlWriter& XmlWriter::startElement( std::string {\cf17 const}& name ) \{\par
10951         ensureTagClosed();\par
10952         newlineIfNecessary();\par
10953         m_os << m_indent << {\cf23 '<'} << name;\par
10954         m_tags.push_back( name );\par
10955         m_indent += "  ";\par
10956         m_tagIsOpen = {\cf17 true};\par
10957         {\cf19 return} *{\cf17 this};\par
10958     \}\par
10959 \par
10960     XmlWriter::ScopedElement XmlWriter::scopedElement( std::string {\cf17 const}& name ) \{\par
10961         ScopedElement scoped( {\cf17 this} );\par
10962         startElement( name );\par
10963         {\cf19 return} scoped;\par
10964     \}\par
10965 \par
10966     XmlWriter& XmlWriter::endElement() \{\par
10967         newlineIfNecessary();\par
10968         m_indent = m_indent.substr( 0, m_indent.size()-2 );\par
10969         {\cf19 if}( m_tagIsOpen ) \{\par
10970             m_os << {\cf22 "/>"};\par
10971             m_tagIsOpen = {\cf17 false};\par
10972         \}\par
10973         {\cf19 else} \{\par
10974             m_os << m_indent << {\cf22 "</"} << m_tags.back() << {\cf22 ">"};\par
10975         \}\par
10976         m_os << std::endl;\par
10977         m_tags.pop_back();\par
10978         {\cf19 return} *{\cf17 this};\par
10979     \}\par
10980 \par
10981     XmlWriter& XmlWriter::writeAttribute( std::string {\cf17 const}& name, std::string {\cf17 const}& attribute ) \{\par
10982         {\cf19 if}( !name.empty() && !attribute.empty() )\par
10983             m_os << {\cf23 ' '} << name << {\cf22 "=\\""} << XmlEncode( attribute, XmlEncode::ForAttributes ) << {\cf23 '"'};\par
10984         {\cf19 return} *{\cf17 this};\par
10985     \}\par
10986 \par
10987     XmlWriter& XmlWriter::writeAttribute( std::string {\cf17 const}& name, {\cf18 bool} attribute ) \{\par
10988         m_os << {\cf23 ' '} << name << {\cf22 "=\\""} << ( attribute ? {\cf22 "true"} : {\cf22 "false"} ) << {\cf23 '"'};\par
10989         {\cf19 return} *{\cf17 this};\par
10990     \}\par
10991 \par
10992     XmlWriter& XmlWriter::writeText( std::string {\cf17 const}& text, {\cf18 bool} indent ) \{\par
10993         {\cf19 if}( !text.empty() )\{\par
10994             {\cf18 bool} tagWasOpen = m_tagIsOpen;\par
10995             ensureTagClosed();\par
10996             {\cf19 if}( tagWasOpen && indent )\par
10997                 m_os << m_indent;\par
10998             m_os << XmlEncode( text );\par
10999             m_needsNewline = {\cf17 true};\par
11000         \}\par
11001         {\cf19 return} *{\cf17 this};\par
11002     \}\par
11003 \par
11004     XmlWriter& XmlWriter::writeComment( std::string {\cf17 const}& text ) \{\par
11005         ensureTagClosed();\par
11006         m_os << m_indent << {\cf22 "<!--"} << text << {\cf22 "-->"};\par
11007         m_needsNewline = {\cf17 true};\par
11008         {\cf19 return} *{\cf17 this};\par
11009     \}\par
11010 \par
11011     {\cf18 void} XmlWriter::writeStylesheetRef( std::string {\cf17 const}& url ) \{\par
11012         m_os << {\cf22 "<?xml-stylesheet type=\\"text/xsl\\" href=\\""} << url << {\cf22 "\\"?>\\n"};\par
11013     \}\par
11014 \par
11015     XmlWriter& XmlWriter::writeBlankLine() \{\par
11016         ensureTagClosed();\par
11017         m_os << {\cf23 '\\n'};\par
11018         {\cf19 return} *{\cf17 this};\par
11019     \}\par
11020 \par
11021     {\cf18 void} XmlWriter::ensureTagClosed() \{\par
11022         {\cf19 if}( m_tagIsOpen ) \{\par
11023             m_os << {\cf22 ">"} << std::endl;\par
11024             m_tagIsOpen = {\cf17 false};\par
11025         \}\par
11026     \}\par
11027 \par
11028     {\cf18 void} XmlWriter::writeDeclaration() \{\par
11029         m_os << {\cf22 "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>\\n"};\par
11030     \}\par
11031 \par
11032     {\cf18 void} XmlWriter::newlineIfNecessary() \{\par
11033         {\cf19 if}( m_needsNewline ) \{\par
11034             m_os << std::endl;\par
11035             m_needsNewline = {\cf17 false};\par
11036         \}\par
11037     \}\par
11038 \}\par
11039 {\cf20 // end catch_xmlwriter.cpp}\par
11040 {\cf20 // start catch_reporter_bases.cpp}\par
11041 \par
11042 {\cf21 #include <cstring>}\par
11043 {\cf21 #include <cfloat>}\par
11044 {\cf21 #include <cstdio>}\par
11045 {\cf21 #include <assert.h>}\par
11046 {\cf21 #include <memory>}\par
11047 \par
11048 {\cf17 namespace }Catch \{\par
11049     {\cf18 void} prepareExpandedExpression(AssertionResult& result) \{\par
11050         result.getExpandedExpression();\par
11051     \}\par
11052 \par
11053     {\cf20 // Because formatting using c++ streams is stateful, drop down to C is required}\par
11054     {\cf20 // Alternatively we could use stringstream, but its performance is... not good.}\par
11055     std::string getFormattedDuration( {\cf18 double} duration ) \{\par
11056         {\cf20 // Max exponent + 1 is required to represent the whole part}\par
11057         {\cf20 // + 1 for decimal point}\par
11058         {\cf20 // + 3 for the 3 decimal places}\par
11059         {\cf20 // + 1 for null terminator}\par
11060         {\cf17 const} std::size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;\par
11061         {\cf18 char} buffer[maxDoubleSize];\par
11062 \par
11063         {\cf20 // Save previous errno, to prevent sprintf from overwriting it}\par
11064         ErrnoGuard guard;\par
11065 {\cf21 #ifdef _MSC_VER}\par
11066         sprintf_s(buffer, {\cf22 "%.3f"}, duration);\par
11067 {\cf21 #else}\par
11068         sprintf(buffer, {\cf22 "%.3f"}, duration);\par
11069 {\cf21 #endif}\par
11070         {\cf19 return} std::string(buffer);\par
11071     \}\par
11072 \par
11073     TestEventListenerBase::TestEventListenerBase(ReporterConfig {\cf17 const} & _config)\par
11074         :StreamingReporterBase(_config) \{\}\par
11075 \par
11076     {\cf18 void} TestEventListenerBase::assertionStarting(AssertionInfo {\cf17 const} &) \{\}\par
11077 \par
11078     {\cf18 bool} TestEventListenerBase::assertionEnded(AssertionStats {\cf17 const} &) \{\par
11079         {\cf19 return} {\cf17 false};\par
11080     \}\par
11081 \par
11082 \} {\cf20 // end namespace Catch}\par
11083 {\cf20 // end catch_reporter_bases.cpp}\par
11084 {\cf20 // start catch_reporter_compact.cpp}\par
11085 \par
11086 {\cf17 namespace }\{\par
11087 \par
11088 {\cf21 #ifdef CATCH_PLATFORM_MAC}\par
11089     {\cf17 const} {\cf18 char}* failedString() \{ {\cf19 return} {\cf22 "FAILED"}; \}\par
11090     {\cf17 const} {\cf18 char}* passedString() \{ {\cf19 return} {\cf22 "PASSED"}; \}\par
11091 {\cf21 #else}\par
11092     {\cf17 const} {\cf18 char}* failedString() \{ {\cf19 return} {\cf22 "failed"}; \}\par
11093     {\cf17 const} {\cf18 char}* passedString() \{ {\cf19 return} {\cf22 "passed"}; \}\par
11094 {\cf21 #endif}\par
11095 \par
11096     {\cf20 // Colour::LightGrey}\par
11097     Catch::Colour::Code dimColour() \{ {\cf19 return} Catch::Colour::FileName; \}\par
11098 \par
11099     std::string bothOrAll( std::size_t count ) \{\par
11100         {\cf19 return} count == 1 ? std::string() :\par
11101                count == 2 ? {\cf22 "both "} : {\cf22 "all "} ;\par
11102     \}\par
11103 \par
11104 \} {\cf20 // anon namespace}\par
11105 \par
11106 {\cf17 namespace }Catch \{\par
11107 {\cf17 namespace }\{\par
11108 {\cf20 // Colour, message variants:}\par
11109 {\cf20 // - white: No tests ran.}\par
11110 {\cf20 // -   red: Failed [both/all] N test cases, failed [both/all] M assertions.}\par
11111 {\cf20 // - white: Passed [both/all] N test cases (no assertions).}\par
11112 {\cf20 // -   red: Failed N tests cases, failed M assertions.}\par
11113 {\cf20 // - green: Passed [both/all] N tests cases with M assertions.}\par
11114 {\cf18 void} printTotals(std::ostream& out, {\cf17 const} Totals& totals) \{\par
11115     {\cf19 if} (totals.testCases.total() == 0) \{\par
11116         out << {\cf22 "No tests ran."};\par
11117     \} {\cf19 else} {\cf19 if} (totals.testCases.failed == totals.testCases.total()) \{\par
11118         Colour colour(Colour::ResultError);\par
11119         {\cf17 const} std::string qualify_assertions_failed =\par
11120             totals.assertions.failed == totals.assertions.total() ?\par
11121             bothOrAll(totals.assertions.failed) : std::string();\par
11122         out <<\par
11123             {\cf22 "Failed "} << bothOrAll(totals.testCases.failed)\par
11124             << pluralise(totals.testCases.failed, {\cf22 "test case"}) << {\cf22 ", "}\par
11125             {\cf22 "failed "} << qualify_assertions_failed <<\par
11126             pluralise(totals.assertions.failed, {\cf22 "assertion"}) << {\cf23 '.'};\par
11127     \} {\cf19 else} {\cf19 if} (totals.assertions.total() == 0) \{\par
11128         out <<\par
11129             {\cf22 "Passed "} << bothOrAll(totals.testCases.total())\par
11130             << pluralise(totals.testCases.total(), {\cf22 "test case"})\par
11131             << {\cf22 " (no assertions)."};\par
11132     \} {\cf19 else} {\cf19 if} (totals.assertions.failed) \{\par
11133         Colour colour(Colour::ResultError);\par
11134         out <<\par
11135             {\cf22 "Failed "} << pluralise(totals.testCases.failed, {\cf22 "test case"}) << {\cf22 ", "}\par
11136             {\cf22 "failed "} << pluralise(totals.assertions.failed, {\cf22 "assertion"}) << {\cf23 '.'};\par
11137     \} {\cf19 else} \{\par
11138         Colour colour(Colour::ResultSuccess);\par
11139         out <<\par
11140             {\cf22 "Passed "} << bothOrAll(totals.testCases.passed)\par
11141             << pluralise(totals.testCases.passed, {\cf22 "test case"}) <<\par
11142             {\cf22 " with "} << pluralise(totals.assertions.passed, {\cf22 "assertion"}) << {\cf23 '.'};\par
11143     \}\par
11144 \}\par
11145 \par
11146 {\cf20 // Implementation of CompactReporter formatting}\par
11147 {\cf17 class }AssertionPrinter \{\par
11148 {\cf17 public}:\par
11149     AssertionPrinter& operator= (AssertionPrinter {\cf17 const}&) = {\cf17 delete};\par
11150     AssertionPrinter(AssertionPrinter {\cf17 const}&) = {\cf17 delete};\par
11151     AssertionPrinter(std::ostream& _stream, AssertionStats {\cf17 const}& _stats, {\cf18 bool} _printInfoMessages)\par
11152         : stream(_stream)\par
11153         , result(_stats.assertionResult)\par
11154         , messages(_stats.infoMessages)\par
11155         , itMessage(_stats.infoMessages.begin())\par
11156         , printInfoMessages(_printInfoMessages) \{\}\par
11157 \par
11158     {\cf18 void} print() \{\par
11159         printSourceInfo();\par
11160 \par
11161         itMessage = messages.begin();\par
11162 \par
11163         {\cf19 switch} (result.getResultType()) \{\par
11164         {\cf19 case} ResultWas::Ok:\par
11165             printResultType(Colour::ResultSuccess, passedString());\par
11166             printOriginalExpression();\par
11167             printReconstructedExpression();\par
11168             {\cf19 if} (!result.hasExpression())\par
11169                 printRemainingMessages(Colour::None);\par
11170             {\cf19 else}\par
11171                 printRemainingMessages();\par
11172             {\cf19 break};\par
11173         {\cf19 case} ResultWas::ExpressionFailed:\par
11174             {\cf19 if} (result.isOk())\par
11175                 printResultType(Colour::ResultSuccess, failedString() + std::string({\cf22 " - but was ok"}));\par
11176             {\cf19 else}\par
11177                 printResultType(Colour::Error, failedString());\par
11178             printOriginalExpression();\par
11179             printReconstructedExpression();\par
11180             printRemainingMessages();\par
11181             {\cf19 break};\par
11182         {\cf19 case} ResultWas::ThrewException:\par
11183             printResultType(Colour::Error, failedString());\par
11184             printIssue({\cf22 "unexpected exception with message:"});\par
11185             printMessage();\par
11186             printExpressionWas();\par
11187             printRemainingMessages();\par
11188             {\cf19 break};\par
11189         {\cf19 case} ResultWas::FatalErrorCondition:\par
11190             printResultType(Colour::Error, failedString());\par
11191             printIssue({\cf22 "fatal error condition with message:"});\par
11192             printMessage();\par
11193             printExpressionWas();\par
11194             printRemainingMessages();\par
11195             {\cf19 break};\par
11196         {\cf19 case} ResultWas::DidntThrowException:\par
11197             printResultType(Colour::Error, failedString());\par
11198             printIssue({\cf22 "expected exception, got none"});\par
11199             printExpressionWas();\par
11200             printRemainingMessages();\par
11201             {\cf19 break};\par
11202         {\cf19 case} ResultWas::Info:\par
11203             printResultType(Colour::None, {\cf22 "info"});\par
11204             printMessage();\par
11205             printRemainingMessages();\par
11206             {\cf19 break};\par
11207         {\cf19 case} ResultWas::Warning:\par
11208             printResultType(Colour::None, {\cf22 "warning"});\par
11209             printMessage();\par
11210             printRemainingMessages();\par
11211             {\cf19 break};\par
11212         {\cf19 case} ResultWas::ExplicitFailure:\par
11213             printResultType(Colour::Error, failedString());\par
11214             printIssue({\cf22 "explicitly"});\par
11215             printRemainingMessages(Colour::None);\par
11216             {\cf19 break};\par
11217             {\cf20 // These cases are here to prevent compiler warnings}\par
11218         {\cf19 case} ResultWas::Unknown:\par
11219         {\cf19 case} ResultWas::FailureBit:\par
11220         {\cf19 case} ResultWas::Exception:\par
11221             printResultType(Colour::Error, {\cf22 "** internal error **"});\par
11222             {\cf19 break};\par
11223         \}\par
11224     \}\par
11225 \par
11226 {\cf17 private}:\par
11227     {\cf18 void} printSourceInfo(){\cf17  const }\{\par
11228         Colour colourGuard(Colour::FileName);\par
11229         stream << result.getSourceInfo() << {\cf23 ':'};\par
11230     \}\par
11231 \par
11232     {\cf18 void} printResultType(Colour::Code colour, std::string {\cf17 const}& passOrFail){\cf17  const }\{\par
11233         {\cf19 if} (!passOrFail.empty()) \{\par
11234             \{\par
11235                 Colour colourGuard(colour);\par
11236                 stream << {\cf23 ' '} << passOrFail;\par
11237             \}\par
11238             stream << {\cf23 ':'};\par
11239         \}\par
11240     \}\par
11241 \par
11242     {\cf18 void} printIssue(std::string {\cf17 const}& issue){\cf17  const }\{\par
11243         stream << {\cf23 ' '} << issue;\par
11244     \}\par
11245 \par
11246     {\cf18 void} printExpressionWas() \{\par
11247         {\cf19 if} (result.hasExpression()) \{\par
11248             stream << {\cf23 ';'};\par
11249             \{\par
11250                 Colour colour(dimColour());\par
11251                 stream << {\cf22 " expression was:"};\par
11252             \}\par
11253             printOriginalExpression();\par
11254         \}\par
11255     \}\par
11256 \par
11257     {\cf18 void} printOriginalExpression(){\cf17  const }\{\par
11258         {\cf19 if} (result.hasExpression()) \{\par
11259             stream << {\cf23 ' '} << result.getExpression();\par
11260         \}\par
11261     \}\par
11262 \par
11263     {\cf18 void} printReconstructedExpression(){\cf17  const }\{\par
11264         {\cf19 if} (result.hasExpandedExpression()) \{\par
11265             \{\par
11266                 Colour colour(dimColour());\par
11267                 stream << {\cf22 " for: "};\par
11268             \}\par
11269             stream << result.getExpandedExpression();\par
11270         \}\par
11271     \}\par
11272 \par
11273     {\cf18 void} printMessage() \{\par
11274         {\cf19 if} (itMessage != messages.end()) \{\par
11275             stream << {\cf22 " '"} << itMessage->message << {\cf23 '\\''};\par
11276             ++itMessage;\par
11277         \}\par
11278     \}\par
11279 \par
11280     {\cf18 void} printRemainingMessages(Colour::Code colour = dimColour()) \{\par
11281         {\cf19 if} (itMessage == messages.end())\par
11282             {\cf19 return};\par
11283 \par
11284         {\cf20 // using messages.end() directly yields (or auto) compilation error:}\par
11285         std::vector<MessageInfo>::const_iterator itEnd = messages.end();\par
11286         {\cf17 const} std::size_t N = {\cf17 static_cast<}std::size_t{\cf17 >}(std::distance(itMessage, itEnd));\par
11287 \par
11288         \{\par
11289             Colour colourGuard(colour);\par
11290             stream << {\cf22 " with "} << pluralise(N, {\cf22 "message"}) << {\cf23 ':'};\par
11291         \}\par
11292 \par
11293         {\cf19 for} (; itMessage != itEnd; ) \{\par
11294             {\cf20 // If this assertion is a warning ignore any INFO messages}\par
11295             {\cf19 if} (printInfoMessages || itMessage->type != ResultWas::Info) \{\par
11296                 stream << {\cf22 " '"} << itMessage->message << {\cf23 '\\''};\par
11297                 {\cf19 if} (++itMessage != itEnd) \{\par
11298                     Colour colourGuard(dimColour());\par
11299                     stream << {\cf22 " and"};\par
11300                 \}\par
11301             \}\par
11302         \}\par
11303     \}\par
11304 \par
11305 {\cf17 private}:\par
11306     std::ostream& stream;\par
11307     AssertionResult {\cf17 const}& result;\par
11308     std::vector<MessageInfo> messages;\par
11309     std::vector<MessageInfo>::const_iterator itMessage;\par
11310     {\cf18 bool} printInfoMessages;\par
11311 \};\par
11312 \par
11313 \} {\cf20 // anon namespace}\par
11314 \par
11315         std::string CompactReporter::getDescription() \{\par
11316             {\cf19 return} {\cf22 "Reports test results on a single line, suitable for IDEs"};\par
11317         \}\par
11318 \par
11319         ReporterPreferences CompactReporter::getPreferences(){\cf17  const }\{\par
11320             ReporterPreferences prefs;\par
11321             prefs.shouldRedirectStdOut = {\cf17 false};\par
11322             {\cf19 return} prefs;\par
11323         \}\par
11324 \par
11325         {\cf18 void} CompactReporter::noMatchingTestCases( std::string {\cf17 const}& spec ) \{\par
11326             stream << {\cf22 "No test cases matched '"} << spec << {\cf23 '\\''} << std::endl;\par
11327         \}\par
11328 \par
11329         {\cf18 void} CompactReporter::assertionStarting( AssertionInfo {\cf17 const}& ) \{\}\par
11330 \par
11331         {\cf18 bool} CompactReporter::assertionEnded( AssertionStats {\cf17 const}& _assertionStats ) \{\par
11332             AssertionResult {\cf17 const}& result = _assertionStats.assertionResult;\par
11333 \par
11334             {\cf18 bool} printInfoMessages = {\cf17 true};\par
11335 \par
11336             {\cf20 // Drop out if result was successful and we're not printing those}\par
11337             {\cf19 if}( !m_config->includeSuccessfulResults() && result.isOk() ) \{\par
11338                 {\cf19 if}( result.getResultType() != ResultWas::Warning )\par
11339                     {\cf19 return} {\cf17 false};\par
11340                 printInfoMessages = {\cf17 false};\par
11341             \}\par
11342 \par
11343             AssertionPrinter printer( stream, _assertionStats, printInfoMessages );\par
11344             printer.print();\par
11345 \par
11346             stream << std::endl;\par
11347             {\cf19 return} {\cf17 true};\par
11348         \}\par
11349 \par
11350         {\cf18 void} CompactReporter::sectionEnded(SectionStats {\cf17 const}& _sectionStats) \{\par
11351             {\cf19 if} (m_config->showDurations() == ShowDurations::Always) \{\par
11352                 stream << getFormattedDuration(_sectionStats.durationInSeconds) << {\cf22 " s: "} << _sectionStats.sectionInfo.name << std::endl;\par
11353             \}\par
11354         \}\par
11355 \par
11356         {\cf18 void} CompactReporter::testRunEnded( TestRunStats {\cf17 const}& _testRunStats ) \{\par
11357             printTotals( stream, _testRunStats.totals );\par
11358             stream << {\cf23 '\\n'} << std::endl;\par
11359             StreamingReporterBase::testRunEnded( _testRunStats );\par
11360         \}\par
11361 \par
11362         CompactReporter::~CompactReporter() \{\}\par
11363 \par
11364     CATCH_REGISTER_REPORTER( {\cf22 "compact"}, CompactReporter )\par
11365 \par
11366 \} {\cf20 // end namespace Catch}\par
11367 {\cf20 // end catch_reporter_compact.cpp}\par
11368 {\cf20 // start catch_reporter_console.cpp}\par
11369 \par
11370 {\cf21 #include <cfloat>}\par
11371 {\cf21 #include <cstdio>}\par
11372 \par
11373 {\cf21 #if defined(_MSC_VER)}\par
11374 {\cf21 #pragma warning(push)}\par
11375 {\cf21 #pragma warning(disable:4061) }{\cf20 // Not all labels are EXPLICITLY handled in switch}\par
11376  {\cf20 // Note that 4062 (not all labels are handled}\par
11377  {\cf20 // and default is missing) is enabled}\par
11378 {\cf21 #endif}\par
11379 \par
11380 {\cf17 namespace }Catch \{\par
11381 \par
11382 {\cf17 namespace }\{\par
11383 \par
11384 {\cf20 // Formatter impl for ConsoleReporter}\par
11385 {\cf17 class }ConsoleAssertionPrinter \{\par
11386 {\cf17 public}:\par
11387     ConsoleAssertionPrinter& operator= (ConsoleAssertionPrinter {\cf17 const}&) = {\cf17 delete};\par
11388     ConsoleAssertionPrinter(ConsoleAssertionPrinter {\cf17 const}&) = {\cf17 delete};\par
11389     ConsoleAssertionPrinter(std::ostream& _stream, AssertionStats {\cf17 const}& _stats, {\cf18 bool} _printInfoMessages)\par
11390         : stream(_stream),\par
11391         stats(_stats),\par
11392         result(_stats.assertionResult),\par
11393         colour(Colour::None),\par
11394         message(result.getMessage()),\par
11395         messages(_stats.infoMessages),\par
11396         printInfoMessages(_printInfoMessages) \{\par
11397         {\cf19 switch} (result.getResultType()) \{\par
11398         {\cf19 case} ResultWas::Ok:\par
11399             colour = Colour::Success;\par
11400             passOrFail = {\cf22 "PASSED"};\par
11401             {\cf20 //if( result.hasMessage() )}\par
11402             {\cf19 if} (_stats.infoMessages.size() == 1)\par
11403                 messageLabel = {\cf22 "with message"};\par
11404             {\cf19 if} (_stats.infoMessages.size() > 1)\par
11405                 messageLabel = {\cf22 "with messages"};\par
11406             {\cf19 break};\par
11407         {\cf19 case} ResultWas::ExpressionFailed:\par
11408             {\cf19 if} (result.isOk()) \{\par
11409                 colour = Colour::Success;\par
11410                 passOrFail = {\cf22 "FAILED - but was ok"};\par
11411             \} {\cf19 else} \{\par
11412                 colour = Colour::Error;\par
11413                 passOrFail = {\cf22 "FAILED"};\par
11414             \}\par
11415             {\cf19 if} (_stats.infoMessages.size() == 1)\par
11416                 messageLabel = {\cf22 "with message"};\par
11417             {\cf19 if} (_stats.infoMessages.size() > 1)\par
11418                 messageLabel = {\cf22 "with messages"};\par
11419             {\cf19 break};\par
11420         {\cf19 case} ResultWas::ThrewException:\par
11421             colour = Colour::Error;\par
11422             passOrFail = {\cf22 "FAILED"};\par
11423             messageLabel = {\cf22 "due to unexpected exception with "};\par
11424             {\cf19 if} (_stats.infoMessages.size() == 1)\par
11425                 messageLabel += "message";\par
11426             {\cf19 if} (_stats.infoMessages.size() > 1)\par
11427                 messageLabel += "messages";\par
11428             {\cf19 break};\par
11429         {\cf19 case} ResultWas::FatalErrorCondition:\par
11430             colour = Colour::Error;\par
11431             passOrFail = {\cf22 "FAILED"};\par
11432             messageLabel = {\cf22 "due to a fatal error condition"};\par
11433             {\cf19 break};\par
11434         {\cf19 case} ResultWas::DidntThrowException:\par
11435             colour = Colour::Error;\par
11436             passOrFail = {\cf22 "FAILED"};\par
11437             messageLabel = {\cf22 "because no exception was thrown where one was expected"};\par
11438             {\cf19 break};\par
11439         {\cf19 case} ResultWas::Info:\par
11440             messageLabel = {\cf22 "info"};\par
11441             {\cf19 break};\par
11442         {\cf19 case} ResultWas::Warning:\par
11443             messageLabel = {\cf22 "warning"};\par
11444             {\cf19 break};\par
11445         {\cf19 case} ResultWas::ExplicitFailure:\par
11446             passOrFail = {\cf22 "FAILED"};\par
11447             colour = Colour::Error;\par
11448             {\cf19 if} (_stats.infoMessages.size() == 1)\par
11449                 messageLabel = {\cf22 "explicitly with message"};\par
11450             {\cf19 if} (_stats.infoMessages.size() > 1)\par
11451                 messageLabel = {\cf22 "explicitly with messages"};\par
11452             {\cf19 break};\par
11453             {\cf20 // These cases are here to prevent compiler warnings}\par
11454         {\cf19 case} ResultWas::Unknown:\par
11455         {\cf19 case} ResultWas::FailureBit:\par
11456         {\cf19 case} ResultWas::Exception:\par
11457             passOrFail = {\cf22 "** internal error **"};\par
11458             colour = Colour::Error;\par
11459             {\cf19 break};\par
11460         \}\par
11461     \}\par
11462 \par
11463     {\cf18 void} print(){\cf17  const }\{\par
11464         printSourceInfo();\par
11465         {\cf19 if} (stats.totals.assertions.total() > 0) \{\par
11466             {\cf19 if} (result.isOk())\par
11467                 stream << {\cf23 '\\n'};\par
11468             printResultType();\par
11469             printOriginalExpression();\par
11470             printReconstructedExpression();\par
11471         \} {\cf19 else} \{\par
11472             stream << {\cf23 '\\n'};\par
11473         \}\par
11474         printMessage();\par
11475     \}\par
11476 \par
11477 {\cf17 private}:\par
11478     {\cf18 void} printResultType(){\cf17  const }\{\par
11479         {\cf19 if} (!passOrFail.empty()) \{\par
11480             Colour colourGuard(colour);\par
11481             stream << passOrFail << {\cf22 ":\\n"};\par
11482         \}\par
11483     \}\par
11484     {\cf18 void} printOriginalExpression(){\cf17  const }\{\par
11485         {\cf19 if} (result.hasExpression()) \{\par
11486             Colour colourGuard(Colour::OriginalExpression);\par
11487             stream << {\cf22 "  "};\par
11488             stream << result.getExpressionInMacro();\par
11489             stream << {\cf23 '\\n'};\par
11490         \}\par
11491     \}\par
11492     {\cf18 void} printReconstructedExpression(){\cf17  const }\{\par
11493         {\cf19 if} (result.hasExpandedExpression()) \{\par
11494             stream << {\cf22 "with expansion:\\n"};\par
11495             Colour colourGuard(Colour::ReconstructedExpression);\par
11496             stream << Column(result.getExpandedExpression()).indent(2) << {\cf23 '\\n'};\par
11497         \}\par
11498     \}\par
11499     {\cf18 void} printMessage(){\cf17  const }\{\par
11500         {\cf19 if} (!messageLabel.empty())\par
11501             stream << messageLabel << {\cf23 ':'} << {\cf23 '\\n'};\par
11502         {\cf19 for} ({\cf17 auto} {\cf17 const}& msg : messages) \{\par
11503             {\cf20 // If this assertion is a warning ignore any INFO messages}\par
11504             {\cf19 if} (printInfoMessages || msg.type != ResultWas::Info)\par
11505                 stream << Column(msg.message).indent(2) << {\cf23 '\\n'};\par
11506         \}\par
11507     \}\par
11508     {\cf18 void} printSourceInfo(){\cf17  const }\{\par
11509         Colour colourGuard(Colour::FileName);\par
11510         stream << result.getSourceInfo() << {\cf22 ": "};\par
11511     \}\par
11512 \par
11513     std::ostream& stream;\par
11514     AssertionStats {\cf17 const}& stats;\par
11515     AssertionResult {\cf17 const}& result;\par
11516     Colour::Code colour;\par
11517     std::string passOrFail;\par
11518     std::string messageLabel;\par
11519     std::string message;\par
11520     std::vector<MessageInfo> messages;\par
11521     {\cf18 bool} printInfoMessages;\par
11522 \};\par
11523 \par
11524 std::size_t makeRatio(std::size_t number, std::size_t total) \{\par
11525     std::size_t ratio = total > 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number / total : 0;\par
11526     {\cf19 return} (ratio == 0 && number > 0) ? 1 : ratio;\par
11527 \}\par
11528 \par
11529 std::size_t& findMax(std::size_t& i, std::size_t& j, std::size_t& k) \{\par
11530     {\cf19 if} (i > j && i > k)\par
11531         {\cf19 return} i;\par
11532     {\cf19 else} {\cf19 if} (j > k)\par
11533         {\cf19 return} j;\par
11534     {\cf19 else}\par
11535         {\cf19 return} k;\par
11536 \}\par
11537 \par
11538 {\cf17 struct }ColumnInfo \{\par
11539     {\cf17 enum} Justification \{ Left, Right \};\par
11540     std::string name;\par
11541     {\cf18 int} width;\par
11542     Justification justification;\par
11543 \};\par
11544 {\cf17 struct }ColumnBreak \{\};\par
11545 {\cf17 struct }RowBreak \{\};\par
11546 \par
11547 {\cf17 class }Duration \{\par
11548     {\cf17 enum class} Unit \{\par
11549         Auto,\par
11550         Nanoseconds,\par
11551         Microseconds,\par
11552         Milliseconds,\par
11553         Seconds,\par
11554         Minutes\par
11555     \};\par
11556     {\cf17 static} {\cf17 const} uint64_t s_nanosecondsInAMicrosecond = 1000;\par
11557     {\cf17 static} {\cf17 const} uint64_t s_nanosecondsInAMillisecond = 1000 * s_nanosecondsInAMicrosecond;\par
11558     {\cf17 static} {\cf17 const} uint64_t s_nanosecondsInASecond = 1000 * s_nanosecondsInAMillisecond;\par
11559     {\cf17 static} {\cf17 const} uint64_t s_nanosecondsInAMinute = 60 * s_nanosecondsInASecond;\par
11560 \par
11561     uint64_t m_inNanoseconds;\par
11562     Unit m_units;\par
11563 \par
11564 {\cf17 public}:\par
11565     {\cf17 explicit} Duration(uint64_t inNanoseconds, Unit units = Unit::Auto)\par
11566         : m_inNanoseconds(inNanoseconds),\par
11567         m_units(units) \{\par
11568         {\cf19 if} (m_units == Unit::Auto) \{\par
11569             {\cf19 if} (m_inNanoseconds < s_nanosecondsInAMicrosecond)\par
11570                 m_units = Unit::Nanoseconds;\par
11571             {\cf19 else} {\cf19 if} (m_inNanoseconds < s_nanosecondsInAMillisecond)\par
11572                 m_units = Unit::Microseconds;\par
11573             {\cf19 else} {\cf19 if} (m_inNanoseconds < s_nanosecondsInASecond)\par
11574                 m_units = Unit::Milliseconds;\par
11575             {\cf19 else} {\cf19 if} (m_inNanoseconds < s_nanosecondsInAMinute)\par
11576                 m_units = Unit::Seconds;\par
11577             {\cf19 else}\par
11578                 m_units = Unit::Minutes;\par
11579         \}\par
11580 \par
11581     \}\par
11582 \par
11583     {\cf17 auto} value() const -> {\cf18 double} \{\par
11584         {\cf19 switch} (m_units) \{\par
11585         {\cf19 case} Unit::Microseconds:\par
11586             {\cf19 return} m_inNanoseconds / {\cf17 static_cast<}{\cf18 double}{\cf17 >}(s_nanosecondsInAMicrosecond);\par
11587         {\cf19 case} Unit::Milliseconds:\par
11588             {\cf19 return} m_inNanoseconds / {\cf17 static_cast<}{\cf18 double}{\cf17 >}(s_nanosecondsInAMillisecond);\par
11589         {\cf19 case} Unit::Seconds:\par
11590             {\cf19 return} m_inNanoseconds / {\cf17 static_cast<}{\cf18 double}{\cf17 >}(s_nanosecondsInASecond);\par
11591         {\cf19 case} Unit::Minutes:\par
11592             {\cf19 return} m_inNanoseconds / {\cf17 static_cast<}{\cf18 double}{\cf17 >}(s_nanosecondsInAMinute);\par
11593         {\cf19 default}:\par
11594             {\cf19 return} {\cf17 static_cast<}{\cf18 double}{\cf17 >}(m_inNanoseconds);\par
11595         \}\par
11596     \}\par
11597     {\cf17 auto} unitsAsString() const -> std::{\cf18 string} \{\par
11598         {\cf19 switch} (m_units) \{\par
11599         {\cf19 case} Unit::Nanoseconds:\par
11600             {\cf19 return} {\cf22 "ns"};\par
11601         {\cf19 case} Unit::Microseconds:\par
11602             {\cf19 return} {\cf22 "\'B5s"};\par
11603         {\cf19 case} Unit::Milliseconds:\par
11604             {\cf19 return} {\cf22 "ms"};\par
11605         {\cf19 case} Unit::Seconds:\par
11606             {\cf19 return} {\cf22 "s"};\par
11607         {\cf19 case} Unit::Minutes:\par
11608             {\cf19 return} {\cf22 "m"};\par
11609         {\cf19 default}:\par
11610             {\cf19 return} {\cf22 "** internal error **"};\par
11611         \}\par
11612 \par
11613     \}\par
11614     {\cf17 friend} {\cf17 auto} operator << (std::ostream& os, Duration {\cf17 const}& duration) -> std::ostream& \{\par
11615         {\cf19 return} os << duration.value() << {\cf22 " "} << duration.unitsAsString();\par
11616     \}\par
11617 \};\par
11618 \} {\cf20 // end anon namespace}\par
11619 \par
11620 {\cf17 class }TablePrinter \{\par
11621     std::ostream& m_os;\par
11622     std::vector<ColumnInfo> m_columnInfos;\par
11623     std::ostringstream m_oss;\par
11624     {\cf18 int} m_currentColumn = -1;\par
11625     {\cf18 bool} m_isOpen = {\cf17 false};\par
11626 \par
11627 {\cf17 public}:\par
11628     TablePrinter( std::ostream& os, std::vector<ColumnInfo> columnInfos )\par
11629     :   m_os( os ),\par
11630         m_columnInfos( std::move( columnInfos ) ) \{\}\par
11631 \par
11632     {\cf17 auto} columnInfos() const -> std::vector<ColumnInfo> const& \{\par
11633         {\cf19 return} m_columnInfos;\par
11634     \}\par
11635 \par
11636     {\cf18 void} open() \{\par
11637         {\cf19 if} (!m_isOpen) \{\par
11638             m_isOpen = {\cf17 true};\par
11639             *{\cf17 this} << RowBreak();\par
11640             {\cf19 for} ({\cf17 auto} {\cf17 const}& info : m_columnInfos)\par
11641                 *this << info.name << ColumnBreak();\par
11642             *{\cf17 this} << RowBreak();\par
11643             m_os << Catch::getLineOfChars<{\cf23 '-'}>() << {\cf22 "\\n"};\par
11644         \}\par
11645     \}\par
11646     {\cf18 void} close() \{\par
11647         {\cf19 if} (m_isOpen) \{\par
11648             *{\cf17 this} << RowBreak();\par
11649             m_os << std::endl;\par
11650             m_isOpen = {\cf17 false};\par
11651         \}\par
11652     \}\par
11653 \par
11654     {\cf17 template}<{\cf17 typename} T>\par
11655     {\cf17 friend} TablePrinter& operator << (TablePrinter& tp, T {\cf17 const}& value) \{\par
11656         tp.m_oss << value;\par
11657         {\cf19 return} tp;\par
11658     \}\par
11659 \par
11660     {\cf17 friend} TablePrinter& operator << (TablePrinter& tp, ColumnBreak) \{\par
11661         {\cf17 auto} colStr = tp.m_oss.str();\par
11662         {\cf20 // This takes account of utf8 encodings}\par
11663         {\cf17 auto} strSize = Catch::StringRef(colStr).numberOfCharacters();\par
11664         tp.m_oss.str({\cf22 ""});\par
11665         tp.open();\par
11666         {\cf19 if} (tp.m_currentColumn == {\cf17 static_cast<}{\cf18 int}{\cf17 >}(tp.m_columnInfos.size() - 1)) \{\par
11667             tp.m_currentColumn = -1;\par
11668             tp.m_os << {\cf22 "\\n"};\par
11669         \}\par
11670         tp.m_currentColumn++;\par
11671 \par
11672         {\cf17 auto} colInfo = tp.m_columnInfos[tp.m_currentColumn];\par
11673         {\cf17 auto} padding = (strSize + 2 < static_cast<std::size_t>(colInfo.width))\par
11674             ? std::string(colInfo.width - (strSize + 2), ' ')\par
11675             : std::string();\par
11676         {\cf19 if} (colInfo.justification == ColumnInfo::Left)\par
11677             tp.m_os << colStr << padding << {\cf22 " "};\par
11678         {\cf19 else}\par
11679             tp.m_os << padding << colStr << {\cf22 " "};\par
11680         {\cf19 return} tp;\par
11681     \}\par
11682 \par
11683     {\cf17 friend} TablePrinter& operator << (TablePrinter& tp, RowBreak) \{\par
11684         {\cf19 if} (tp.m_currentColumn > 0) \{\par
11685             tp.m_os << {\cf22 "\\n"};\par
11686             tp.m_currentColumn = -1;\par
11687         \}\par
11688         {\cf19 return} tp;\par
11689     \}\par
11690 \};\par
11691 \par
11692 ConsoleReporter::ConsoleReporter(ReporterConfig {\cf17 const}& config)\par
11693     : StreamingReporterBase(config),\par
11694     m_tablePrinter(new TablePrinter(config.stream(),\par
11695     \{\par
11696         \{ {\cf22 "benchmark name"}, CATCH_CONFIG_CONSOLE_WIDTH - 32, ColumnInfo::Left \},\par
11697         \{ {\cf22 "iters"}, 8, ColumnInfo::Right \},\par
11698         \{ {\cf22 "elapsed ns"}, 14, ColumnInfo::Right \},\par
11699         \{ {\cf22 "average"}, 14, ColumnInfo::Right \}\par
11700     \})) \{\}\par
11701 ConsoleReporter::~ConsoleReporter() = {\cf19 default};\par
11702 \par
11703 std::string ConsoleReporter::getDescription() \{\par
11704     {\cf19 return} {\cf22 "Reports test results as plain lines of text"};\par
11705 \}\par
11706 \par
11707 {\cf18 void} ConsoleReporter::noMatchingTestCases(std::string {\cf17 const}& spec) \{\par
11708     stream << {\cf22 "No test cases matched '"} << spec << {\cf23 '\\''} << std::endl;\par
11709 \}\par
11710 \par
11711 {\cf18 void} ConsoleReporter::assertionStarting(AssertionInfo {\cf17 const}&) \{\}\par
11712 \par
11713 {\cf18 bool} ConsoleReporter::assertionEnded(AssertionStats {\cf17 const}& _assertionStats) \{\par
11714     AssertionResult {\cf17 const}& result = _assertionStats.assertionResult;\par
11715 \par
11716     {\cf18 bool} includeResults = m_config->includeSuccessfulResults() || !result.isOk();\par
11717 \par
11718     {\cf20 // Drop out if result was successful but we're not printing them.}\par
11719     {\cf19 if} (!includeResults && result.getResultType() != ResultWas::Warning)\par
11720         {\cf19 return} {\cf17 false};\par
11721 \par
11722     lazyPrint();\par
11723 \par
11724     ConsoleAssertionPrinter printer(stream, _assertionStats, includeResults);\par
11725     printer.print();\par
11726     stream << std::endl;\par
11727     {\cf19 return} {\cf17 true};\par
11728 \}\par
11729 \par
11730 {\cf18 void} ConsoleReporter::sectionStarting(SectionInfo {\cf17 const}& _sectionInfo) \{\par
11731     m_headerPrinted = {\cf17 false};\par
11732     StreamingReporterBase::sectionStarting(_sectionInfo);\par
11733 \}\par
11734 {\cf18 void} ConsoleReporter::sectionEnded(SectionStats {\cf17 const}& _sectionStats) \{\par
11735     m_tablePrinter->close();\par
11736     {\cf19 if} (_sectionStats.missingAssertions) \{\par
11737         lazyPrint();\par
11738         Colour colour(Colour::ResultError);\par
11739         {\cf19 if} (m_sectionStack.size() > 1)\par
11740             stream << {\cf22 "\\nNo assertions in section"};\par
11741         {\cf19 else}\par
11742             stream << {\cf22 "\\nNo assertions in test case"};\par
11743         stream << {\cf22 " '"} << _sectionStats.sectionInfo.name << {\cf22 "'\\n"} << std::endl;\par
11744     \}\par
11745     {\cf19 if} (m_config->showDurations() == ShowDurations::Always) \{\par
11746         stream << getFormattedDuration(_sectionStats.durationInSeconds) << {\cf22 " s: "} << _sectionStats.sectionInfo.name << std::endl;\par
11747     \}\par
11748     {\cf19 if} (m_headerPrinted) \{\par
11749         m_headerPrinted = {\cf17 false};\par
11750     \}\par
11751     StreamingReporterBase::sectionEnded(_sectionStats);\par
11752 \}\par
11753 \par
11754 {\cf18 void} ConsoleReporter::benchmarkStarting(BenchmarkInfo {\cf17 const}& info) \{\par
11755     lazyPrintWithoutClosingBenchmarkTable();\par
11756 \par
11757     {\cf17 auto} nameCol = Column( info.name ).width( {\cf17 static_cast<}std::size_t{\cf17 >}( m_tablePrinter->columnInfos()[0].width - 2 ) );\par
11758 \par
11759     {\cf18 bool} firstLine = {\cf17 true};\par
11760     {\cf19 for} ({\cf17 auto} line : nameCol) \{\par
11761         {\cf19 if} (!firstLine)\par
11762             (*m_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();\par
11763         {\cf19 else}\par
11764             firstLine = {\cf17 false};\par
11765 \par
11766         (*m_tablePrinter) << line << ColumnBreak();\par
11767     \}\par
11768 \}\par
11769 {\cf18 void} ConsoleReporter::benchmarkEnded(BenchmarkStats {\cf17 const}& stats) \{\par
11770     Duration average(stats.elapsedTimeInNanoseconds / stats.iterations);\par
11771     (*m_tablePrinter)\par
11772         << stats.iterations << ColumnBreak()\par
11773         << stats.elapsedTimeInNanoseconds << ColumnBreak()\par
11774         << average << ColumnBreak();\par
11775 \}\par
11776 \par
11777 {\cf18 void} ConsoleReporter::testCaseEnded(TestCaseStats {\cf17 const}& _testCaseStats) \{\par
11778     m_tablePrinter->close();\par
11779     StreamingReporterBase::testCaseEnded(_testCaseStats);\par
11780     m_headerPrinted = {\cf17 false};\par
11781 \}\par
11782 {\cf18 void} ConsoleReporter::testGroupEnded(TestGroupStats {\cf17 const}& _testGroupStats) \{\par
11783     {\cf19 if} (currentGroupInfo.used) \{\par
11784         printSummaryDivider();\par
11785         stream << {\cf22 "Summary for group '"} << _testGroupStats.groupInfo.name << {\cf22 "':\\n"};\par
11786         printTotals(_testGroupStats.totals);\par
11787         stream << {\cf23 '\\n'} << std::endl;\par
11788     \}\par
11789     StreamingReporterBase::testGroupEnded(_testGroupStats);\par
11790 \}\par
11791 {\cf18 void} ConsoleReporter::testRunEnded(TestRunStats {\cf17 const}& _testRunStats) \{\par
11792     printTotalsDivider(_testRunStats.totals);\par
11793     printTotals(_testRunStats.totals);\par
11794     stream << std::endl;\par
11795     StreamingReporterBase::testRunEnded(_testRunStats);\par
11796 \}\par
11797 \par
11798 {\cf18 void} ConsoleReporter::lazyPrint() \{\par
11799 \par
11800     m_tablePrinter->close();\par
11801     lazyPrintWithoutClosingBenchmarkTable();\par
11802 \}\par
11803 \par
11804 {\cf18 void} ConsoleReporter::lazyPrintWithoutClosingBenchmarkTable() \{\par
11805 \par
11806     {\cf19 if} (!currentTestRunInfo.used)\par
11807         lazyPrintRunInfo();\par
11808     {\cf19 if} (!currentGroupInfo.used)\par
11809         lazyPrintGroupInfo();\par
11810 \par
11811     {\cf19 if} (!m_headerPrinted) \{\par
11812         printTestCaseAndSectionHeader();\par
11813         m_headerPrinted = {\cf17 true};\par
11814     \}\par
11815 \}\par
11816 {\cf18 void} ConsoleReporter::lazyPrintRunInfo() \{\par
11817     stream << '\\n' << getLineOfChars<'~'>() << {\cf23 '\\n'};\par
11818     Colour colour(Colour::SecondaryText);\par
11819     stream << currentTestRunInfo->name\par
11820         << {\cf22 " is a Catch v"} << libraryVersion() << {\cf22 " host application.\\n"}\par
11821         << {\cf22 "Run with -? for options\\n\\n"};\par
11822 \par
11823     {\cf19 if} (m_config->rngSeed() != 0)\par
11824         stream << {\cf22 "Randomness seeded to: "} << m_config->rngSeed() << {\cf22 "\\n\\n"};\par
11825 \par
11826     currentTestRunInfo.used = {\cf17 true};\par
11827 \}\par
11828 {\cf18 void} ConsoleReporter::lazyPrintGroupInfo() \{\par
11829     {\cf19 if} (!currentGroupInfo->name.empty() && currentGroupInfo->groupsCounts > 1) \{\par
11830         printClosedHeader({\cf22 "Group: "} + currentGroupInfo->name);\par
11831         currentGroupInfo.used = {\cf17 true};\par
11832     \}\par
11833 \}\par
11834 {\cf18 void} ConsoleReporter::printTestCaseAndSectionHeader() \{\par
11835     assert(!m_sectionStack.empty());\par
11836     printOpenHeader(currentTestCaseInfo->name);\par
11837 \par
11838     {\cf19 if} (m_sectionStack.size() > 1) \{\par
11839         Colour colourGuard(Colour::Headers);\par
11840 \par
11841         {\cf17 auto}\par
11842             it = m_sectionStack.begin() + 1, {\cf20 // Skip first section (test case)}\par
11843             itEnd = m_sectionStack.end();\par
11844         {\cf19 for} (; it != itEnd; ++it)\par
11845             printHeaderString(it->name, 2);\par
11846     \}\par
11847 \par
11848     SourceLineInfo lineInfo = m_sectionStack.back().lineInfo;\par
11849 \par
11850     {\cf19 if} (!lineInfo.empty()) \{\par
11851         stream << getLineOfChars<{\cf22 '-'}>() << {\cf22 '\\n'};\par
11852         Colour colourGuard(Colour::FileName);\par
11853         stream << lineInfo << {\cf22 '\\n'};\par
11854     \}\par
11855     stream << getLineOfChars<{\cf23 '.'}>() << {\cf23 '\\n'} << std::endl;\par
11856 \}\par
11857 \par
11858 {\cf18 void} ConsoleReporter::printClosedHeader(std::string {\cf17 const}& _name) \{\par
11859     printOpenHeader(_name);\par
11860     stream << getLineOfChars<{\cf23 '.'}>() << {\cf23 '\\n'};\par
11861 \}\par
11862 {\cf18 void} ConsoleReporter::printOpenHeader(std::string {\cf17 const}& _name) \{\par
11863     stream << getLineOfChars<{\cf23 '-'}>() << {\cf23 '\\n'};\par
11864     \{\par
11865         Colour colourGuard(Colour::Headers);\par
11866         printHeaderString(_name);\par
11867     \}\par
11868 \}\par
11869 \par
11870 {\cf20 // if string has a : in first line will set indent to follow it on}\par
11871 {\cf20 // subsequent lines}\par
11872 {\cf18 void} ConsoleReporter::printHeaderString(std::string {\cf17 const}& _string, std::size_t indent) \{\par
11873     std::size_t i = _string.find({\cf22 ": "});\par
11874     {\cf19 if} (i != std::string::npos)\par
11875         i += 2;\par
11876     {\cf19 else}\par
11877         i = 0;\par
11878     stream << Column(_string).indent(indent + i).initialIndent(indent) << {\cf23 '\\n'};\par
11879 \}\par
11880 \par
11881 {\cf17 struct }SummaryColumn \{\par
11882 \par
11883     SummaryColumn( std::string _label, Colour::Code _colour )\par
11884     :   label( std::move( _label ) ),\par
11885         colour( _colour ) \{\}\par
11886     SummaryColumn addRow( std::size_t count ) \{\par
11887         ReusableStringStream rss;\par
11888         rss << count;\par
11889         std::string row = rss.str();\par
11890         {\cf19 for} ({\cf17 auto}& oldRow : rows) \{\par
11891             {\cf19 while} (oldRow.size() < row.size())\par
11892                 oldRow = {\cf23 ' '} + oldRow;\par
11893             {\cf19 while} (oldRow.size() > row.size())\par
11894                 row = {\cf23 ' '} + row;\par
11895         \}\par
11896         rows.push_back(row);\par
11897         {\cf19 return} *{\cf17 this};\par
11898     \}\par
11899 \par
11900     std::string label;\par
11901     Colour::Code colour;\par
11902     std::vector<std::string> rows;\par
11903 \par
11904 \};\par
11905 \par
11906 {\cf18 void} ConsoleReporter::printTotals( Totals {\cf17 const}& totals ) \{\par
11907     {\cf19 if} (totals.testCases.total() == 0) \{\par
11908         stream << Colour(Colour::Warning) << {\cf22 "No tests ran\\n"};\par
11909     \} {\cf19 else} {\cf19 if} (totals.assertions.total() > 0 && totals.testCases.allPassed()) \{\par
11910         stream << Colour(Colour::ResultSuccess) << {\cf22 "All tests passed"};\par
11911         stream << {\cf22 " ("}\par
11912             << pluralise(totals.assertions.passed, {\cf22 "assertion"}) << {\cf22 " in "}\par
11913             << pluralise(totals.testCases.passed, {\cf22 "test case"}) << {\cf23 ')'}\par
11914             << {\cf23 '\\n'};\par
11915     \} {\cf19 else} \{\par
11916 \par
11917         std::vector<SummaryColumn> columns;\par
11918         columns.push_back(SummaryColumn({\cf22 ""}, Colour::None)\par
11919                           .addRow(totals.testCases.total())\par
11920                           .addRow(totals.assertions.total()));\par
11921         columns.push_back(SummaryColumn({\cf22 "passed"}, Colour::Success)\par
11922                           .addRow(totals.testCases.passed)\par
11923                           .addRow(totals.assertions.passed));\par
11924         columns.push_back(SummaryColumn({\cf22 "failed"}, Colour::ResultError)\par
11925                           .addRow(totals.testCases.failed)\par
11926                           .addRow(totals.assertions.failed));\par
11927         columns.push_back(SummaryColumn({\cf22 "failed as expected"}, Colour::ResultExpectedFailure)\par
11928                           .addRow(totals.testCases.failedButOk)\par
11929                           .addRow(totals.assertions.failedButOk));\par
11930 \par
11931         printSummaryRow({\cf22 "test cases"}, columns, 0);\par
11932         printSummaryRow({\cf22 "assertions"}, columns, 1);\par
11933     \}\par
11934 \}\par
11935 {\cf18 void} ConsoleReporter::printSummaryRow(std::string {\cf17 const}& label, std::vector<SummaryColumn> {\cf17 const}& cols, std::size_t row) \{\par
11936     {\cf19 for} ({\cf17 auto} col : cols) \{\par
11937         std::string value = col.rows[row];\par
11938         {\cf19 if} (col.label.empty()) \{\par
11939             stream << label << {\cf22 ": "};\par
11940             {\cf19 if} (value != {\cf22 "0"})\par
11941                 stream << value;\par
11942             {\cf19 else}\par
11943                 stream << Colour(Colour::Warning) << {\cf22 "- none -"};\par
11944         \} {\cf19 else} {\cf19 if} (value != {\cf22 "0"}) \{\par
11945             stream << Colour(Colour::LightGrey) << {\cf22 " | "};\par
11946             stream << Colour(col.colour)\par
11947                 << value << {\cf23 ' '} << col.label;\par
11948         \}\par
11949     \}\par
11950     stream << {\cf23 '\\n'};\par
11951 \}\par
11952 \par
11953 {\cf18 void} ConsoleReporter::printTotalsDivider(Totals {\cf17 const}& totals) \{\par
11954     {\cf19 if} (totals.testCases.total() > 0) \{\par
11955         std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());\par
11956         std::size_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());\par
11957         std::size_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());\par
11958         {\cf19 while} (failedRatio + failedButOkRatio + passedRatio < CATCH_CONFIG_CONSOLE_WIDTH - 1)\par
11959             findMax(failedRatio, failedButOkRatio, passedRatio)++;\par
11960         {\cf19 while} (failedRatio + failedButOkRatio + passedRatio > CATCH_CONFIG_CONSOLE_WIDTH - 1)\par
11961             findMax(failedRatio, failedButOkRatio, passedRatio)--;\par
11962 \par
11963         stream << Colour(Colour::Error) << std::string(failedRatio, {\cf23 '='});\par
11964         stream << Colour(Colour::ResultExpectedFailure) << std::string(failedButOkRatio, {\cf23 '='});\par
11965         {\cf19 if} (totals.testCases.allPassed())\par
11966             stream << Colour(Colour::ResultSuccess) << std::string(passedRatio, {\cf23 '='});\par
11967         {\cf19 else}\par
11968             stream << Colour(Colour::Success) << std::string(passedRatio, {\cf23 '='});\par
11969     \} {\cf19 else} \{\par
11970         stream << Colour(Colour::Warning) << std::string(CATCH_CONFIG_CONSOLE_WIDTH - 1, {\cf23 '='});\par
11971     \}\par
11972     stream << {\cf23 '\\n'};\par
11973 \}\par
11974 {\cf18 void} ConsoleReporter::printSummaryDivider() \{\par
11975     stream << getLineOfChars<{\cf23 '-'}>() << {\cf23 '\\n'};\par
11976 \}\par
11977 \par
11978 CATCH_REGISTER_REPORTER({\cf22 "console"}, ConsoleReporter)\par
11979 \par
11980 \} {\cf20 // end namespace Catch}\par
11981 \par
11982 {\cf21 #if defined(_MSC_VER)}\par
11983 {\cf21 #pragma warning(pop)}\par
11984 {\cf21 #endif}\par
11985 {\cf20 // end catch_reporter_console.cpp}\par
11986 {\cf20 // start catch_reporter_junit.cpp}\par
11987 \par
11988 {\cf21 #include <assert.h>}\par
11989 {\cf21 #include <sstream>}\par
11990 {\cf21 #include <ctime>}\par
11991 {\cf21 #include <algorithm>}\par
11992 \par
11993 {\cf17 namespace }Catch \{\par
11994 \par
11995     {\cf17 namespace }\{\par
11996         std::string getCurrentTimestamp() \{\par
11997             {\cf20 // Beware, this is not reentrant because of backward compatibility issues}\par
11998             {\cf20 // Also, UTC only, again because of backward compatibility (%z is C++11)}\par
11999             time_t rawtime;\par
12000             std::time(&rawtime);\par
12001             {\cf17 auto} {\cf17 const} timeStampSize = {\cf17 sizeof}({\cf22 "2017-01-16T17:06:45Z"});\par
12002 \par
12003 {\cf21 #ifdef _MSC_VER}\par
12004             std::tm timeInfo = \{\};\par
12005             gmtime_s(&timeInfo, &rawtime);\par
12006 {\cf21 #else}\par
12007             std::tm* timeInfo;\par
12008             timeInfo = std::gmtime(&rawtime);\par
12009 {\cf21 #endif}\par
12010 \par
12011             {\cf18 char} timeStamp[timeStampSize];\par
12012             {\cf17 const} {\cf18 char} * {\cf17 const} fmt = {\cf22 "%Y-%m-%dT%H:%M:%SZ"};\par
12013 \par
12014 {\cf21 #ifdef _MSC_VER}\par
12015             std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);\par
12016 {\cf21 #else}\par
12017             std::strftime(timeStamp, timeStampSize, fmt, timeInfo);\par
12018 {\cf21 #endif}\par
12019             {\cf19 return} std::string(timeStamp);\par
12020         \}\par
12021 \par
12022         std::string fileNameTag({\cf17 const} std::vector<std::string> &tags) \{\par
12023             {\cf17 auto} it = std::find_if(begin(tags),\par
12024                                    end(tags),\par
12025                                    [] (std::string {\cf17 const}& tag) \{{\cf19 return} tag.front() == {\cf23 '#'}; \});\par
12026             {\cf19 if} (it != tags.end())\par
12027                 {\cf19 return} it->substr(1);\par
12028             {\cf19 return} std::string();\par
12029         \}\par
12030     \} {\cf20 // anonymous namespace}\par
12031 \par
12032     JunitReporter::JunitReporter( ReporterConfig {\cf17 const}& _config )\par
12033         :   CumulativeReporterBase( _config ),\par
12034             xml( _config.stream() )\par
12035         \{\par
12036             m_reporterPrefs.shouldRedirectStdOut = {\cf17 true};\par
12037         \}\par
12038 \par
12039     JunitReporter::~JunitReporter() \{\}\par
12040 \par
12041     std::string JunitReporter::getDescription() \{\par
12042         {\cf19 return} {\cf22 "Reports test results in an XML format that looks like Ant's junitreport target"};\par
12043     \}\par
12044 \par
12045     {\cf18 void} JunitReporter::noMatchingTestCases( std::string {\cf17 const}& {\cf20 /*spec*/} ) \{\}\par
12046 \par
12047     {\cf18 void} JunitReporter::testRunStarting( TestRunInfo {\cf17 const}& runInfo )  \{\par
12048         CumulativeReporterBase::testRunStarting( runInfo );\par
12049         xml.startElement( {\cf22 "testsuites"} );\par
12050     \}\par
12051 \par
12052     {\cf18 void} JunitReporter::testGroupStarting( GroupInfo {\cf17 const}& groupInfo ) \{\par
12053         suiteTimer.start();\par
12054         stdOutForSuite.clear();\par
12055         stdErrForSuite.clear();\par
12056         unexpectedExceptions = 0;\par
12057         CumulativeReporterBase::testGroupStarting( groupInfo );\par
12058     \}\par
12059 \par
12060     {\cf18 void} JunitReporter::testCaseStarting( TestCaseInfo {\cf17 const}& testCaseInfo ) \{\par
12061         m_okToFail = testCaseInfo.okToFail();\par
12062     \}\par
12063 \par
12064     {\cf18 bool} JunitReporter::assertionEnded( AssertionStats {\cf17 const}& assertionStats ) \{\par
12065         {\cf19 if}( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException && !m_okToFail )\par
12066             unexpectedExceptions++;\par
12067         {\cf19 return} CumulativeReporterBase::assertionEnded( assertionStats );\par
12068     \}\par
12069 \par
12070     {\cf18 void} JunitReporter::testCaseEnded( TestCaseStats {\cf17 const}& testCaseStats ) \{\par
12071         stdOutForSuite += testCaseStats.stdOut;\par
12072         stdErrForSuite += testCaseStats.stdErr;\par
12073         CumulativeReporterBase::testCaseEnded( testCaseStats );\par
12074     \}\par
12075 \par
12076     {\cf18 void} JunitReporter::testGroupEnded( TestGroupStats {\cf17 const}& testGroupStats ) \{\par
12077         {\cf18 double} suiteTime = suiteTimer.getElapsedSeconds();\par
12078         CumulativeReporterBase::testGroupEnded( testGroupStats );\par
12079         writeGroup( *m_testGroups.back(), suiteTime );\par
12080     \}\par
12081 \par
12082     {\cf18 void} JunitReporter::testRunEndedCumulative() \{\par
12083         xml.endElement();\par
12084     \}\par
12085 \par
12086     {\cf18 void} JunitReporter::writeGroup( TestGroupNode {\cf17 const}& groupNode, {\cf18 double} suiteTime ) \{\par
12087         XmlWriter::ScopedElement e = xml.scopedElement( {\cf22 "testsuite"} );\par
12088         TestGroupStats {\cf17 const}& stats = groupNode.value;\par
12089         xml.writeAttribute( {\cf22 "name"}, stats.groupInfo.name );\par
12090         xml.writeAttribute( {\cf22 "errors"}, unexpectedExceptions );\par
12091         xml.writeAttribute( {\cf22 "failures"}, stats.totals.assertions.failed-unexpectedExceptions );\par
12092         xml.writeAttribute( {\cf22 "tests"}, stats.totals.assertions.total() );\par
12093         xml.writeAttribute( {\cf22 "hostname"}, {\cf22 "tbd"} ); {\cf20 // !TBD}\par
12094         {\cf19 if}( m_config->showDurations() == ShowDurations::Never )\par
12095             xml.writeAttribute( {\cf22 "time"}, {\cf22 ""} );\par
12096         {\cf19 else}\par
12097             xml.writeAttribute( {\cf22 "time"}, suiteTime );\par
12098         xml.writeAttribute( {\cf22 "timestamp"}, getCurrentTimestamp() );\par
12099 \par
12100         {\cf20 // Write test cases}\par
12101         {\cf19 for}( {\cf17 auto} {\cf17 const}& child : groupNode.children )\par
12102             writeTestCase( *child );\par
12103 \par
12104         xml.scopedElement( {\cf22 "system-out"} ).writeText( trim( stdOutForSuite ), {\cf17 false} );\par
12105         xml.scopedElement( {\cf22 "system-err"} ).writeText( trim( stdErrForSuite ), {\cf17 false} );\par
12106     \}\par
12107 \par
12108     {\cf18 void} JunitReporter::writeTestCase( TestCaseNode {\cf17 const}& testCaseNode ) \{\par
12109         TestCaseStats {\cf17 const}& stats = testCaseNode.value;\par
12110 \par
12111         {\cf20 // All test cases have exactly one section - which represents the}\par
12112         {\cf20 // test case itself. That section may have 0-n nested sections}\par
12113         assert( testCaseNode.children.size() == 1 );\par
12114         SectionNode {\cf17 const}& rootSection = *testCaseNode.children.front();\par
12115 \par
12116         std::string className = stats.testInfo.className;\par
12117 \par
12118         {\cf19 if}( className.empty() ) \{\par
12119             className = fileNameTag(stats.testInfo.tags);\par
12120             {\cf19 if} ( className.empty() )\par
12121                 className = {\cf22 "global"};\par
12122         \}\par
12123 \par
12124         {\cf19 if} ( !m_config->name().empty() )\par
12125             className = m_config->name() + "." + className;\par
12126 \par
12127         writeSection( className, {\cf22 ""}, rootSection );\par
12128     \}\par
12129 \par
12130     {\cf18 void} JunitReporter::writeSection(  std::string {\cf17 const}& className,\par
12131                         std::string {\cf17 const}& rootName,\par
12132                         SectionNode {\cf17 const}& sectionNode ) \{\par
12133         std::string name = trim( sectionNode.stats.sectionInfo.name );\par
12134         {\cf19 if}( !rootName.empty() )\par
12135             name = rootName + '/' + name;\par
12136 \par
12137         {\cf19 if}( !sectionNode.assertions.empty() ||\par
12138             !sectionNode.stdOut.empty() ||\par
12139             !sectionNode.stdErr.empty() ) \{\par
12140             XmlWriter::ScopedElement e = xml.scopedElement( {\cf22 "testcase"} );\par
12141             {\cf19 if}( className.empty() ) \{\par
12142                 xml.writeAttribute( {\cf22 "classname"}, name );\par
12143                 xml.writeAttribute( {\cf22 "name"}, {\cf22 "root"} );\par
12144             \}\par
12145             {\cf19 else} \{\par
12146                 xml.writeAttribute( {\cf22 "classname"}, className );\par
12147                 xml.writeAttribute( {\cf22 "name"}, name );\par
12148             \}\par
12149             xml.writeAttribute( {\cf22 "time"}, ::Catch::Detail::stringify( sectionNode.stats.durationInSeconds ) );\par
12150 \par
12151             writeAssertions( sectionNode );\par
12152 \par
12153             {\cf19 if}( !sectionNode.stdOut.empty() )\par
12154                 xml.scopedElement( {\cf22 "system-out"} ).writeText( trim( sectionNode.stdOut ), {\cf17 false} );\par
12155             {\cf19 if}( !sectionNode.stdErr.empty() )\par
12156                 xml.scopedElement( {\cf22 "system-err"} ).writeText( trim( sectionNode.stdErr ), {\cf17 false} );\par
12157         \}\par
12158         {\cf19 for}( {\cf17 auto} {\cf17 const}& childNode : sectionNode.childSections )\par
12159             if( className.empty() )\par
12160                 writeSection( name, {\cf22 ""}, *childNode );\par
12161             {\cf19 else}\par
12162                 writeSection( className, name, *childNode );\par
12163     \}\par
12164 \par
12165     {\cf18 void} JunitReporter::writeAssertions( SectionNode {\cf17 const}& sectionNode ) \{\par
12166         {\cf19 for}( {\cf17 auto} {\cf17 const}& assertion : sectionNode.assertions )\par
12167             writeAssertion( assertion );\par
12168     \}\par
12169 \par
12170     {\cf18 void} JunitReporter::writeAssertion( AssertionStats {\cf17 const}& stats ) \{\par
12171         AssertionResult {\cf17 const}& result = stats.assertionResult;\par
12172         {\cf19 if}( !result.isOk() ) \{\par
12173             std::string elementName;\par
12174             {\cf19 switch}( result.getResultType() ) \{\par
12175                 {\cf19 case} ResultWas::ThrewException:\par
12176                 {\cf19 case} ResultWas::FatalErrorCondition:\par
12177                     elementName = {\cf22 "error"};\par
12178                     {\cf19 break};\par
12179                 {\cf19 case} ResultWas::ExplicitFailure:\par
12180                     elementName = {\cf22 "failure"};\par
12181                     {\cf19 break};\par
12182                 {\cf19 case} ResultWas::ExpressionFailed:\par
12183                     elementName = {\cf22 "failure"};\par
12184                     {\cf19 break};\par
12185                 {\cf19 case} ResultWas::DidntThrowException:\par
12186                     elementName = {\cf22 "failure"};\par
12187                     {\cf19 break};\par
12188 \par
12189                 {\cf20 // We should never see these here:}\par
12190                 {\cf19 case} ResultWas::Info:\par
12191                 {\cf19 case} ResultWas::Warning:\par
12192                 {\cf19 case} ResultWas::Ok:\par
12193                 {\cf19 case} ResultWas::Unknown:\par
12194                 {\cf19 case} ResultWas::FailureBit:\par
12195                 {\cf19 case} ResultWas::Exception:\par
12196                     elementName = {\cf22 "internalError"};\par
12197                     {\cf19 break};\par
12198             \}\par
12199 \par
12200             XmlWriter::ScopedElement e = xml.scopedElement( elementName );\par
12201 \par
12202             xml.writeAttribute( {\cf22 "message"}, result.getExpandedExpression() );\par
12203             xml.writeAttribute( {\cf22 "type"}, result.getTestMacroName() );\par
12204 \par
12205             ReusableStringStream rss;\par
12206             {\cf19 if}( !result.getMessage().empty() )\par
12207                 rss << result.getMessage() << {\cf23 '\\n'};\par
12208             {\cf19 for}( {\cf17 auto} {\cf17 const}& msg : stats.infoMessages )\par
12209                 if( msg.type == ResultWas::Info )\par
12210                     rss << msg.message << {\cf22 '\\n'};\par
12211 \par
12212             rss << {\cf22 "at "} << result.getSourceInfo();\par
12213             xml.writeText( rss.str(), {\cf17 false} );\par
12214         \}\par
12215     \}\par
12216 \par
12217     CATCH_REGISTER_REPORTER( {\cf22 "junit"}, JunitReporter )\par
12218 \par
12219 \} {\cf20 // end namespace Catch}\par
12220 {\cf20 // end catch_reporter_junit.cpp}\par
12221 {\cf20 // start catch_reporter_multi.cpp}\par
12222 \par
12223 {\cf17 namespace }Catch \{\par
12224 \par
12225     {\cf18 void} MultipleReporters::add( IStreamingReporterPtr&& reporter ) \{\par
12226         m_reporters.push_back( std::move( reporter ) );\par
12227     \}\par
12228 \par
12229     ReporterPreferences MultipleReporters::getPreferences(){\cf17  const }\{\par
12230         {\cf19 return} m_reporters[0]->getPreferences();\par
12231     \}\par
12232 \par
12233     std::set<Verbosity> MultipleReporters::getSupportedVerbosities() \{\par
12234         {\cf19 return} std::set<Verbosity>\{ \};\par
12235     \}\par
12236 \par
12237     {\cf18 void} MultipleReporters::noMatchingTestCases( std::string {\cf17 const}& spec ) \{\par
12238         {\cf19 for}( {\cf17 auto} {\cf17 const}& reporter : m_reporters )\par
12239             reporter->noMatchingTestCases( spec );\par
12240     \}\par
12241 \par
12242     {\cf18 void} MultipleReporters::benchmarkStarting( BenchmarkInfo {\cf17 const}& benchmarkInfo ) \{\par
12243         {\cf19 for}( {\cf17 auto} {\cf17 const}& reporter : m_reporters )\par
12244             reporter->benchmarkStarting( benchmarkInfo );\par
12245     \}\par
12246     {\cf18 void} MultipleReporters::benchmarkEnded( BenchmarkStats {\cf17 const}& benchmarkStats ) \{\par
12247         {\cf19 for}( {\cf17 auto} {\cf17 const}& reporter : m_reporters )\par
12248             reporter->benchmarkEnded( benchmarkStats );\par
12249     \}\par
12250 \par
12251     {\cf18 void} MultipleReporters::testRunStarting( TestRunInfo {\cf17 const}& testRunInfo ) \{\par
12252         {\cf19 for}( {\cf17 auto} {\cf17 const}& reporter : m_reporters )\par
12253             reporter->testRunStarting( testRunInfo );\par
12254     \}\par
12255 \par
12256     {\cf18 void} MultipleReporters::testGroupStarting( GroupInfo {\cf17 const}& groupInfo ) \{\par
12257         {\cf19 for}( {\cf17 auto} {\cf17 const}& reporter : m_reporters )\par
12258             reporter->testGroupStarting( groupInfo );\par
12259     \}\par
12260 \par
12261     {\cf18 void} MultipleReporters::testCaseStarting( TestCaseInfo {\cf17 const}& testInfo ) \{\par
12262         {\cf19 for}( {\cf17 auto} {\cf17 const}& reporter : m_reporters )\par
12263             reporter->testCaseStarting( testInfo );\par
12264     \}\par
12265 \par
12266     {\cf18 void} MultipleReporters::sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) \{\par
12267         {\cf19 for}( {\cf17 auto} {\cf17 const}& reporter : m_reporters )\par
12268             reporter->sectionStarting( sectionInfo );\par
12269     \}\par
12270 \par
12271     {\cf18 void} MultipleReporters::assertionStarting( AssertionInfo {\cf17 const}& assertionInfo ) \{\par
12272         {\cf19 for}( {\cf17 auto} {\cf17 const}& reporter : m_reporters )\par
12273             reporter->assertionStarting( assertionInfo );\par
12274     \}\par
12275 \par
12276     {\cf20 // The return value indicates if the messages buffer should be cleared:}\par
12277     {\cf18 bool} MultipleReporters::assertionEnded( AssertionStats {\cf17 const}& assertionStats ) \{\par
12278         {\cf18 bool} clearBuffer = {\cf17 false};\par
12279         {\cf19 for}( {\cf17 auto} {\cf17 const}& reporter : m_reporters )\par
12280             clearBuffer |= reporter->assertionEnded( assertionStats );\par
12281         {\cf19 return} clearBuffer;\par
12282     \}\par
12283 \par
12284     {\cf18 void} MultipleReporters::sectionEnded( SectionStats {\cf17 const}& sectionStats ) \{\par
12285         {\cf19 for}( {\cf17 auto} {\cf17 const}& reporter : m_reporters )\par
12286             reporter->sectionEnded( sectionStats );\par
12287     \}\par
12288 \par
12289     {\cf18 void} MultipleReporters::testCaseEnded( TestCaseStats {\cf17 const}& testCaseStats ) \{\par
12290         {\cf19 for}( {\cf17 auto} {\cf17 const}& reporter : m_reporters )\par
12291             reporter->testCaseEnded( testCaseStats );\par
12292     \}\par
12293 \par
12294     {\cf18 void} MultipleReporters::testGroupEnded( TestGroupStats {\cf17 const}& testGroupStats ) \{\par
12295         {\cf19 for}( {\cf17 auto} {\cf17 const}& reporter : m_reporters )\par
12296             reporter->testGroupEnded( testGroupStats );\par
12297     \}\par
12298 \par
12299     {\cf18 void} MultipleReporters::testRunEnded( TestRunStats {\cf17 const}& testRunStats ) \{\par
12300         {\cf19 for}( {\cf17 auto} {\cf17 const}& reporter : m_reporters )\par
12301             reporter->testRunEnded( testRunStats );\par
12302     \}\par
12303 \par
12304     {\cf18 void} MultipleReporters::skipTest( TestCaseInfo {\cf17 const}& testInfo ) \{\par
12305         {\cf19 for}( {\cf17 auto} {\cf17 const}& reporter : m_reporters )\par
12306             reporter->skipTest( testInfo );\par
12307     \}\par
12308 \par
12309     {\cf18 bool} MultipleReporters::isMulti(){\cf17  const }\{\par
12310         {\cf19 return} {\cf17 true};\par
12311     \}\par
12312 \par
12313 \} {\cf20 // end namespace Catch}\par
12314 {\cf20 // end catch_reporter_multi.cpp}\par
12315 {\cf20 // start catch_reporter_xml.cpp}\par
12316 \par
12317 {\cf21 #if defined(_MSC_VER)}\par
12318 {\cf21 #pragma warning(push)}\par
12319 {\cf21 #pragma warning(disable:4061) }{\cf20 // Not all labels are EXPLICITLY handled in switch}\par
12320                               {\cf20 // Note that 4062 (not all labels are handled}\par
12321                               {\cf20 // and default is missing) is enabled}\par
12322 {\cf21 #endif}\par
12323 \par
12324 {\cf17 namespace }Catch \{\par
12325     XmlReporter::XmlReporter( ReporterConfig {\cf17 const}& _config )\par
12326     :   StreamingReporterBase( _config ),\par
12327         m_xml(_config.stream())\par
12328     \{\par
12329         m_reporterPrefs.shouldRedirectStdOut = {\cf17 true};\par
12330     \}\par
12331 \par
12332     XmlReporter::~XmlReporter() = {\cf19 default};\par
12333 \par
12334     std::string XmlReporter::getDescription() \{\par
12335         {\cf19 return} {\cf22 "Reports test results as an XML document"};\par
12336     \}\par
12337 \par
12338     std::string XmlReporter::getStylesheetRef(){\cf17  const }\{\par
12339         {\cf19 return} std::string();\par
12340     \}\par
12341 \par
12342     {\cf18 void} XmlReporter::writeSourceInfo( SourceLineInfo {\cf17 const}& sourceInfo ) \{\par
12343         m_xml\par
12344             .writeAttribute( {\cf22 "filename"}, sourceInfo.file )\par
12345             .writeAttribute( {\cf22 "line"}, sourceInfo.line );\par
12346     \}\par
12347 \par
12348     {\cf18 void} XmlReporter::noMatchingTestCases( std::string {\cf17 const}& s ) \{\par
12349         StreamingReporterBase::noMatchingTestCases( s );\par
12350     \}\par
12351 \par
12352     {\cf18 void} XmlReporter::testRunStarting( TestRunInfo {\cf17 const}& testInfo ) \{\par
12353         StreamingReporterBase::testRunStarting( testInfo );\par
12354         std::string stylesheetRef = getStylesheetRef();\par
12355         {\cf19 if}( !stylesheetRef.empty() )\par
12356             m_xml.writeStylesheetRef( stylesheetRef );\par
12357         m_xml.startElement( {\cf22 "Catch"} );\par
12358         {\cf19 if}( !m_config->name().empty() )\par
12359             m_xml.writeAttribute( {\cf22 "name"}, m_config->name() );\par
12360     \}\par
12361 \par
12362     {\cf18 void} XmlReporter::testGroupStarting( GroupInfo {\cf17 const}& groupInfo ) \{\par
12363         StreamingReporterBase::testGroupStarting( groupInfo );\par
12364         m_xml.startElement( {\cf22 "Group"} )\par
12365             .writeAttribute( {\cf22 "name"}, groupInfo.name );\par
12366     \}\par
12367 \par
12368     {\cf18 void} XmlReporter::testCaseStarting( TestCaseInfo {\cf17 const}& testInfo ) \{\par
12369         StreamingReporterBase::testCaseStarting(testInfo);\par
12370         m_xml.startElement( {\cf22 "TestCase"} )\par
12371             .writeAttribute( {\cf22 "name"}, trim( testInfo.name ) )\par
12372             .writeAttribute( {\cf22 "description"}, testInfo.description )\par
12373             .writeAttribute( {\cf22 "tags"}, testInfo.tagsAsString() );\par
12374 \par
12375         writeSourceInfo( testInfo.lineInfo );\par
12376 \par
12377         {\cf19 if} ( m_config->showDurations() == ShowDurations::Always )\par
12378             m_testCaseTimer.start();\par
12379         m_xml.ensureTagClosed();\par
12380     \}\par
12381 \par
12382     {\cf18 void} XmlReporter::sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) \{\par
12383         StreamingReporterBase::sectionStarting( sectionInfo );\par
12384         {\cf19 if}( m_sectionDepth++ > 0 ) \{\par
12385             m_xml.startElement( {\cf22 "Section"} )\par
12386                 .writeAttribute( {\cf22 "name"}, trim( sectionInfo.name ) )\par
12387                 .writeAttribute( {\cf22 "description"}, sectionInfo.description );\par
12388             writeSourceInfo( sectionInfo.lineInfo );\par
12389             m_xml.ensureTagClosed();\par
12390         \}\par
12391     \}\par
12392 \par
12393     {\cf18 void} XmlReporter::assertionStarting( AssertionInfo {\cf17 const}& ) \{ \}\par
12394 \par
12395     {\cf18 bool} XmlReporter::assertionEnded( AssertionStats {\cf17 const}& assertionStats ) \{\par
12396 \par
12397         AssertionResult {\cf17 const}& result = assertionStats.assertionResult;\par
12398 \par
12399         {\cf18 bool} includeResults = m_config->includeSuccessfulResults() || !result.isOk();\par
12400 \par
12401         {\cf19 if}( includeResults || result.getResultType() == ResultWas::Warning ) \{\par
12402             {\cf20 // Print any info messages in <Info> tags.}\par
12403             {\cf19 for}( {\cf17 auto} {\cf17 const}& msg : assertionStats.infoMessages ) \{\par
12404                 {\cf19 if}( msg.type == ResultWas::Info && includeResults ) \{\par
12405                     m_xml.scopedElement( {\cf22 "Info"} )\par
12406                             .writeText( msg.message );\par
12407                 \} {\cf19 else} {\cf19 if} ( msg.type == ResultWas::Warning ) \{\par
12408                     m_xml.scopedElement( {\cf22 "Warning"} )\par
12409                             .writeText( msg.message );\par
12410                 \}\par
12411             \}\par
12412         \}\par
12413 \par
12414         {\cf20 // Drop out if result was successful but we're not printing them.}\par
12415         {\cf19 if}( !includeResults && result.getResultType() != ResultWas::Warning )\par
12416             {\cf19 return} {\cf17 true};\par
12417 \par
12418         {\cf20 // Print the expression if there is one.}\par
12419         {\cf19 if}( result.hasExpression() ) \{\par
12420             m_xml.startElement( {\cf22 "Expression"} )\par
12421                 .writeAttribute( {\cf22 "success"}, result.succeeded() )\par
12422                 .writeAttribute( {\cf22 "type"}, result.getTestMacroName() );\par
12423 \par
12424             writeSourceInfo( result.getSourceInfo() );\par
12425 \par
12426             m_xml.scopedElement( {\cf22 "Original"} )\par
12427                 .writeText( result.getExpression() );\par
12428             m_xml.scopedElement( {\cf22 "Expanded"} )\par
12429                 .writeText( result.getExpandedExpression() );\par
12430         \}\par
12431 \par
12432         {\cf20 // And... Print a result applicable to each result type.}\par
12433         {\cf19 switch}( result.getResultType() ) \{\par
12434             {\cf19 case} ResultWas::ThrewException:\par
12435                 m_xml.startElement( {\cf22 "Exception"} );\par
12436                 writeSourceInfo( result.getSourceInfo() );\par
12437                 m_xml.writeText( result.getMessage() );\par
12438                 m_xml.endElement();\par
12439                 {\cf19 break};\par
12440             {\cf19 case} ResultWas::FatalErrorCondition:\par
12441                 m_xml.startElement( {\cf22 "FatalErrorCondition"} );\par
12442                 writeSourceInfo( result.getSourceInfo() );\par
12443                 m_xml.writeText( result.getMessage() );\par
12444                 m_xml.endElement();\par
12445                 {\cf19 break};\par
12446             {\cf19 case} ResultWas::Info:\par
12447                 m_xml.scopedElement( {\cf22 "Info"} )\par
12448                     .writeText( result.getMessage() );\par
12449                 {\cf19 break};\par
12450             {\cf19 case} ResultWas::Warning:\par
12451                 {\cf20 // Warning will already have been written}\par
12452                 {\cf19 break};\par
12453             {\cf19 case} ResultWas::ExplicitFailure:\par
12454                 m_xml.startElement( {\cf22 "Failure"} );\par
12455                 writeSourceInfo( result.getSourceInfo() );\par
12456                 m_xml.writeText( result.getMessage() );\par
12457                 m_xml.endElement();\par
12458                 {\cf19 break};\par
12459             {\cf19 default}:\par
12460                 {\cf19 break};\par
12461         \}\par
12462 \par
12463         {\cf19 if}( result.hasExpression() )\par
12464             m_xml.endElement();\par
12465 \par
12466         {\cf19 return} {\cf17 true};\par
12467     \}\par
12468 \par
12469     {\cf18 void} XmlReporter::sectionEnded( SectionStats {\cf17 const}& sectionStats ) \{\par
12470         StreamingReporterBase::sectionEnded( sectionStats );\par
12471         {\cf19 if}( --m_sectionDepth > 0 ) \{\par
12472             XmlWriter::ScopedElement e = m_xml.scopedElement( {\cf22 "OverallResults"} );\par
12473             e.writeAttribute( {\cf22 "successes"}, sectionStats.assertions.passed );\par
12474             e.writeAttribute( {\cf22 "failures"}, sectionStats.assertions.failed );\par
12475             e.writeAttribute( {\cf22 "expectedFailures"}, sectionStats.assertions.failedButOk );\par
12476 \par
12477             {\cf19 if} ( m_config->showDurations() == ShowDurations::Always )\par
12478                 e.writeAttribute( {\cf22 "durationInSeconds"}, sectionStats.durationInSeconds );\par
12479 \par
12480             m_xml.endElement();\par
12481         \}\par
12482     \}\par
12483 \par
12484     {\cf18 void} XmlReporter::testCaseEnded( TestCaseStats {\cf17 const}& testCaseStats ) \{\par
12485         StreamingReporterBase::testCaseEnded( testCaseStats );\par
12486         XmlWriter::ScopedElement e = m_xml.scopedElement( {\cf22 "OverallResult"} );\par
12487         e.writeAttribute( {\cf22 "success"}, testCaseStats.totals.assertions.allOk() );\par
12488 \par
12489         {\cf19 if} ( m_config->showDurations() == ShowDurations::Always )\par
12490             e.writeAttribute( {\cf22 "durationInSeconds"}, m_testCaseTimer.getElapsedSeconds() );\par
12491 \par
12492         {\cf19 if}( !testCaseStats.stdOut.empty() )\par
12493             m_xml.scopedElement( {\cf22 "StdOut"} ).writeText( trim( testCaseStats.stdOut ), {\cf17 false} );\par
12494         {\cf19 if}( !testCaseStats.stdErr.empty() )\par
12495             m_xml.scopedElement( {\cf22 "StdErr"} ).writeText( trim( testCaseStats.stdErr ), {\cf17 false} );\par
12496 \par
12497         m_xml.endElement();\par
12498     \}\par
12499 \par
12500     {\cf18 void} XmlReporter::testGroupEnded( TestGroupStats {\cf17 const}& testGroupStats ) \{\par
12501         StreamingReporterBase::testGroupEnded( testGroupStats );\par
12502         {\cf20 // TODO: Check testGroupStats.aborting and act accordingly.}\par
12503         m_xml.scopedElement( {\cf22 "OverallResults"} )\par
12504             .writeAttribute( {\cf22 "successes"}, testGroupStats.totals.assertions.passed )\par
12505             .writeAttribute( {\cf22 "failures"}, testGroupStats.totals.assertions.failed )\par
12506             .writeAttribute( {\cf22 "expectedFailures"}, testGroupStats.totals.assertions.failedButOk );\par
12507         m_xml.endElement();\par
12508     \}\par
12509 \par
12510     {\cf18 void} XmlReporter::testRunEnded( TestRunStats {\cf17 const}& testRunStats ) \{\par
12511         StreamingReporterBase::testRunEnded( testRunStats );\par
12512         m_xml.scopedElement( {\cf22 "OverallResults"} )\par
12513             .writeAttribute( {\cf22 "successes"}, testRunStats.totals.assertions.passed )\par
12514             .writeAttribute( {\cf22 "failures"}, testRunStats.totals.assertions.failed )\par
12515             .writeAttribute( {\cf22 "expectedFailures"}, testRunStats.totals.assertions.failedButOk );\par
12516         m_xml.endElement();\par
12517     \}\par
12518 \par
12519     CATCH_REGISTER_REPORTER( {\cf22 "xml"}, XmlReporter )\par
12520 \par
12521 \} {\cf20 // end namespace Catch}\par
12522 \par
12523 {\cf21 #if defined(_MSC_VER)}\par
12524 {\cf21 #pragma warning(pop)}\par
12525 {\cf21 #endif}\par
12526 {\cf20 // end catch_reporter_xml.cpp}\par
12527 \par
12528 {\cf17 namespace }Catch \{\par
12529     LeakDetector leakDetector;\par
12530 \}\par
12531 \par
12532 {\cf21 #ifdef __clang__}\par
12533 {\cf21 #pragma clang diagnostic pop}\par
12534 {\cf21 #endif}\par
12535 \par
12536 {\cf20 // end catch_impl.hpp}\par
12537 {\cf21 #endif}\par
12538 \par
12539 {\cf21 #ifdef CATCH_CONFIG_MAIN}\par
12540 {\cf20 // start catch_default_main.hpp}\par
12541 \par
12542 {\cf21 #ifndef __OBJC__}\par
12543 \par
12544 {\cf21 #if defined(CATCH_CONFIG_WCHAR) && defined(WIN32) && defined(_UNICODE) && !defined(DO_NOT_USE_WMAIN)}\par
12545 {\cf20 // Standard C/C++ Win32 Unicode wmain entry point}\par
12546 {\cf17 extern} {\cf22 "C"} {\cf18 int} wmain ({\cf18 int} argc, {\cf18 wchar_t} * argv[], {\cf18 wchar_t} * []) \{\par
12547 {\cf21 #else}\par
12548 {\cf20 // Standard C/C++ main entry point}\par
12549 {\cf18 int} main ({\cf18 int} argc, {\cf18 char} * argv[]) \{\par
12550 {\cf21 #endif}\par
12551 \par
12552     {\cf19 return} Catch::Session().run( argc, argv );\par
12553 \}\par
12554 \par
12555 {\cf21 #else }{\cf20 // __OBJC__}\par
12556 \par
12557 {\cf20 // Objective-C entry point}\par
12558 {\cf18 int} main ({\cf18 int} argc, {\cf18 char} * {\cf17 const} argv[]) \{\par
12559 {\cf21 #if !CATCH_ARC_ENABLED}\par
12560     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];\par
12561 {\cf21 #endif}\par
12562 \par
12563     Catch::registerTestMethods();\par
12564     {\cf18 int} result = Catch::Session().run( argc, ({\cf18 char}**)argv );\par
12565 \par
12566 {\cf21 #if !CATCH_ARC_ENABLED}\par
12567     [pool drain];\par
12568 {\cf21 #endif}\par
12569 \par
12570     {\cf19 return} result;\par
12571 \}\par
12572 \par
12573 {\cf21 #endif }{\cf20 // __OBJC__}\par
12574 \par
12575 {\cf20 // end catch_default_main.hpp}\par
12576 {\cf21 #endif}\par
12577 \par
12578 {\cf21 #if !defined(CATCH_CONFIG_IMPL_ONLY)}\par
12579 \par
12580 {\cf21 #ifdef CLARA_CONFIG_MAIN_NOT_DEFINED}\par
12581 {\cf21 #  undef CLARA_CONFIG_MAIN}\par
12582 {\cf21 #endif}\par
12583 \par
12584 {\cf21 #if !defined(CATCH_CONFIG_DISABLE)}\par
12586 {\cf20 // If this config identifier is defined then all CATCH macros are prefixed with CATCH_}\par
12587 {\cf21 #ifdef CATCH_CONFIG_PREFIX_ALL}\par
12588 \par
12589 {\cf21 #define CATCH_REQUIRE( ... ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE"}, Catch::ResultDisposition::Normal, __VA_ARGS__ )\par
12590 {\cf21 #define CATCH_REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE_FALSE"}, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )\par
12591 \par
12592 {\cf21 #define CATCH_REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( "CATCH_REQUIRE_THROWS"}, Catch::ResultDisposition::Normal, "", __VA_ARGS__ )\par
12593 {\cf21 #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_REQUIRE_THROWS_AS"}, exceptionType, Catch::ResultDisposition::Normal, expr )\par
12594 {\cf21 #define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_REQUIRE_THROWS_WITH"}, Catch::ResultDisposition::Normal, matcher, expr )\par
12595 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)}\par
12596 {\cf21 #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_REQUIRE_THROWS_MATCHES"}, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )\par
12597 {\cf21 #endif}{\cf20 // CATCH_CONFIG_DISABLE_MATCHERS}\par
12598 {\cf21 #define CATCH_REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CATCH_REQUIRE_NOTHROW"}, Catch::ResultDisposition::Normal, __VA_ARGS__ )\par
12599 \par
12600 {\cf21 #define CATCH_CHECK( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK"}, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\par
12601 {\cf21 #define CATCH_CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK_FALSE"}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )\par
12602 {\cf21 #define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( "CATCH_CHECKED_IF"}, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\par
12603 {\cf21 #define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( "CATCH_CHECKED_ELSE"}, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\par
12604 {\cf21 #define CATCH_CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK_NOFAIL"}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\par
12605 \par
12606 {\cf21 #define CATCH_CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( "CATCH_CHECK_THROWS"}, Catch::ResultDisposition::ContinueOnFailure, "", __VA_ARGS__ )\par
12607 {\cf21 #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_CHECK_THROWS_AS"}, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )\par
12608 {\cf21 #define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_CHECK_THROWS_WITH"}, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )\par
12609 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)}\par
12610 {\cf21 #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_CHECK_THROWS_MATCHES"}, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )\par
12611 {\cf21 #endif }{\cf20 // CATCH_CONFIG_DISABLE_MATCHERS}\par
12612 {\cf21 #define CATCH_CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CATCH_CHECK_NOTHROW"}, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\par
12613 \par
12614 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)}\par
12615 {\cf21 #define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_CHECK_THAT"}, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )\par
12616 \par
12617 {\cf21 #define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_REQUIRE_THAT"}, matcher, Catch::ResultDisposition::Normal, arg )\par
12618 {\cf21 #endif }{\cf20 // CATCH_CONFIG_DISABLE_MATCHERS}\par
12619 \par
12620 {\cf21 #define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( "CATCH_INFO"}, msg )\par
12621 {\cf21 #define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( "CATCH_WARN"}, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )\par
12622 {\cf21 #define CATCH_CAPTURE( msg ) INTERNAL_CATCH_INFO( "CATCH_CAPTURE"}, #msg " := " << ::Catch::Detail::stringify(msg) )\par
12623 \par
12624 {\cf21 #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )}\par
12625 {\cf21 #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
12626 {\cf21 #define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )}\par
12627 {\cf21 #define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )}\par
12628 {\cf21 #define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )}\par
12629 {\cf21 #define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL"}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )\par
12630 {\cf21 #define CATCH_FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL_CHECK"}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\par
12631 {\cf21 #define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( "CATCH_SUCCEED"}, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\par
12632 \par
12633 {\cf21 #define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()}\par
12634 \par
12635 {\cf20 // "BDD-style" convenience wrappers}\par
12636 {\cf21 #define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( "Scenario: "} __VA_ARGS__ )\par
12637 {\cf21 #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: "} __VA_ARGS__ )\par
12638 {\cf21 #define CATCH_GIVEN( desc )    CATCH_SECTION( std::string( "Given: "}) + desc )\par
12639 {\cf21 #define CATCH_WHEN( desc )     CATCH_SECTION( std::string( " When: "}) + desc )\par
12640 {\cf21 #define CATCH_AND_WHEN( desc ) CATCH_SECTION( std::string( "  And: "}) + desc )\par
12641 {\cf21 #define CATCH_THEN( desc )     CATCH_SECTION( std::string( " Then: "}) + desc )\par
12642 {\cf21 #define CATCH_AND_THEN( desc ) CATCH_SECTION( std::string( "  And: "}) + desc )\par
12643 \par
12644 {\cf20 // If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required}\par
12645 {\cf21 #else}\par
12646 \par
12647 {\cf21 #define REQUIRE( ... ) INTERNAL_CATCH_TEST( "REQUIRE"}, Catch::ResultDisposition::Normal, __VA_ARGS__  )\par
12648 {\cf21 #define REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( "REQUIRE_FALSE"}, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )\par
12649 \par
12650 {\cf21 #define REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( "REQUIRE_THROWS"}, Catch::ResultDisposition::Normal, __VA_ARGS__ )\par
12651 {\cf21 #define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "REQUIRE_THROWS_AS"}, exceptionType, Catch::ResultDisposition::Normal, expr )\par
12652 {\cf21 #define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "REQUIRE_THROWS_WITH"}, Catch::ResultDisposition::Normal, matcher, expr )\par
12653 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)}\par
12654 {\cf21 #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "REQUIRE_THROWS_MATCHES"}, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )\par
12655 {\cf21 #endif }{\cf20 // CATCH_CONFIG_DISABLE_MATCHERS}\par
12656 {\cf21 #define REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "REQUIRE_NOTHROW"}, Catch::ResultDisposition::Normal, __VA_ARGS__ )\par
12657 \par
12658 {\cf21 #define CHECK( ... ) INTERNAL_CATCH_TEST( "CHECK"}, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\par
12659 {\cf21 #define CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( "CHECK_FALSE"}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )\par
12660 {\cf21 #define CHECKED_IF( ... ) INTERNAL_CATCH_IF( "CHECKED_IF"}, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\par
12661 {\cf21 #define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( "CHECKED_ELSE"}, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\par
12662 {\cf21 #define CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( "CHECK_NOFAIL"}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\par
12663 \par
12664 {\cf21 #define CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( "CHECK_THROWS"}, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\par
12665 {\cf21 #define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CHECK_THROWS_AS"}, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )\par
12666 {\cf21 #define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CHECK_THROWS_WITH"}, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )\par
12667 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)}\par
12668 {\cf21 #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CHECK_THROWS_MATCHES"}, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )\par
12669 {\cf21 #endif }{\cf20 // CATCH_CONFIG_DISABLE_MATCHERS}\par
12670 {\cf21 #define CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CHECK_NOTHROW"}, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\par
12671 \par
12672 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)}\par
12673 {\cf21 #define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CHECK_THAT"}, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )\par
12674 \par
12675 {\cf21 #define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "REQUIRE_THAT"}, matcher, Catch::ResultDisposition::Normal, arg )\par
12676 {\cf21 #endif }{\cf20 // CATCH_CONFIG_DISABLE_MATCHERS}\par
12677 \par
12678 {\cf21 #define INFO( msg ) INTERNAL_CATCH_INFO( "INFO"}, msg )\par
12679 {\cf21 #define WARN( msg ) INTERNAL_CATCH_MSG( "WARN"}, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )\par
12680 {\cf21 #define CAPTURE( msg ) INTERNAL_CATCH_INFO( "CAPTURE"}, #msg " := " << ::Catch::Detail::stringify(msg) )\par
12681 \par
12682 {\cf21 #define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )}\par
12683 {\cf21 #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
12684 {\cf21 #define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )}\par
12685 {\cf21 #define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )}\par
12686 {\cf21 #define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )}\par
12687 {\cf21 #define FAIL( ... ) INTERNAL_CATCH_MSG( "FAIL"}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )\par
12688 {\cf21 #define FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "FAIL_CHECK"}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\par
12689 {\cf21 #define SUCCEED( ... ) INTERNAL_CATCH_MSG( "SUCCEED"}, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\par
12690 {\cf21 #define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()}\par
12691 \par
12692 {\cf21 #endif}\par
12693 \par
12694 {\cf21 #define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )}\par
12695 \par
12696 {\cf20 // "BDD-style" convenience wrappers}\par
12697 {\cf21 #define SCENARIO( ... ) TEST_CASE( "Scenario: "} __VA_ARGS__ )\par
12698 {\cf21 #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: "} __VA_ARGS__ )\par
12699 \par
12700 {\cf21 #define GIVEN( desc )    SECTION( std::string("   Given: "}) + desc )\par
12701 {\cf21 #define WHEN( desc )     SECTION( std::string("    When: "}) + desc )\par
12702 {\cf21 #define AND_WHEN( desc ) SECTION( std::string("And when: "}) + desc )\par
12703 {\cf21 #define THEN( desc )     SECTION( std::string("    Then: "}) + desc )\par
12704 {\cf21 #define AND_THEN( desc ) SECTION( std::string("     And: "}) + desc )\par
12705 \par
12706 {\cf17 using }Catch::Detail::Approx;\par
12707 \par
12708 {\cf21 #else}\par
12710 {\cf20 // If this config identifier is defined then all CATCH macros are prefixed with CATCH_}\par
12711 {\cf21 #ifdef CATCH_CONFIG_PREFIX_ALL}\par
12712 \par
12713 {\cf21 #define CATCH_REQUIRE( ... )        (void)(0)}\par
12714 {\cf21 #define CATCH_REQUIRE_FALSE( ... )  (void)(0)}\par
12715 \par
12716 {\cf21 #define CATCH_REQUIRE_THROWS( ... ) (void)(0)}\par
12717 {\cf21 #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)}\par
12718 {\cf21 #define CATCH_REQUIRE_THROWS_WITH( expr, matcher )     (void)(0)}\par
12719 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)}\par
12720 {\cf21 #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)}\par
12721 {\cf21 #endif}{\cf20 // CATCH_CONFIG_DISABLE_MATCHERS}\par
12722 {\cf21 #define CATCH_REQUIRE_NOTHROW( ... ) (void)(0)}\par
12723 \par
12724 {\cf21 #define CATCH_CHECK( ... )         (void)(0)}\par
12725 {\cf21 #define CATCH_CHECK_FALSE( ... )   (void)(0)}\par
12726 {\cf21 #define CATCH_CHECKED_IF( ... )    if (__VA_ARGS__)}\par
12727 {\cf21 #define CATCH_CHECKED_ELSE( ... )  if (!(__VA_ARGS__))}\par
12728 {\cf21 #define CATCH_CHECK_NOFAIL( ... )  (void)(0)}\par
12729 \par
12730 {\cf21 #define CATCH_CHECK_THROWS( ... )  (void)(0)}\par
12731 {\cf21 #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) (void)(0)}\par
12732 {\cf21 #define CATCH_CHECK_THROWS_WITH( expr, matcher )     (void)(0)}\par
12733 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)}\par
12734 {\cf21 #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)}\par
12735 {\cf21 #endif }{\cf20 // CATCH_CONFIG_DISABLE_MATCHERS}\par
12736 {\cf21 #define CATCH_CHECK_NOTHROW( ... ) (void)(0)}\par
12737 \par
12738 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)}\par
12739 {\cf21 #define CATCH_CHECK_THAT( arg, matcher )   (void)(0)}\par
12740 \par
12741 {\cf21 #define CATCH_REQUIRE_THAT( arg, matcher ) (void)(0)}\par
12742 {\cf21 #endif }{\cf20 // CATCH_CONFIG_DISABLE_MATCHERS}\par
12743 \par
12744 {\cf21 #define CATCH_INFO( msg )    (void)(0)}\par
12745 {\cf21 #define CATCH_WARN( msg )    (void)(0)}\par
12746 {\cf21 #define CATCH_CAPTURE( msg ) (void)(0)}\par
12747 \par
12748 {\cf21 #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))}\par
12749 {\cf21 #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))}\par
12750 {\cf21 #define CATCH_METHOD_AS_TEST_CASE( method, ... )}\par
12751 {\cf21 #define CATCH_REGISTER_TEST_CASE( Function, ... ) (void)(0)}\par
12752 {\cf21 #define CATCH_SECTION( ... )}\par
12753 {\cf21 #define CATCH_FAIL( ... ) (void)(0)}\par
12754 {\cf21 #define CATCH_FAIL_CHECK( ... ) (void)(0)}\par
12755 {\cf21 #define CATCH_SUCCEED( ... ) (void)(0)}\par
12756 \par
12757 {\cf21 #define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))}\par
12758 \par
12759 {\cf20 // "BDD-style" convenience wrappers}\par
12760 {\cf21 #define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))}\par
12761 {\cf21 #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )}\par
12762 {\cf21 #define CATCH_GIVEN( desc )}\par
12763 {\cf21 #define CATCH_WHEN( desc )}\par
12764 {\cf21 #define CATCH_AND_WHEN( desc )}\par
12765 {\cf21 #define CATCH_THEN( desc )}\par
12766 {\cf21 #define CATCH_AND_THEN( desc )}\par
12767 \par
12768 {\cf20 // If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required}\par
12769 {\cf21 #else}\par
12770 \par
12771 {\cf21 #define REQUIRE( ... )       (void)(0)}\par
12772 {\cf21 #define REQUIRE_FALSE( ... ) (void)(0)}\par
12773 \par
12774 {\cf21 #define REQUIRE_THROWS( ... ) (void)(0)}\par
12775 {\cf21 #define REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)}\par
12776 {\cf21 #define REQUIRE_THROWS_WITH( expr, matcher ) (void)(0)}\par
12777 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)}\par
12778 {\cf21 #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)}\par
12779 {\cf21 #endif }{\cf20 // CATCH_CONFIG_DISABLE_MATCHERS}\par
12780 {\cf21 #define REQUIRE_NOTHROW( ... ) (void)(0)}\par
12781 \par
12782 {\cf21 #define CHECK( ... ) (void)(0)}\par
12783 {\cf21 #define CHECK_FALSE( ... ) (void)(0)}\par
12784 {\cf21 #define CHECKED_IF( ... ) if (__VA_ARGS__)}\par
12785 {\cf21 #define CHECKED_ELSE( ... ) if (!(__VA_ARGS__))}\par
12786 {\cf21 #define CHECK_NOFAIL( ... ) (void)(0)}\par
12787 \par
12788 {\cf21 #define CHECK_THROWS( ... )  (void)(0)}\par
12789 {\cf21 #define CHECK_THROWS_AS( expr, exceptionType ) (void)(0)}\par
12790 {\cf21 #define CHECK_THROWS_WITH( expr, matcher ) (void)(0)}\par
12791 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)}\par
12792 {\cf21 #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)}\par
12793 {\cf21 #endif }{\cf20 // CATCH_CONFIG_DISABLE_MATCHERS}\par
12794 {\cf21 #define CHECK_NOTHROW( ... ) (void)(0)}\par
12795 \par
12796 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_MATCHERS)}\par
12797 {\cf21 #define CHECK_THAT( arg, matcher ) (void)(0)}\par
12798 \par
12799 {\cf21 #define REQUIRE_THAT( arg, matcher ) (void)(0)}\par
12800 {\cf21 #endif }{\cf20 // CATCH_CONFIG_DISABLE_MATCHERS}\par
12801 \par
12802 {\cf21 #define INFO( msg ) (void)(0)}\par
12803 {\cf21 #define WARN( msg ) (void)(0)}\par
12804 {\cf21 #define CAPTURE( msg ) (void)(0)}\par
12805 \par
12806 {\cf21 #define TEST_CASE( ... )  INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))}\par
12807 {\cf21 #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))}\par
12808 {\cf21 #define METHOD_AS_TEST_CASE( method, ... )}\par
12809 {\cf21 #define REGISTER_TEST_CASE( Function, ... ) (void)(0)}\par
12810 {\cf21 #define SECTION( ... )}\par
12811 {\cf21 #define FAIL( ... ) (void)(0)}\par
12812 {\cf21 #define FAIL_CHECK( ... ) (void)(0)}\par
12813 {\cf21 #define SUCCEED( ... ) (void)(0)}\par
12814 {\cf21 #define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))}\par
12815 \par
12816 {\cf21 #endif}\par
12817 \par
12818 {\cf21 #define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )}\par
12819 \par
12820 {\cf20 // "BDD-style" convenience wrappers}\par
12821 {\cf21 #define SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ) )}\par
12822 {\cf21 #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )}\par
12823 \par
12824 {\cf21 #define GIVEN( desc )}\par
12825 {\cf21 #define WHEN( desc )}\par
12826 {\cf21 #define AND_WHEN( desc )}\par
12827 {\cf21 #define THEN( desc )}\par
12828 {\cf21 #define AND_THEN( desc )}\par
12829 \par
12830 {\cf17 using }Catch::Detail::Approx;\par
12831 \par
12832 {\cf21 #endif}\par
12833 \par
12834 {\cf21 #endif }{\cf20 // ! CATCH_CONFIG_IMPL_ONLY}\par
12835 \par
12836 {\cf20 // start catch_reenable_warnings.h}\par
12837 \par
12838 \par
12839 {\cf21 #ifdef __clang__}\par
12840 {\cf21 #    ifdef __ICC }{\cf20 // icpc defines the __clang__ macro}\par
12841 {\cf21 #        pragma warning(pop)}\par
12842 {\cf21 #    else}\par
12843 {\cf21 #        pragma clang diagnostic pop}\par
12844 {\cf21 #    endif}\par
12845 {\cf21 #elif defined __GNUC__}\par
12846 {\cf21 #    pragma GCC diagnostic pop}\par
12847 {\cf21 #endif}\par
12848 \par
12849 {\cf20 // end catch_reenable_warnings.h}\par
12850 {\cf20 // end catch.hpp}\par
12851 {\cf21 #endif }{\cf20 // TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED}\par
12852 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo desafio_8_rainhas/rainhas.cpp\par \pard\plain 
{\tc\tcl2 \v desafio_8_rainhas/rainhas.cpp}
{\xe \v desafio_8_rainhas/rainhas.cpp}
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "/rainhas.hpp"}\par
{\f2 #include <vector>}\par
{\f2 #include <algorithm>}\par
{\f2 #include <fstream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b posicao} (const std::vector< std::vector< int > > &tab, int li, int co)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ataques_rainhas} (const std::vector< std::vector< int > > &tab)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b checar_solucao} (const std::vector< int > &tab)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v ataques_rainhas\:rainhas.cpp}
{\xe \v rainhas.cpp\:ataques_rainhas}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ataques_rainhas (const std::vector< std::vector< int > > &  {\i tab})}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 31                                                            \{\par
32     std::ofstream outputFile({\cf22 "ataques_rainhas.txt"});\par
33     {\cf18 int} n = tab.size();\par
34 \par
35     {\cf20 // Percorre todas as posi\'E7\'F5es do tab}\par
36     {\cf19 for} ({\cf18 int} li = 0; li < n; li++) \{\par
37         {\cf19 for} ({\cf18 int} co = 0; co < n; co++) \{\par
38             {\cf20 // Verifica se h\'E1 uma rainha na posi\'E7\'E3o (li, co)}\par
39             {\cf19 if} (tab[li][co] == 1) \{\par
40                 {\cf20 // Verifica se ela se ataca com outras rainhas}\par
41                 {\cf19 for} ({\cf18 int} i = 0; i < n; i++) \{\par
42                     {\cf19 for} ({\cf18 int} j = 0; j < n; j++) \{\par
43                         {\cf19 if} (i != li && j != co) \{\par
44                             {\cf19 if} (tab[i][j] == 1 && !posicao(tab, i, j)) \{\par
45 outputFile << {\cf22 "("} << li << {\cf22 ","} << co << {\cf22 ")at("} << i << {\cf22 ","} << j <<{\cf22 ")\\n"};\par
46                             \}\par
47                         \}\par
48                     \}\par
49                 \}\par
50             \}\par
51         \}\par
52     \}\par
53 \par
54     outputFile.close();\par
55 \}\par
}
}
{\xe \v checar_solucao\:rainhas.cpp}
{\xe \v rainhas.cpp\:checar_solucao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int checar_solucao (const std::vector< int > &  {\i tab})}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 57                                               \{\par
58     {\cf18 int} n = tab.size();\par
59     {\cf19 if} (n != 64) \{\par
60         {\cf19 return} -1;\par
61     \}\par
62 \par
63     std::vector<std::vector<int>> xadrez(8, std::vector<int>(8, 0));\par
64 \par
65     {\cf20 // Preenche o tab com base no vetor tab}\par
66     {\cf19 for} ({\cf18 int} i = 0; i < n; i++) \{\par
67         {\cf18 int} li = i / 8;\par
68         {\cf18 int} co = i % 8;\par
69         xadrez[li][co] = tab[i];\par
70     \}\par
71 \par
72     {\cf20 // Verifica se h\'E1 mais de 8 rainhas}\par
73     {\cf18 int} numQueens = 0;\par
74     {\cf19 for} ({\cf17 const} {\cf17 auto}& li : xadrez) \{\par
75         numQueens += std::count(li.begin(), li.end(), 1);\par
76         {\cf19 if} (numQueens > 8) \{\par
77             {\cf19 return} -1;\par
78         \}\par
79     \}\par
80 \par
81     {\cf20 // Verifica se as rainhas est\'E3o em posi\'E7\'F5es seguras}\par
82     {\cf19 for} ({\cf18 int} li = 0; li < 8; li++) \{\par
83         {\cf19 for} ({\cf18 int} co = 0; co < 8; co++) \{\par
84             {\cf19 if} (xadrez[li][co] == 1 && !posicao(xadrez, li, co)) \{\par
85                 {\cf20 // Rainhas se atacam, escreve no arquivo de sa\'EDda}\par
86                 ataques_rainhas(xadrez);\par
87                 {\cf19 return} 0;\par
88             \}\par
89         \}\par
90     \}\par
91 \par
92     {\cf19 return} 1;\par
93 \}\par
}
}
{\xe \v posicao\:rainhas.cpp}
{\xe \v rainhas.cpp\:posicao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool posicao (const std::vector< std::vector< int > > &  {\i tab}, int  {\i li}, int  {\i co})}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7                                                                    \{\par
8     {\cf18 int} n = tab.size();\par
9 \par
10     {\cf20 // Verifica se h\'E1 uma rainha na mesma couna}\par
11     {\cf19 for} ({\cf18 int} i = 0; i < li; i++) \{\par
12         {\cf19 if} (tab[i][co] == 1)\par
13             {\cf19 return} {\cf17 false};\par
14     \}\par
15 \par
16     {\cf20 // Verifica se h\'E1 uma rainha na diagonal superior esquerda}\par
17     {\cf19 for} ({\cf18 int} i = li-1, j = co-1; i >= 0 && j >= 0; i--, j--) \{\par
18         {\cf19 if} (tab[i][j] == 1)\par
19             {\cf19 return} {\cf17 false};\par
20     \}\par
21 \par
22     {\cf20 // Verifica se h\'E1 uma rainha na diagonal superior direita}\par
23     {\cf19 for} ({\cf18 int} i = li-1, j = co+1; i >= 0 && j < n; i--, j++) \{\par
24         {\cf19 if} (tab[i][j] == 1)\par
25             {\cf19 return} {\cf17 false};\par
26     \}\par
27 \par
28     {\cf19 return} {\cf17 true};\par
29 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo desafio_8_rainhas/rainhas.hpp\par \pard\plain 
{\tc\tcl2 \v desafio_8_rainhas/rainhas.hpp}
{\xe \v desafio_8_rainhas/rainhas.hpp}
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b checar_solucao} (const std::vector< int > &tab)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v checar_solucao\:rainhas.hpp}
{\xe \v rainhas.hpp\:checar_solucao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int checar_solucao (const std::vector< int > &  {\i tab})}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 57                                               \{\par
58     {\cf18 int} n = tab.size();\par
59     {\cf19 if} (n != 64) \{\par
60         {\cf19 return} -1;\par
61     \}\par
62 \par
63     std::vector<std::vector<int>> xadrez(8, std::vector<int>(8, 0));\par
64 \par
65     {\cf20 // Preenche o tab com base no vetor tab}\par
66     {\cf19 for} ({\cf18 int} i = 0; i < n; i++) \{\par
67         {\cf18 int} li = i / 8;\par
68         {\cf18 int} co = i % 8;\par
69         xadrez[li][co] = tab[i];\par
70     \}\par
71 \par
72     {\cf20 // Verifica se h\'E1 mais de 8 rainhas}\par
73     {\cf18 int} numQueens = 0;\par
74     {\cf19 for} ({\cf17 const} {\cf17 auto}& li : xadrez) \{\par
75         numQueens += std::count(li.begin(), li.end(), 1);\par
76         {\cf19 if} (numQueens > 8) \{\par
77             {\cf19 return} -1;\par
78         \}\par
79     \}\par
80 \par
81     {\cf20 // Verifica se as rainhas est\'E3o em posi\'E7\'F5es seguras}\par
82     {\cf19 for} ({\cf18 int} li = 0; li < 8; li++) \{\par
83         {\cf19 for} ({\cf18 int} co = 0; co < 8; co++) \{\par
84             {\cf19 if} (xadrez[li][co] == 1 && !posicao(xadrez, li, co)) \{\par
85                 {\cf20 // Rainhas se atacam, escreve no arquivo de sa\'EDda}\par
86                 ataques_rainhas(xadrez);\par
87                 {\cf19 return} 0;\par
88             \}\par
89         \}\par
90     \}\par
91 \par
92     {\cf19 return} 1;\par
93 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
rainhas.hpp\par \pard\plain 
{\tc\tcl2 \v desafio_8_rainhas/rainhas.hpp}
{\xe \v desafio_8_rainhas/rainhas.hpp}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Ir para a documenta\'E7\'E3o desse arquivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 // Copyright[2023] <Vinicius de Camargo Bandeira>}\par
2 {\cf21 #ifndef RAINHAS_HPP_}\par
3 {\cf21 #define RAINHAS_HPP_}\par
4 \par
5 {\cf21 #include <vector>}\par
6 \par
7 \par
8 {\cf18 int} checar_solucao({\cf17 const} std::vector<int>& tab);\par
9 \par
10 {\cf21 #endif  }{\cf20 // RAINHAS_HPP_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo desafio_8_rainhas/README.md\par \pard\plain 
{\tc\tcl2 \v desafio_8_rainhas/README.md}
{\xe \v desafio_8_rainhas/README.md}
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo desafio_8_rainhas/testa_rainhas.cpp\par \pard\plain 
{\tc\tcl2 \v desafio_8_rainhas/testa_rainhas.cpp}
{\xe \v desafio_8_rainhas/testa_rainhas.cpp}
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}\par
{\f2 #include "/rainhas.hpp"}\par
{\f2 #include "/catch.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONFIG_MAIN}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Teste de solu\'E7\'E3o v\'E1lida das 8 damas")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Segundo Teste de solu\'E7\'E3o v\'E1lida das 8 damas")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Tercerio Teste de solu\'E7\'E3o v\'E1lida das 8 damas")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Quarto Teste de solu\'E7\'E3o v\'E1lida das 8 damas")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Quinto Teste de solu\'E7\'E3o v\'E1lida das 8 damas")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Sexto Teste de solu\'E7\'E3o v\'E1lida das 8 damas")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Setimo Teste de solu\'E7\'E3o v\'E1lida das 8 damas")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Oitavo Teste de solu\'E7\'E3o v\'E1lida das 8 damas")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Nono Teste de solu\'E7\'E3o v\'E1lida das 8 damas")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Decimo Teste de solu\'E7\'E3o v\'E1lida das 8 damas")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Decimo primeiro Teste de solu\'E7\'E3o v\'E1lida das 8 damas")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Decimo segundo Teste de solu\'E7\'E3o v\'E1lida das 8 damas")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Segundo Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Terceiro Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Quarto Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Quinto Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Sexto Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Setimo Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Oitavo Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Nono Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Decimo Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("11\'B0 Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("12\'B0 Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("13\'B0 Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("14\'B0 Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("15\'B0 Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("16\'B0 Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Teste de solu\'E7\'E3o inv\'E1lida do tab ou rainhas")\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e macros\par
\pard\plain 
{\xe \v CATCH_CONFIG_MAIN\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:CATCH_CONFIG_MAIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONFIG_MAIN}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("11\'B0 Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida" )}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 373                                                      : solu\'E7\'E3o inv\'E1lida{\cf22 ") \{}\par
374 {\cf22     std::vector<int> tab = \{}\par
375 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
376 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
377 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
378 {\cf22         0, 0, 0, 0, 0, 1, 0, 0,}\par
379 {\cf22         0, 0, 1, 0, 0, 0, 0, 0,}\par
380 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
381 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
382 {\cf22         1, 0, 0, 0, 0, 0, 0, 0}\par
383 {\cf22     \};}\par
384 {\cf22 }\par
385 {\cf22     REQUIRE(checar_solucao(tab) == 0);}\par
386 {\cf22 \}}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("12\'B0 Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida" )}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 388                                                      : solu\'E7\'E3o inv\'E1lida{\cf22 ") \{}\par
389 {\cf22     std::vector<int> tab = \{}\par
390 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
391 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
392 {\cf22         0, 0, 0, 0, 0, 0, 0, 1,}\par
393 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
394 {\cf22         0, 0, 1, 0, 0, 0, 0, 0,}\par
395 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
396 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
397 {\cf22         1, 0, 0, 0, 0, 0, 0, 0}\par
398 {\cf22     \};}\par
399 {\cf22 }\par
400 {\cf22     REQUIRE(checar_solucao(tab) == 0);}\par
401 {\cf22 \}}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("13\'B0 Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida" )}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 403                                                      : solu\'E7\'E3o inv\'E1lida{\cf22 ") \{}\par
404 {\cf22     std::vector<int> tab = \{}\par
405 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
406 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
407 {\cf22         0, 0, 0, 0, 0, 0, 0, 1,}\par
408 {\cf22         0, 0, 0, 0, 0, 1, 0, 0,}\par
409 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
410 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
411 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
412 {\cf22         1, 0, 0, 0, 0, 0, 0, 0}\par
413 {\cf22     \};}\par
414 {\cf22 }\par
415 {\cf22     REQUIRE(checar_solucao(tab) == 0);}\par
416 {\cf22 \}}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("14\'B0 Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida" )}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 418                                                      : solu\'E7\'E3o inv\'E1lida{\cf22 ") \{}\par
419 {\cf22     std::vector<int> tab = \{}\par
420 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
421 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
422 {\cf22         0, 0, 0, 0, 0, 0, 0, 1,}\par
423 {\cf22         0, 0, 0, 0, 0, 1, 0, 0,}\par
424 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
425 {\cf22         0, 0, 0, 0, 0, 0, 0, 1,}\par
426 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
427 {\cf22         0, 1, 0, 0, 0, 0, 0, 0}\par
428 {\cf22     \};}\par
429 {\cf22 }\par
430 {\cf22     REQUIRE(checar_solucao(tab) == 0);}\par
431 {\cf22 \}}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("15\'B0 Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida" )}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 433                                                      : solu\'E7\'E3o inv\'E1lida{\cf22 ") \{}\par
434 {\cf22     std::vector<int> tab = \{}\par
435 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
436 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
437 {\cf22         0, 0, 0, 0, 0, 0, 0, 1,}\par
438 {\cf22         0, 0, 0, 0, 0, 1, 0, 0,}\par
439 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
440 {\cf22         0, 0, 0, 0, 0, 0, 0, 1,}\par
441 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
442 {\cf22         0, 1, 0, 0, 0, 0, 0, 0}\par
443 {\cf22     \};}\par
444 {\cf22 }\par
445 {\cf22     REQUIRE(checar_solucao(tab) == 0);}\par
446 {\cf22 \}}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("16\'B0 Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida" )}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 448                                                      : solu\'E7\'E3o inv\'E1lida{\cf22 ") \{}\par
449 {\cf22     std::vector<int> tab = \{}\par
450 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
451 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
452 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
453 {\cf22         0, 0, 0, 0, 0, 1, 0, 0,}\par
454 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
455 {\cf22         0, 0, 0, 0, 0, 0, 0, 1,}\par
456 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
457 {\cf22         0, 1, 0, 0, 0, 0, 0, 0}\par
458 {\cf22     \};}\par
459 {\cf22 }\par
460 {\cf22     REQUIRE(checar_solucao(tab) == 0);}\par
461 {\cf22 \}}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Decimo primeiro Teste de solu\'E7\'E3o v\'E1lida das 8 damas" )}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 193                                                                     \{\par
194     std::vector<int> tab = \{\par
195         0, 0, 0, 1, 0, 0, 0, 0,\par
196         0, 0, 0, 0, 0, 0, 1, 0,\par
197         1, 0, 0, 0, 0, 0, 0, 0,\par
198         0, 0, 0, 0, 0, 0, 0, 1,\par
199         0, 0, 0, 0, 1, 0, 0, 0,\par
200         0, 1, 0, 0, 0, 0, 0, 0,\par
201         0, 0, 0, 0, 0, 1, 0, 0,\par
202         0, 0, 1, 0, 0, 0, 0, 0\par
203     \};\par
204 \par
205     REQUIRE(checar_solucao(tab) == 1);\par
206 \}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Decimo segundo Teste de solu\'E7\'E3o v\'E1lida das 8 damas" )}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 208                                                                    \{\par
209     std::vector<int> tab = \{\par
210         0, 0, 0, 0, 0, 1, 0, 0,\par
211         0, 0, 0, 1, 0, 0, 0, 0,\par
212         0, 0, 0, 0, 0, 0, 1, 0,\par
213         1, 0, 0, 0, 0, 0, 0, 0,\par
214         0, 0, 0, 0, 0, 0, 0, 1,\par
215         0, 1, 0, 0, 0, 0, 0, 0,\par
216         0, 0, 0, 0, 1, 0, 0, 0,\par
217         0, 0, 1, 0, 0, 0, 0, 0\par
218     \};\par
219 \par
220     REQUIRE(checar_solucao(tab) == 1);\par
221 \}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Decimo Teste de solu\'E7\'E3o v\'E1lida das 8 damas" )}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 178                                                            \{\par
179     std::vector<int> tab = \{\par
180         0, 0, 0, 0, 0, 1, 0, 0,\par
181         0, 1, 0, 0, 0, 0, 0, 0,\par
182         0, 0, 0, 0, 0, 0, 1, 0,\par
183         1, 0, 0, 0, 0, 0, 0, 0,\par
184         0, 0, 0, 1, 0, 0, 0, 0,\par
185         0, 0, 0, 0, 0, 0, 0, 1,\par
186         0, 0, 0, 0, 1, 0, 0, 0,\par
187         0, 0, 1, 0, 0, 0, 0, 0\par
188     \};\par
189 \par
190     REQUIRE(checar_solucao(tab) == 1);\par
191 \}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Decimo Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida" )}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 358                                                        : solu\'E7\'E3o inv\'E1lida{\cf22 ") \{}\par
359 {\cf22     std::vector<int> tab = \{}\par
360 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
361 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
362 {\cf22         0, 0, 0, 0, 0, 0, 0, 1,}\par
363 {\cf22         0, 0, 0, 0, 0, 1, 0, 0,}\par
364 {\cf22         0, 0, 1, 0, 0, 0, 0, 0,}\par
365 {\cf22         0, 0, 0, 0, 0, 0, 0, 1,}\par
366 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
367 {\cf22         1, 0, 0, 0, 0, 0, 0, 0}\par
368 {\cf22     \};}\par
369 {\cf22 }\par
370 {\cf22     REQUIRE(checar_solucao(tab) == 0);}\par
371 {\cf22 \}}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Nono Teste de solu\'E7\'E3o v\'E1lida das 8 damas" )}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 163                                                          \{\par
164     std::vector<int> tab = \{\par
165         0, 0, 1, 0, 0, 0, 0, 0,\par
166         0, 0, 0, 0, 0, 1, 0, 0,\par
167         0, 0, 0, 1, 0, 0, 0, 0,\par
168         1, 0, 0, 0, 0, 0, 0, 0,\par
169         0, 0, 0, 0, 0, 0, 0, 1,\par
170         0, 0, 0, 0, 1, 0, 0, 0,\par
171         0, 0, 0, 0, 0, 0, 1, 0,\par
172         0, 1, 0, 0, 0, 0, 0, 0\par
173     \};\par
174 \par
175     REQUIRE(checar_solucao(tab) == 1);\par
176 \}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Nono Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida" )}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 343                                                      : solu\'E7\'E3o inv\'E1lida{\cf22 ") \{}\par
344 {\cf22     std::vector<int> tab = \{}\par
345 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
346 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
347 {\cf22         0, 0, 0, 0, 0, 0, 0, 1,}\par
348 {\cf22         0, 0, 0, 0, 0, 1, 0, 0,}\par
349 {\cf22         1, 0, 0, 0, 0, 0, 0, 0,}\par
350 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
351 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
352 {\cf22         1, 0, 0, 0, 0, 0, 0, 0}\par
353 {\cf22     \};}\par
354 {\cf22 }\par
355 {\cf22     REQUIRE(checar_solucao(tab) == 0);}\par
356 {\cf22 \}}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Oitavo Teste de solu\'E7\'E3o v\'E1lida das 8 damas" )}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 148                                                            \{\par
149     std::vector<int> tab = \{\par
150         0, 0, 0, 1, 0, 0, 0, 0,\par
151         1, 0, 0, 0, 0, 0, 0, 0,\par
152         0, 0, 0, 0, 1, 0, 0, 0,\par
153         0, 0, 0, 0, 0, 0, 0, 1,\par
154         0, 0, 0, 0, 0, 1, 0, 0,\par
155         0, 0, 1, 0, 0, 0, 0, 0,\par
156         0, 0, 0, 0, 0, 0, 1, 0,\par
157         0, 1, 0, 0, 0, 0, 0, 0\par
158     \};\par
159 \par
160     REQUIRE(checar_solucao(tab) == 1);\par
161 \}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Oitavo Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida" )}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 328                                                        : solu\'E7\'E3o inv\'E1lida{\cf22 ") \{}\par
329 {\cf22     std::vector<int> tab = \{}\par
330 {\cf22         0, 0, 0, 0, 0, 1, 0, 0,}\par
331 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
332 {\cf22         0, 0, 0, 0, 0, 0, 0, 1,}\par
333 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
334 {\cf22         0, 0, 1, 0, 0, 0, 0, 0,}\par
335 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
336 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
337 {\cf22         1, 0, 0, 0, 0, 0, 0, 0}\par
338 {\cf22     \};}\par
339 {\cf22 }\par
340 {\cf22     REQUIRE(checar_solucao(tab) == 0);}\par
341 {\cf22 \}}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Quarto Teste de solu\'E7\'E3o v\'E1lida das 8 damas" )}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
testes {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tab} \cell }{\cell }
{\row }
}
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 88                                                            \{\par
89     std::vector<int> tab = \{\par
90         0, 0, 0, 1, 0, 0, 0, 0,\par
91         0, 0, 0, 0, 0, 1, 0, 0,\par
92         0, 0, 0, 0, 0, 0, 0, 1,\par
93         0, 0, 1, 0, 0, 0, 0, 0,\par
94         1, 0, 0, 0, 0, 0, 0, 0,\par
95         0, 0, 0, 0, 0, 0, 1, 0,\par
96         0, 0, 0, 0, 1, 0, 0, 0,\par
97         0, 1, 0, 0, 0, 0, 0, 0\par
98     \};\par
99 \par
100     REQUIRE(checar_solucao(tab) == 1);\par
101 \}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Quarto Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida" )}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 268                                                        : solu\'E7\'E3o inv\'E1lida{\cf22 ") \{}\par
269 {\cf22     std::vector<int> tab = \{}\par
270 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
271 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
272 {\cf22         0, 0, 0, 0, 0, 0, 0, 1,}\par
273 {\cf22         0, 0, 0, 0, 0, 1, 0, 0,}\par
274 {\cf22         0, 0, 1, 0, 0, 0, 0, 0,}\par
275 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
276 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
277 {\cf22         0, 0, 1, 0, 0, 0, 0, 0}\par
278 {\cf22     \};}\par
279 {\cf22 }\par
280 {\cf22     REQUIRE(checar_solucao(tab) == 0);}\par
281 {\cf22 \}}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Quinto Teste de solu\'E7\'E3o v\'E1lida das 8 damas" )}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 103                                                            \{\par
104     std::vector<int> tab = \{\par
105         0, 0, 1, 0, 0, 0, 0, 0,\par
106         0, 0, 0, 0, 0, 1, 0, 0,\par
107         0, 0, 0, 0, 0, 0, 0, 1,\par
108         1, 0, 0, 0, 0, 0, 0, 0,\par
109         0, 0, 0, 1, 0, 0, 0, 0,\par
110         0, 0, 0, 0, 0, 0, 1, 0,\par
111         0, 0, 0, 0, 1, 0, 0, 0,\par
112         0, 1, 0, 0, 0, 0, 0, 0\par
113     \};\par
114 \par
115     REQUIRE(checar_solucao(tab) == 1);\par
116 \}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Quinto Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida" )}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 283                                                        : solu\'E7\'E3o inv\'E1lida{\cf22 ") \{}\par
284 {\cf22     std::vector<int> tab = \{}\par
285 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
286 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
287 {\cf22         0, 0, 0, 0, 0, 0, 0, 1,}\par
288 {\cf22         0, 0, 0, 0, 0, 1, 0, 0,}\par
289 {\cf22         0, 0, 1, 0, 0, 0, 0, 0,}\par
290 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
291 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
292 {\cf22         1, 0, 0, 0, 0, 0, 0, 0}\par
293 {\cf22     \};}\par
294 {\cf22 }\par
295 {\cf22     REQUIRE(checar_solucao(tab) == 0);}\par
296 {\cf22 \}}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Segundo Teste de solu\'E7\'E3o v\'E1lida das 8 damas" )}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return 1 testes {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tab} \cell }{\cell }
{\row }
}
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 42                                                             \{\par
43     std::vector<int> tab = \{\par
44         0, 0, 0, 1, 0, 0, 0, 0,\par
45         0, 0, 0, 0, 0, 0, 1, 0,\par
46         0, 0, 1, 0, 0, 0, 0, 0,\par
47         0, 0, 0, 0, 0, 0, 0, 1,\par
48         0, 1, 0, 0, 0, 0, 0, 0,\par
49         0, 0, 0, 0, 1, 0, 0, 0,\par
50         1, 0, 0, 0, 0, 0, 0, 0,\par
51         0, 0, 0, 0, 0, 1, 0, 0\par
52     \};\par
53 \par
54     REQUIRE(checar_solucao(tab) == 1);\par
55 \}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Segundo Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida" )}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 238                                                         : solu\'E7\'E3o inv\'E1lida{\cf22 ") \{}\par
239 {\cf22     std::vector<int> tab = \{}\par
240 {\cf22         1, 0, 0, 0, 0, 0, 0, 0,}\par
241 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
242 {\cf22         0, 0, 0, 0, 0, 0, 0, 1,}\par
243 {\cf22         0, 0, 0, 0, 0, 1, 0, 0,}\par
244 {\cf22         0, 0, 1, 0, 0, 0, 0, 0,}\par
245 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
246 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
247 {\cf22         0, 1, 0, 0, 0, 0, 0, 0}\par
248 {\cf22     \};}\par
249 {\cf22 }\par
250 {\cf22     REQUIRE(checar_solucao(tab) == 0);}\par
251 {\cf22 \}}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Setimo Teste de solu\'E7\'E3o v\'E1lida das 8 damas" )}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 133                                                            \{\par
134     std::vector<int> tab = \{\par
135         0, 0, 0, 0, 1, 0, 0, 0,\par
136         0, 0, 0, 0, 0, 0, 1, 0,\par
137         0, 0, 0, 1, 0, 0, 0, 0,\par
138         1, 0, 0, 0, 0, 0, 0, 0,\par
139         0, 0, 1, 0, 0, 0, 0, 0,\par
140         0, 0, 0, 0, 0, 0, 0, 1,\par
141         0, 0, 0, 0, 0, 1, 0, 0,\par
142         0, 1, 0, 0, 0, 0, 0, 0\par
143     \};\par
144 \par
145     REQUIRE(checar_solucao(tab) == 1);\par
146 \}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Setimo Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida" )}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 313                                                        : solu\'E7\'E3o inv\'E1lida{\cf22 ") \{}\par
314 {\cf22     std::vector<int> tab = \{}\par
315 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
316 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
317 {\cf22         0, 0, 0, 0, 0, 0, 0, 1,}\par
318 {\cf22         0, 0, 0, 0, 0, 1, 0, 0,}\par
319 {\cf22         0, 0, 1, 0, 0, 0, 0, 0,}\par
320 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
321 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
322 {\cf22         1, 0, 0, 0, 0, 0, 0, 0}\par
323 {\cf22     \};}\par
324 {\cf22 }\par
325 {\cf22     REQUIRE(checar_solucao(tab) == 0);}\par
326 {\cf22 \}}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Sexto Teste de solu\'E7\'E3o v\'E1lida das 8 damas" )}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 118                                                           \{\par
119     std::vector<int> tab = \{\par
120         0, 0, 0, 0, 1, 0, 0, 0,\par
121         0, 0, 1, 0, 0, 0, 0, 0,\par
122         0, 0, 0, 0, 0, 0, 0, 1,\par
123         0, 0, 0, 1, 0, 0, 0, 0,\par
124         0, 0, 0, 0, 0, 0, 1, 0,\par
125         1, 0, 0, 0, 0, 0, 0, 0,\par
126         0, 0, 0, 0, 0, 1, 0, 0,\par
127         0, 1, 0, 0, 0, 0, 0, 0\par
128     \};\par
129 \par
130     REQUIRE(checar_solucao(tab) == 1);\par
131 \}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Sexto Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida" )}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 298                                                       : solu\'E7\'E3o inv\'E1lida{\cf22 ") \{}\par
299 {\cf22     std::vector<int> tab = \{}\par
300 {\cf22         0, 0, 0, 0, 0, 1, 0, 0,}\par
301 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
302 {\cf22         0, 0, 0, 0, 0, 0, 0, 1,}\par
303 {\cf22         0, 0, 0, 0, 0, 1, 0, 0,}\par
304 {\cf22         0, 0, 1, 0, 0, 0, 0, 0,}\par
305 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
306 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
307 {\cf22         1, 0, 0, 0, 0, 0, 0, 0}\par
308 {\cf22     \};}\par
309 {\cf22 }\par
310 {\cf22     REQUIRE(checar_solucao(tab) == 0);}\par
311 {\cf22 \}}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Terceiro Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida" )}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 253                                                          : solu\'E7\'E3o inv\'E1lida{\cf22 ") \{}\par
254 {\cf22     std::vector<int> tab = \{}\par
255 {\cf22         1, 0, 0, 0, 0, 0, 0, 0,}\par
256 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
257 {\cf22         0, 0, 0, 0, 0, 0, 0, 1,}\par
258 {\cf22         0, 0, 0, 0, 0, 1, 0, 0,}\par
259 {\cf22         0, 0, 1, 0, 0, 0, 0, 0,}\par
260 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
261 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
262 {\cf22         0, 0, 1, 0, 0, 0, 0, 0}\par
263 {\cf22     \};}\par
264 {\cf22 }\par
265 {\cf22     REQUIRE(checar_solucao(tab) == 0);}\par
266 {\cf22 \}}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Tercerio Teste de solu\'E7\'E3o v\'E1lida das 8 damas" )}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
testes {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tab} \cell }{\cell }
{\row }
}
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 66                                                              \{\par
67     std::vector<int> tab = \{\par
68         0, 0, 0, 0, 1, 0, 0, 0,\par
69         0, 1, 0, 0, 0, 0, 0, 0,\par
70         0, 0, 0, 1, 0, 0, 0, 0,\par
71         0, 0, 0, 0, 0, 0, 1, 0,\par
72         0, 0, 1, 0, 0, 0, 0, 0,\par
73         0, 0, 0, 0, 0, 0, 0, 1,\par
74         0, 0, 0, 0, 0, 1, 0, 0,\par
75         1, 0, 0, 0, 0, 0, 0, 0\par
76     \};\par
77 \par
78     REQUIRE(checar_solucao(tab) == 1);\par
79 \}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Teste de solu\'E7\'E3o inv\'E1lida do tab ou rainhas" )}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 463                                                             \{\par
464     std::vector<int> tab = \{\par
465         1, 0, 0, 0, 0, 0, 0, 0,\par
466         0, 0, 0, 0, 1, 0, 0, 0,\par
467         0, 0, 0, 0, 0, 0, 0, 1,\par
468         0, 0, 0, 0, 0, 1, 0, 0,\par
469         0, 0, 1, 0, 0, 0, 0, 0,\par
470         0, 0, 0, 0, 0, 0, 1, 0,\par
471         0, 1, 0, 0, 0, 0, 0, 0,\par
472         0, 0, 0, 1, 1, 0\par
473     \};\par
474 \par
475     REQUIRE(checar_solucao(tab) == -1);\par
476 \}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Teste de solu\'E7\'E3o v\'E1lida das 8 damas" )}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
testes {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tab} \cell }{\cell }
{\row }
}
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13                                                     \{\par
14     std::vector<int> tab = \{\par
15         1, 0, 0, 0, 0, 0, 0, 0,\par
16         0, 0, 0, 0, 1, 0, 0, 0,\par
17         0, 0, 0, 0, 0, 0, 0, 1,\par
18         0, 0, 0, 0, 0, 1, 0, 0,\par
19         0, 0, 1, 0, 0, 0, 0, 0,\par
20         0, 0, 0, 0, 0, 0, 1, 0,\par
21         0, 1, 0, 0, 0, 0, 0, 0,\par
22         0, 0, 0, 1, 0, 0, 0, 0\par
23     \};\par
24 \par
25     REQUIRE(checar_solucao(tab) == 1);\par
26 \}\par
}
}
{\xe \v TEST_CASE\:testa_rainhas.cpp}
{\xe \v testa_rainhas.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Teste de valida\'E7\'E3o do tab inv\'E1lido: solu\'E7\'E3o inv\'E1lida" )}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 223                                                 : solu\'E7\'E3o inv\'E1lida{\cf22 ") \{}\par
224 {\cf22     std::vector<int> tab = \{}\par
225 {\cf22         1, 0, 0, 0, 0, 0, 0, 0,}\par
226 {\cf22         0, 0, 0, 0, 1, 0, 0, 0,}\par
227 {\cf22         0, 0, 0, 0, 0, 0, 0, 1,}\par
228 {\cf22         0, 0, 0, 0, 0, 1, 0, 0,}\par
229 {\cf22         0, 0, 1, 0, 0, 0, 0, 0,}\par
230 {\cf22         0, 0, 0, 0, 0, 0, 1, 0,}\par
231 {\cf22         0, 1, 0, 0, 0, 0, 0, 0,}\par
232 {\cf22         1, 0, 0, 0, 0, 0, 0, 0}\par
233 {\cf22     \};}\par
234 {\cf22 }\par
235 {\cf22     REQUIRE(checar_solucao(tab) == 0);}\par
236 {\cf22 \}}\par
}
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Sum\'E1rio\par 
\pard\plain 
{\tc \v Sum\'E1rio}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
